"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[9877],{8885:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(9378);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},8895:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"introduction/why-t-ruby","title":"Why T-Ruby?","description":"Benefits and motivation behind T-Ruby","source":"@site/docs/introduction/why-t-ruby.md","sourceDirName":"introduction","slug":"/introduction/why-t-ruby","permalink":"/ja/docs/introduction/why-t-ruby","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/introduction/why-t-ruby.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Why T-Ruby?","description":"Benefits and motivation behind T-Ruby"},"sidebar":"docsSidebar","previous":{"title":"T-Ruby\u3068\u306f\uff1f","permalink":"/ja/docs/introduction/what-is-t-ruby"},"next":{"title":"T-Ruby vs Others","permalink":"/ja/docs/introduction/t-ruby-vs-others"}}');var s=t(2714),i=t(8885);const o={sidebar_position:2,title:"Why T-Ruby?",description:"Benefits and motivation behind T-Ruby"},a="Why T-Ruby?",l={},d=[{value:"The Problem with Dynamic Typing at Scale",id:"the-problem-with-dynamic-typing-at-scale",level:2},{value:"Benefits of T-Ruby",id:"benefits-of-t-ruby",level:2},{value:"1. Catch Bugs Early",id:"1-catch-bugs-early",level:3},{value:"2. Better Developer Experience",id:"2-better-developer-experience",level:3},{value:"3. Gradual Adoption",id:"3-gradual-adoption",level:3},{value:"4. Zero Runtime Cost",id:"4-zero-runtime-cost",level:3},{value:"5. Ecosystem Integration",id:"5-ecosystem-integration",level:3},{value:"When to Use T-Ruby",id:"when-to-use-t-ruby",level:2},{value:"When Types Might Be Overkill",id:"when-types-might-be-overkill",level:2},{value:"The TypeScript Success Story",id:"the-typescript-success-story",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"why-t-ruby",children:"Why T-Ruby?"})}),"\n",(0,s.jsx)(n.p,{children:"Ruby is a beautiful language known for its expressiveness and developer happiness. But as projects grow, the lack of static types can lead to bugs that are hard to catch. T-Ruby addresses this while preserving everything that makes Ruby great."}),"\n",(0,s.jsx)(n.h2,{id:"the-problem-with-dynamic-typing-at-scale",children:"The Problem with Dynamic Typing at Scale"}),"\n",(0,s.jsx)(n.p,{children:"Consider this common scenario:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'# Someone writes this API\ndef fetch_user(id)\n  User.find(id)\nend\n\n# Months later, someone else calls it\nuser = fetch_user("123")  # Bug! Should be an Integer\n'})}),"\n",(0,s.jsx)(n.p,{children:"This bug won't surface until runtime\u2014possibly in production. With T-Ruby:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",metastring:'title="With T-Ruby"',children:'def fetch_user(id: Integer): User\n  User.find(id)\nend\n\nuser = fetch_user("123")  # Compile error! Expected Integer, got String\n'})}),"\n",(0,s.jsx)(n.p,{children:"The error is caught immediately, before the code ever runs."}),"\n",(0,s.jsx)(n.h2,{id:"benefits-of-t-ruby",children:"Benefits of T-Ruby"}),"\n",(0,s.jsx)(n.h3,{id:"1-catch-bugs-early",children:"1. Catch Bugs Early"}),"\n",(0,s.jsx)(n.p,{children:"Type errors are caught at compile time, not runtime. This means:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fewer bugs in production"}),"\n",(0,s.jsx)(n.li,{children:"Faster debugging cycles"}),"\n",(0,s.jsx)(n.li,{children:"More confidence when refactoring"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'def process_payment(amount: Float, currency: String): PaymentResult\n  # Type checker ensures:\n  # - amount is always a Float\n  # - currency is always a String\n  # - Return value must be a PaymentResult\nend\n\n# These would all be compile-time errors:\nprocess_payment("100", "USD")      # Error: String is not Float\nprocess_payment(100.0, :usd)       # Error: Symbol is not String\nprocess_payment(100.0, "USD").foo  # Error: PaymentResult has no method \'foo\'\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-better-developer-experience",children:"2. Better Developer Experience"}),"\n",(0,s.jsx)(n.p,{children:"Types serve as documentation that never goes out of date:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# Without types - what does this return? What should I pass?\ndef transform(data, options = {})\n  # ...\nend\n\n# With types - crystal clear\ndef transform(data: Array<Record>, options: TransformOptions?): TransformResult\n  # ...\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"Your IDE can provide:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Intelligent autocomplete"}),"\n",(0,s.jsx)(n.li,{children:"Inline type information"}),"\n",(0,s.jsx)(n.li,{children:"Refactoring support"}),"\n",(0,s.jsx)(n.li,{children:"Go-to-definition that actually works"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-gradual-adoption",children:"3. Gradual Adoption"}),"\n",(0,s.jsx)(n.p,{children:"You don't have to rewrite your entire codebase. T-Ruby supports gradual typing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# Start with your most critical code\ndef charge_customer(customer_id: Integer, amount: Float): ChargeResult\n  # This function is now type-safe\n  legacy_billing_system(customer_id, amount)\nend\n\n# Legacy code can remain untyped\ndef legacy_billing_system(customer_id, amount)\n  # Still works fine\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-zero-runtime-cost",children:"4. Zero Runtime Cost"}),"\n",(0,s.jsx)(n.p,{children:"Unlike some type systems that add runtime checks, T-Ruby types are completely erased during compilation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",metastring:'title="Before compilation (app.trb)"',children:"def multiply(a: Integer, b: Integer): Integer\n  a * b\nend\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",metastring:'title="After compilation (app.rb)"',children:"def multiply(a, b)\n  a * b\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"The output is exactly what you'd write by hand. No performance overhead, no dependencies, no magic."}),"\n",(0,s.jsx)(n.h3,{id:"5-ecosystem-integration",children:"5. Ecosystem Integration"}),"\n",(0,s.jsx)(n.p,{children:"T-Ruby generates standard RBS files, integrating with the existing Ruby type ecosystem:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.strong,{children:"Steep"})," for additional type checking"]}),"\n",(0,s.jsxs)(n.li,{children:["Get IDE support via ",(0,s.jsx)(n.strong,{children:"Ruby LSP"})]}),"\n",(0,s.jsxs)(n.li,{children:["Compatible with ",(0,s.jsx)(n.strong,{children:"Sorbet"})," type definitions"]}),"\n",(0,s.jsx)(n.li,{children:"Works with all existing Ruby gems"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-t-ruby",children:"When to Use T-Ruby"}),"\n",(0,s.jsx)(n.p,{children:"T-Ruby is particularly valuable for:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Use Case"}),(0,s.jsx)(n.th,{children:"Benefit"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Large codebases"})}),(0,s.jsx)(n.td,{children:"Types prevent bugs and make refactoring safer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Team projects"})}),(0,s.jsx)(n.td,{children:"Types serve as documentation and contracts between developers"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Critical systems"})}),(0,s.jsx)(n.td,{children:"Catch errors before they reach production"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Library authors"})}),(0,s.jsx)(n.td,{children:"Provide type information for users"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Learning Ruby"})}),(0,s.jsx)(n.td,{children:"Types help understand APIs and catch mistakes"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"when-types-might-be-overkill",children:"When Types Might Be Overkill"}),"\n",(0,s.jsx)(n.p,{children:"Types add some overhead. For very small scripts or quick prototypes, untyped Ruby might be more appropriate:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'# For a quick script, this is fine\nputs "Hello, #{ARGV[0]}!"\n\n# No need for:\n# def main(args: Array<String>): void\n#   puts "Hello, #{args[0]}!"\n# end\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The beauty of T-Ruby is that ",(0,s.jsx)(n.strong,{children:"you choose"})," when and where to add types."]}),"\n",(0,s.jsx)(n.h2,{id:"the-typescript-success-story",children:"The TypeScript Success Story"}),"\n",(0,s.jsx)(n.p,{children:"TypeScript proved that adding types to a dynamic language can be done right:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gradual adoption"})," - Start small, grow organically"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type erasure"})," - No runtime overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ecosystem integration"})," - Works with existing code"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"T-Ruby brings this same proven approach to Ruby. If TypeScript made large-scale JavaScript development manageable, T-Ruby can do the same for Ruby."}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Convinced? Let's get started:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/getting-started/installation",children:"Install T-Ruby"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/getting-started/quick-start",children:"Write your first typed Ruby"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/learn/basics/type-annotations",children:"Learn the type system"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);