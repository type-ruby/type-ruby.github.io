"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[3712],{3225:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"learn/advanced/intersection-types","title":"Intersection Types","description":"Combining types with intersection","source":"@site/docs/learn/advanced/intersection-types.md","sourceDirName":"learn/advanced","slug":"/learn/advanced/intersection-types","permalink":"/ja/docs/learn/advanced/intersection-types","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/advanced/intersection-types.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Intersection Types","description":"Combining types with intersection"},"sidebar":"docsSidebar","previous":{"title":"Type Aliases","permalink":"/ja/docs/learn/advanced/type-aliases"},"next":{"title":"Conditional Types","permalink":"/ja/docs/learn/advanced/conditional-types"}}');var a=t(2714),s=t(8885);const r={sidebar_position:2,title:"Intersection Types",description:"Combining types with intersection"},d="Intersection Types",l={},o=[{value:"Understanding Intersection Types",id:"understanding-intersection-types",level:2},{value:"Union vs Intersection",id:"union-vs-intersection",level:3},{value:"Basic Intersection Syntax",id:"basic-intersection-syntax",level:2},{value:"Combining Interfaces",id:"combining-interfaces",level:2},{value:"Mixing Types and Interfaces",id:"mixing-types-and-interfaces",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Mixins Pattern",id:"mixins-pattern",level:3},{value:"Repository Pattern",id:"repository-pattern",level:3},{value:"Event System",id:"event-system",level:3},{value:"Intersection with Generics",id:"intersection-with-generics",level:2},{value:"Type Guards and Narrowing",id:"type-guards-and-narrowing",level:2},{value:"Conflicts and Resolution",id:"conflicts-and-resolution",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Compose Small, Focused Interfaces",id:"1-compose-small-focused-interfaces",level:3},{value:"2. Use Meaningful Names",id:"2-use-meaningful-names",level:3},{value:"3. Don&#39;t Over-Complicate",id:"3-dont-over-complicate",level:3},{value:"4. Document Intent",id:"4-document-intent",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Builder Pattern",id:"builder-pattern",level:3},{value:"State Machine",id:"state-machine",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Cannot Intersect Primitive Types",id:"cannot-intersect-primitive-types",level:3},{value:"Implementation Requirements",id:"implementation-requirements",level:3},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"intersection-types",children:"Intersection Types"})}),"\n",(0,a.jsx)(n.admonition,{title:"Coming Soon",type:"caution",children:(0,a.jsx)(n.p,{children:"This feature is planned for a future release."})}),"\n",(0,a.jsx)(n.p,{children:'Intersection types allow you to combine multiple types into one, creating a type that has all the properties and methods of each combined type. Think of intersection types as "AND" relationships\u2014a value must satisfy all types in the intersection.'}),"\n",(0,a.jsx)(n.h2,{id:"understanding-intersection-types",children:"Understanding Intersection Types"}),"\n",(0,a.jsxs)(n.p,{children:['While union types represent "either-or" relationships (',(0,a.jsx)(n.code,{children:"A | B"}),' means "A OR B"), intersection types represent "and" relationships (',(0,a.jsx)(n.code,{children:"A & B"}),' means "A AND B").']}),"\n",(0,a.jsx)(n.h3,{id:"union-vs-intersection",children:"Union vs Intersection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Union type: value can be String OR Integer\ntype StringOrInt = String | Integer\nvalue1: StringOrInt = "hello"  # OK\nvalue2: StringOrInt = 42       # OK\n\n# Intersection type: value must have properties of BOTH types\ntype NamedAndAged = Named & Aged\n# Must have both name (from Named) and age (from Aged)\n'})}),"\n",(0,a.jsx)(n.h2,{id:"basic-intersection-syntax",children:"Basic Intersection Syntax"}),"\n",(0,a.jsxs)(n.p,{children:["The intersection operator is ",(0,a.jsx)(n.code,{children:"&"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"type Combined = TypeA & TypeB & TypeC\n"})}),"\n",(0,a.jsx)(n.h2,{id:"combining-interfaces",children:"Combining Interfaces"}),"\n",(0,a.jsx)(n.p,{children:"The most common use of intersection types is combining interfaces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Define individual interfaces\ninterface Named\n  def name: String\nend\n\ninterface Aged\n  def age: Integer\nend\n\ninterface Contactable\n  def email: String\n  def phone: String\nend\n\n# Combine interfaces with intersection\ntype Person = Named & Aged\ntype Employee = Named & Aged & Contactable\n\n# A class implementing the intersection must implement all interfaces\nclass User\n  implements Named, Aged\n\n  @name: String\n  @age: Integer\n\n  def initialize(name: String, age: Integer): void\n    @name = name\n    @age = age\n  end\n\n  def name: String\n    @name\n  end\n\n  def age: Integer\n    @age\n  end\nend\n\n# User can be used as Person type\nuser: Person = User.new("Alice", 30)\nputs user.name  # OK: Named interface\nputs user.age   # OK: Aged interface\n'})}),"\n",(0,a.jsx)(n.h2,{id:"mixing-types-and-interfaces",children:"Mixing Types and Interfaces"}),"\n",(0,a.jsx)(n.p,{children:"You can combine interfaces with class types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Base class\nclass Entity\n  @id: Integer\n\n  def initialize(id: Integer): void\n    @id = id\n  end\n\n  def id: Integer\n    @id\n  end\nend\n\n# Interface\ninterface Timestamped\n  def created_at: Time\n  def updated_at: Time\nend\n\n# Intersection of class and interface\ntype TimestampedEntity = Entity & Timestamped\n\n# Implementation must extend Entity AND implement Timestamped\nclass User < Entity\n  implements Timestamped\n\n  @name: String\n  @created_at: Time\n  @updated_at: Time\n\n  def initialize(id: Integer, name: String): void\n    super(id)\n    @name = name\n    @created_at = Time.now\n    @updated_at = Time.now\n  end\n\n  def created_at: Time\n    @created_at\n  end\n\n  def updated_at: Time\n    @updated_at\n  end\nend\n\n# User satisfies the intersection type\nuser: TimestampedEntity = User.new(1, "Alice")\nputs user.id          # From Entity class\nputs user.created_at  # From Timestamped interface\n'})}),"\n",(0,a.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,a.jsx)(n.h3,{id:"mixins-pattern",children:"Mixins Pattern"}),"\n",(0,a.jsx)(n.p,{children:"Intersection types work well with Ruby's mixin concept:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Define capability interfaces\ninterface Serializable\n  def to_json: String\n  def self.from_json(json: String): self\nend\n\ninterface Validatable\n  def valid?: Bool\n  def errors: Array<String>\nend\n\ninterface Persistable\n  def save: Bool\n  def delete: Bool\nend\n\n# Combine capabilities as needed\ntype Model = Serializable & Validatable & Persistable\n\n# A full-featured model class\nclass Article\n  implements Serializable, Validatable, Persistable\n\n  @title: String\n  @content: String\n  @errors: Array<String>\n\n  def initialize(title: String, content: String): void\n    @title = title\n    @content = content\n    @errors = []\n  end\n\n  def to_json: String\n    "{ \\"title\\": \\"#{@title}\\", \\"content\\": \\"#{@content}\\" }"\n  end\n\n  def self.from_json(json: String): Article\n    # Parse JSON and create instance\n    Article.new("Title", "Content")\n  end\n\n  def valid?: Bool\n    @errors = []\n    @errors.push("Title cannot be empty") if @title.empty?\n    @errors.push("Content cannot be empty") if @content.empty?\n    @errors.empty?\n  end\n\n  def errors: Array<String>\n    @errors\n  end\n\n  def save: Bool\n    return false unless valid?\n    # Save to database\n    true\n  end\n\n  def delete: Bool\n    # Delete from database\n    true\n  end\nend\n\n# Article satisfies Model intersection type\narticle: Model = Article.new("Hello", "World")\nputs article.to_json    # Serializable\nputs article.valid?     # Validatable\narticle.save            # Persistable\n'})}),"\n",(0,a.jsx)(n.h3,{id:"repository-pattern",children:"Repository Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"interface Identifiable\n  def id: Integer | String\nend\n\ninterface Timestamped\n  def created_at: Time\n  def updated_at: Time\nend\n\ninterface SoftDeletable\n  def deleted?: Bool\n  def deleted_at: Time | nil\nend\n\n# Different combinations for different needs\ntype BaseEntity = Identifiable & Timestamped\ntype DeletableEntity = Identifiable & Timestamped & SoftDeletable\n\nclass Repository<T: BaseEntity>\n  @items: Array<T>\n\n  def initialize: void\n    @items = []\n  end\n\n  def find(id: Integer | String): T | nil\n    @items.find { |item| item.id == id }\n  end\n\n  def all: Array<T>\n    @items.dup\n  end\n\n  def recent(limit: Integer = 10): Array<T>\n    @items.sort_by { |item| item.created_at }.reverse.take(limit)\n  end\nend\n\nclass SoftDeleteRepository<T: DeletableEntity> < Repository<T>\n  def all: Array<T>\n    @items.reject { |item| item.deleted? }\n  end\n\n  def with_deleted: Array<T>\n    @items.dup\n  end\n\n  def only_deleted: Array<T>\n    @items.select { |item| item.deleted? }\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"event-system",children:"Event System"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'interface Event\n  def event_type: String\n  def timestamp: Time\nend\n\ninterface Cancellable\n  def cancelled?: Bool\n  def cancel: void\nend\n\ninterface Prioritized\n  def priority: Integer\nend\n\n# Different event types with different capabilities\ntype BasicEvent = Event\ntype CancellableEvent = Event & Cancellable\ntype PrioritizedCancellableEvent = Event & Cancellable & Prioritized\n\nclass UserClickEvent\n  implements Event\n\n  @event_type: String\n  @timestamp: Time\n\n  def initialize: void\n    @event_type = "user_click"\n    @timestamp = Time.now\n  end\n\n  def event_type: String\n    @event_type\n  end\n\n  def timestamp: Time\n    @timestamp\n  end\nend\n\nclass NetworkRequestEvent\n  implements Event, Cancellable\n\n  @event_type: String\n  @timestamp: Time\n  @cancelled: Bool\n\n  def initialize: void\n    @event_type = "network_request"\n    @timestamp = Time.now\n    @cancelled = false\n  end\n\n  def event_type: String\n    @event_type\n  end\n\n  def timestamp: Time\n    @timestamp\n  end\n\n  def cancelled?: Bool\n    @cancelled\n  end\n\n  def cancel: void\n    @cancelled = true\n  end\nend\n\nclass CriticalAlertEvent\n  implements Event, Cancellable, Prioritized\n\n  @event_type: String\n  @timestamp: Time\n  @cancelled: Bool\n  @priority: Integer\n\n  def initialize(priority: Integer): void\n    @event_type = "critical_alert"\n    @timestamp = Time.now\n    @cancelled = false\n    @priority = priority\n  end\n\n  def event_type: String\n    @event_type\n  end\n\n  def timestamp: Time\n    @timestamp\n  end\n\n  def cancelled?: Bool\n    @cancelled\n  end\n\n  def cancel: void\n    @cancelled = true\n  end\n\n  def priority: Integer\n    @priority\n  end\nend\n\n# Event handlers for different event types\ndef handle_basic_event(event: BasicEvent): void\n  puts "Event: #{event.event_type} at #{event.timestamp}"\nend\n\ndef handle_cancellable_event(event: CancellableEvent): void\n  if event.cancelled?\n    puts "Event #{event.event_type} was cancelled"\n  else\n    puts "Processing #{event.event_type}"\n  end\nend\n\ndef handle_priority_event(event: PrioritizedCancellableEvent): void\n  puts "Priority #{event.priority}: #{event.event_type}"\n  event.cancel if event.priority < 5\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"intersection-with-generics",children:"Intersection with Generics"}),"\n",(0,a.jsx)(n.p,{children:"Intersection types can be combined with generics:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Generic type with intersection constraint\ndef process<T: Serializable & Validatable>(item: T): Bool\n  if item.valid?\n    json = item.to_json\n    # Send to API\n    true\n  else\n    puts \"Validation errors: #{item.errors.join(', ')}\"\n    false\n  end\nend\n\n# Collection that requires multiple capabilities\nclass ValidatedCollection<T: Identifiable & Validatable>\n  @items: Array<T>\n\n  def initialize: void\n    @items = []\n  end\n\n  def add(item: T): Bool\n    if item.valid?\n      @items.push(item)\n      true\n    else\n      false\n    end\n  end\n\n  def find(id: Integer | String): T | nil\n    @items.find { |item| item.id == id }\n  end\n\n  def all_valid: Array<T>\n    @items.select { |item| item.valid? }\n  end\n\n  def all_invalid: Array<T>\n    @items.reject { |item| item.valid? }\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"type-guards-and-narrowing",children:"Type Guards and Narrowing"}),"\n",(0,a.jsx)(n.p,{children:"Intersection types work with type narrowing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'interface Animal\n  def speak: String\nend\n\ninterface Swimmable\n  def swim: void\nend\n\ninterface Flyable\n  def fly: void\nend\n\ntype Duck = Animal & Swimmable & Flyable\n\nclass DuckImpl\n  implements Animal, Swimmable, Flyable\n\n  def speak: String\n    "Quack!"\n  end\n\n  def swim: void\n    puts "Swimming..."\n  end\n\n  def fly: void\n    puts "Flying..."\n  end\nend\n\ndef test_duck(animal: Animal): void\n  puts animal.speak\n\n  # Type narrowing with responds_to?\n  if animal.responds_to?(:swim) && animal.responds_to?(:fly)\n    # Here animal is treated as Duck (Animal & Swimmable & Flyable)\n    duck = animal as Duck\n    duck.swim\n    duck.fly\n  end\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"conflicts-and-resolution",children:"Conflicts and Resolution"}),"\n",(0,a.jsx)(n.p,{children:"When intersection types have conflicting members, the more specific type wins:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"interface HasName\n  def name: String\nend\n\ninterface HasOptionalName\n  def name: String | nil\nend\n\n# The intersection requires the more restrictive type\ntype Person = HasName & HasOptionalName\n# person.name must be String (not String | nil)\n# because String is more specific than String | nil\n\nclass User\n  implements HasName, HasOptionalName\n\n  @name: String\n\n  def initialize(name: String): void\n    @name = name\n  end\n\n  # Must return String to satisfy both interfaces\n  def name: String\n    @name\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-compose-small-focused-interfaces",children:"1. Compose Small, Focused Interfaces"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Good: Small, single-responsibility interfaces\ninterface Identifiable\n  def id: Integer\nend\n\ninterface Named\n  def name: String\nend\n\ninterface Timestamped\n  def created_at: Time\nend\n\ntype Entity = Identifiable & Named & Timestamped\n\n# Less good: Large, monolithic interface\ninterface Entity\n  def id: Integer\n  def name: String\n  def created_at: Time\n  def updated_at: Time\n  def save: Bool\n  def delete: Bool\n  # Too many responsibilities\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-use-meaningful-names",children:"2. Use Meaningful Names"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Good: Clear what the intersection represents\ntype AuditedEntity = Entity & Auditable\ntype SerializableModel = Model & Serializable\n\n# Less good: Generic names\ntype TypeA = Interface1 & Interface2\ntype Combined = Foo & Bar\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-dont-over-complicate",children:"3. Don't Over-Complicate"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Good: Reasonable number of intersections\ntype FullModel = Identifiable & Timestamped & Validatable\n\n# Potentially problematic: Too many intersections\ntype SuperType = A & B & C & D & E & F & G & H\n# Hard to implement and understand\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-document-intent",children:"4. Document Intent"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Good: Comment explains why intersection is needed\n# Represents entities that can be both serialized and cached\ntype CacheableEntity = Serializable & Identifiable\n\n# Cache implementation\nclass Cache<T: CacheableEntity>\n  @store: Hash<Integer | String, String>\n\n  def set(entity: T): void\n    @store[entity.id] = entity.to_json\n  end\n\n  def get(id: Integer | String): String | nil\n    @store[id]\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"builder-pattern",children:"Builder Pattern"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'interface Buildable\n  def build: self\nend\n\ninterface Validatable\n  def valid?: Bool\nend\n\ninterface Resettable\n  def reset: void\nend\n\ntype CompleteBuilder = Buildable & Validatable & Resettable\n\nclass FormBuilder\n  implements Buildable, Validatable, Resettable\n\n  @fields: Hash<String, String>\n  @errors: Array<String>\n\n  def initialize: void\n    @fields = {}\n    @errors = []\n  end\n\n  def add_field(name: String, value: String): self\n    @fields[name] = value\n    self\n  end\n\n  def build: self\n    self\n  end\n\n  def valid?: Bool\n    @errors = []\n    @errors.push("No fields") if @fields.empty?\n    @errors.empty?\n  end\n\n  def reset: void\n    @fields = {}\n    @errors = []\n  end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"state-machine",children:"State Machine"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'interface State\n  def name: String\nend\n\ninterface Transitionable\n  def can_transition_to?(state: String): Bool\n  def transition_to(state: String): void\nend\n\ninterface Observable\n  def on_enter: void\n  def on_exit: void\nend\n\ntype ManagedState = State & Transitionable & Observable\n\nclass WorkflowState\n  implements State, Transitionable, Observable\n\n  @name: String\n  @allowed_transitions: Array<String>\n\n  def initialize(name: String, allowed_transitions: Array<String>): void\n    @name = name\n    @allowed_transitions = allowed_transitions\n  end\n\n  def name: String\n    @name\n  end\n\n  def can_transition_to?(state: String): Bool\n    @allowed_transitions.include?(state)\n  end\n\n  def transition_to(state: String): void\n    if can_transition_to?(state)\n      on_exit\n      # Perform transition\n      on_enter\n    else\n      raise "Invalid transition from #{@name} to #{state}"\n    end\n  end\n\n  def on_enter: void\n    puts "Entering state: #{@name}"\n  end\n\n  def on_exit: void\n    puts "Exiting state: #{@name}"\n  end\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsx)(n.h3,{id:"cannot-intersect-primitive-types",children:"Cannot Intersect Primitive Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# This doesn't make sense - a value can't be both String AND Integer\n# type Impossible = String & Integer  # Would be empty type\n\n# Intersection makes sense for structural types (interfaces, classes)\ntype Valid = Interface1 & Interface2\n"})}),"\n",(0,a.jsx)(n.h3,{id:"implementation-requirements",children:"Implementation Requirements"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# When using intersection, implementation must satisfy ALL parts\ntype Complete = Interface1 & Interface2 & Interface3\n\nclass MyClass\n  # Must implement ALL of: Interface1, Interface2, Interface3\n  implements Interface1, Interface2, Interface3\n  # ...\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"Now that you understand intersection types, explore:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/learn/everyday-types/union-types",children:"Union Types"}),' for "or" type relationships']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/learn/advanced/type-aliases",children:"Type Aliases"})," for naming complex intersections"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/learn/interfaces/defining-interfaces",children:"Interfaces"})," to create the building blocks for intersections"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/learn/advanced/conditional-types",children:"Conditional Types"})," for types that depend on conditions"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8885:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(9378);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);