"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[7196],{8756:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>g,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"learn/generics/built-in-generics","title":"Built-in Generics","description":"Array, Hash, and other built-in generic types","source":"@site/docs/learn/generics/built-in-generics.md","sourceDirName":"learn/generics","slug":"/learn/generics/built-in-generics","permalink":"/ja/docs/learn/generics/built-in-generics","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/generics/built-in-generics.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Built-in Generics","description":"Array, Hash, and other built-in generic types"},"sidebar":"docsSidebar","previous":{"title":"Constraints","permalink":"/ja/docs/learn/generics/constraints"},"next":{"title":"Type Aliases","permalink":"/ja/docs/learn/advanced/type-aliases"}}');var a=r(2714),i=r(8885);const t={sidebar_position:3,title:"Built-in Generics",description:"Array, Hash, and other built-in generic types"},l="Built-in Generics",o={},c=[{value:"Array&lt;T&gt;",id:"arrayt",level:2},{value:"Basic Array Usage",id:"basic-array-usage",level:3},{value:"Array Operations",id:"array-operations",level:3},{value:"Array Mapping and Transformation",id:"array-mapping-and-transformation",level:3},{value:"Array Filtering",id:"array-filtering",level:3},{value:"Array Reduction",id:"array-reduction",level:3},{value:"Nested Arrays",id:"nested-arrays",level:3},{value:"Hash&lt;K, V&gt;",id:"hashk-v",level:2},{value:"Basic Hash Usage",id:"basic-hash-usage",level:3},{value:"Hash Operations",id:"hash-operations",level:3},{value:"Hash Iteration",id:"hash-iteration",level:3},{value:"Complex Hash Types",id:"complex-hash-types",level:3},{value:"Set&lt;T&gt;",id:"sett",level:2},{value:"Range&lt;T&gt;",id:"ranget",level:2},{value:"Enumerator&lt;T&gt;",id:"enumeratort",level:2},{value:"Proc&lt;Args, Return&gt;",id:"procargs-return",level:2},{value:"Optional Types with Nilable",id:"optional-types-with-nilable",level:2},{value:"Combining Generic Types",id:"combining-generic-types",level:2},{value:"Type Aliases for Built-in Generics",id:"type-aliases-for-built-in-generics",level:2},{value:"Working with Built-in Methods",id:"working-with-built-in-methods",level:2},{value:"Default Values and Safety",id:"default-values-and-safety",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Prefer Specific Types Over Any",id:"1-prefer-specific-types-over-any",level:3},{value:"2. Use Type Aliases for Complex Types",id:"2-use-type-aliases-for-complex-types",level:3},{value:"3. Handle Nil Values Explicitly",id:"3-handle-nil-values-explicitly",level:3},{value:"4. Use Appropriate Collection Types",id:"4-use-appropriate-collection-types",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Safe Array Access",id:"safe-array-access",level:3},{value:"Grouping with Hashes",id:"grouping-with-hashes",level:3},{value:"Memoization with Hashes",id:"memoization-with-hashes",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"built-in-generics",children:"Built-in Generics"})}),"\n",(0,a.jsx)(n.p,{children:"T-Ruby comes with several built-in generic types that you'll use every day. These types are parameterized to work with any type while providing type safety. Understanding how to use these built-in generics is essential for writing type-safe T-Ruby code."}),"\n",(0,a.jsx)(n.h2,{id:"arrayt",children:"Array<T>"}),"\n",(0,a.jsxs)(n.p,{children:["The most commonly used generic type is ",(0,a.jsx)(n.code,{children:"Array<T>"}),", representing an array of elements of type ",(0,a.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"basic-array-usage",children:"Basic Array Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Explicitly typed arrays\nnumbers: Array<Integer> = [1, 2, 3, 4, 5]\nnames: Array<String> = ["Alice", "Bob", "Charlie"]\nflags: Array<Bool> = [true, false, true]\n\n# Type inference works too\ninferred_numbers = [1, 2, 3]  # Array<Integer>\ninferred_names = ["Alice", "Bob"]  # Array<String>\n\n# Empty arrays need explicit types\nempty_numbers: Array<Integer> = []\nempty_users = Array<User>.new\n'})}),"\n",(0,a.jsx)(n.h3,{id:"array-operations",children:"Array Operations"}),"\n",(0,a.jsx)(n.p,{children:"All standard array operations preserve type safety:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"numbers: Array<Integer> = [1, 2, 3, 4, 5]\n\n# Accessing elements\nfirst: Integer | nil = numbers[0]      # 1\nlast: Integer | nil = numbers[-1]      # 5\nout_of_bounds: Integer | nil = numbers[100]  # nil\n\n# Adding elements\nnumbers.push(6)        # Array<Integer>\nnumbers << 7           # Array<Integer>\nnumbers.unshift(0)     # Array<Integer>\n\n# Removing elements\npopped: Integer | nil = numbers.pop      # Removes and returns last\nshifted: Integer | nil = numbers.shift   # Removes and returns first\n\n# Checking contents\ncontains_three: Bool = numbers.include?(3)  # true\nindex: Integer | nil = numbers.index(3)     # 2\n"})}),"\n",(0,a.jsx)(n.h3,{id:"array-mapping-and-transformation",children:"Array Mapping and Transformation"}),"\n",(0,a.jsxs)(n.p,{children:["Mapping transforms an ",(0,a.jsx)(n.code,{children:"Array<T>"})," into an ",(0,a.jsx)(n.code,{children:"Array<U>"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Map integers to strings\nnumbers: Array<Integer> = [1, 2, 3, 4, 5]\nstrings: Array<String> = numbers.map { |n| n.to_s }\n# Result: ["1", "2", "3", "4", "5"]\n\n# Map strings to their lengths\nwords: Array<String> = ["hello", "world", "ruby"]\nlengths: Array<Integer> = words.map { |w| w.length }\n# Result: [5, 5, 4]\n\n# Map to complex types\nclass Person\n  @name: String\n  @age: Integer\n\n  def initialize(name: String, age: Integer): void\n    @name = name\n    @age = age\n  end\n\n  def name: String\n    @name\n  end\nend\n\nnames: Array<String> = ["Alice", "Bob"]\npeople: Array<Person> = names.map { |name| Person.new(name, 25) }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"array-filtering",children:"Array Filtering"}),"\n",(0,a.jsx)(n.p,{children:"Filtering maintains the same type:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'numbers: Array<Integer> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Filter for even numbers\nevens: Array<Integer> = numbers.select { |n| n.even? }\n# Result: [2, 4, 6, 8, 10]\n\n# Filter for odd numbers\nodds: Array<Integer> = numbers.reject { |n| n.even? }\n# Result: [1, 3, 5, 7, 9]\n\n# Find first matching element\nfirst_even: Integer | nil = numbers.find { |n| n.even? }\n# Result: 2\n\n# Filter with complex conditions\nwords: Array<String> = ["hello", "world", "hi", "ruby", "typescript"]\nlong_words: Array<String> = words.select { |w| w.length > 4 }\n# Result: ["hello", "world", "typescript"]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"array-reduction",children:"Array Reduction"}),"\n",(0,a.jsx)(n.p,{children:"Reduce collapses an array into a single value:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'numbers: Array<Integer> = [1, 2, 3, 4, 5]\n\n# Sum all numbers\nsum: Integer = numbers.reduce(0) { |acc, n| acc + n }\n# Result: 15\n\n# Find maximum\nmax: Integer = numbers.reduce(numbers[0]) { |max, n| n > max ? n : max }\n# Result: 5\n\n# Concatenate strings\nwords: Array<String> = ["Hello", "World", "from", "T-Ruby"]\nsentence: String = words.reduce("") { |acc, w| acc.empty? ? w : "#{acc} #{w}" }\n# Result: "Hello World from T-Ruby"\n\n# Build a hash from array\npairs: Array<Array<String>> = [["name", "Alice"], ["age", "30"]]\nhash: Hash<String, String> = pairs.reduce({}) { |h, pair|\n  h[pair[0]] = pair[1]\n  h\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"nested-arrays",children:"Nested Arrays"}),"\n",(0,a.jsx)(n.p,{children:"Arrays can be nested to any depth:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Two-dimensional array (matrix)\nmatrix: Array<Array<Integer>> = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n]\n\n# Accessing nested elements\nfirst_row: Array<Integer> = matrix[0]      # [1, 2, 3]\nelement: Integer | nil = matrix[1][2]      # 6\n\n# Three-dimensional array\ncube: Array<Array<Array<Integer>>> = [\n  [[1, 2], [3, 4]],\n  [[5, 6], [7, 8]]\n]\n\n# Flatten nested arrays\nnested: Array<Array<Integer>> = [[1, 2], [3, 4], [5, 6]]\nflat: Array<Integer> = nested.flatten\n# Result: [1, 2, 3, 4, 5, 6]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hashk-v",children:"Hash<K, V>"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Hash<K, V>"})," represents a hash map with keys of type ",(0,a.jsx)(n.code,{children:"K"})," and values of type ",(0,a.jsx)(n.code,{children:"V"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"basic-hash-usage",children:"Basic Hash Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Explicitly typed hashes\nages: Hash<String, Integer> = {\n  "Alice" => 30,\n  "Bob" => 25,\n  "Charlie" => 35\n}\n\n# Symbol keys\nconfig: Hash<Symbol, String> = {\n  database: "postgresql",\n  host: "localhost",\n  port: "5432"\n}\n\n# Type inference\ninferred = { "key" => "value" }  # Hash<String, String>\n\n# Empty hashes need explicit types\nempty_hash: Hash<String, Integer> = {}\nempty_map = Hash<Symbol, Array<String>>.new\n'})}),"\n",(0,a.jsx)(n.h3,{id:"hash-operations",children:"Hash Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'ages: Hash<String, Integer> = {\n  "Alice" => 30,\n  "Bob" => 25\n}\n\n# Accessing values\nalice_age: Integer | nil = ages["Alice"]   # 30\nmissing: Integer | nil = ages["Charlie"]   # nil\n\n# Adding/updating values\nages["Charlie"] = 35\nages["Alice"] = 31  # Update existing\n\n# Removing values\nremoved: Integer | nil = ages.delete("Bob")  # Returns 25\n\n# Checking keys\nhas_alice: Bool = ages.key?("Alice")      # true\nhas_bob: Bool = ages.key?("Bob")          # false (deleted)\n\n# Getting keys and values\nkeys: Array<String> = ages.keys           # ["Alice", "Charlie"]\nvalues: Array<Integer> = ages.values      # [31, 35]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"hash-iteration",children:"Hash Iteration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'scores: Hash<String, Integer> = {\n  "Alice" => 95,\n  "Bob" => 87,\n  "Charlie" => 92\n}\n\n# Iterate over key-value pairs\nscores.each do |name, score|\n  puts "#{name}: #{score}"\nend\n\n# Map to arrays\nname_score_pairs: Array<String> = scores.map { |name, score|\n  "#{name} scored #{score}"\n}\n\n# Filter hash\nhigh_scores: Hash<String, Integer> = scores.select { |_, score| score >= 90 }\n# Result: { "Alice" => 95, "Charlie" => 92 }\n\n# Transform values\ndoubled: Hash<String, Integer> = scores.transform_values { |score| score * 2 }\n# Result: { "Alice" => 190, "Bob" => 174, "Charlie" => 184 }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"complex-hash-types",children:"Complex Hash Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Hash with array values\ntags: Hash<String, Array<String>> = {\n  "ruby" => ["programming", "language"],\n  "rails" => ["framework", "web"],\n  "postgres" => ["database", "sql"]\n}\n\n# Add to array value\ntags["ruby"].push("dynamic")\n\n# Hash with hash values (nested)\nusers: Hash<String, Hash<Symbol, String | Integer>> = {\n  "user1" => { name: "Alice", age: 30, email: "alice@example.com" },\n  "user2" => { name: "Bob", age: 25, email: "bob@example.com" }\n}\n\n# Access nested values\nuser1_name = users["user1"][:name]  # "Alice"\n\n# Hash with custom types\nclass User\n  @name: String\n  @email: String\n\n  def initialize(name: String, email: String): void\n    @name = name\n    @email = email\n  end\nend\n\nuser_map: Hash<Integer, User> = {\n  1 => User.new("Alice", "alice@example.com"),\n  2 => User.new("Bob", "bob@example.com")\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"sett",children:"Set<T>"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Set<T>"})," represents an unordered collection of unique elements of type ",(0,a.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Creating sets\nnumbers: Set<Integer> = Set.new([1, 2, 3, 4, 5])\nunique_words: Set<String> = Set.new(["hello", "world", "hello"])\n# unique_words contains: {"hello", "world"}\n\n# Adding elements\nnumbers.add(6)\nnumbers.add(3)  # Already exists, no duplicate\n\n# Removing elements\nnumbers.delete(2)\n\n# Checking membership\ncontains_three: Bool = numbers.include?(3)  # true\n\n# Set operations\nset1: Set<Integer> = Set.new([1, 2, 3, 4])\nset2: Set<Integer> = Set.new([3, 4, 5, 6])\n\nunion: Set<Integer> = set1 | set2           # {1, 2, 3, 4, 5, 6}\nintersection: Set<Integer> = set1 & set2    # {3, 4}\ndifference: Set<Integer> = set1 - set2      # {1, 2}\n\n# Convert to array\narray: Array<Integer> = numbers.to_a\n'})}),"\n",(0,a.jsx)(n.h2,{id:"ranget",children:"Range<T>"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Range<T>"})," represents a range of values from a start to an end."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Integer ranges\none_to_ten: Range<Integer> = 1..10      # Inclusive: 1, 2, ..., 10\none_to_nine: Range<Integer> = 1...10    # Exclusive: 1, 2, ..., 9\n\n# Check if range includes a value\nincludes_five: Bool = one_to_ten.include?(5)  # true\n\n# Convert to array\nnumbers: Array<Integer> = (1..5).to_a   # [1, 2, 3, 4, 5]\n\n# Iterate over range\n(1..5).each do |i|\n  puts i\nend\n\n# Character ranges\nalphabet: Range<String> = \'a\'..\'z\'\nletters: Array<String> = (\'a\'..\'e\').to_a  # ["a", "b", "c", "d", "e"]\n'})}),"\n",(0,a.jsx)(n.h2,{id:"enumeratort",children:"Enumerator<T>"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Enumerator<T>"})," represents a lazy enumeration of type ",(0,a.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Create an enumerator\nnumbers: Array<Integer> = [1, 2, 3, 4, 5]\nenum: Enumerator<Integer> = numbers.each\n\n# Lazy evaluation\nlarge_range: Enumerator<Integer> = (1..1_000_000).lazy\nsquares: Enumerator<Integer> = large_range.map { |n| n * n }\nfirst_five_squares: Array<Integer> = squares.first(5)\n# Only computes first 5, not all 1 million\n\n# Chain operations lazily\nresult = (1..Float::INFINITY)\n  .lazy\n  .select { |n| n.even? }\n  .map { |n| n * 2 }\n  .first(10)\n# Efficiently gets first 10 results without infinite loop\n"})}),"\n",(0,a.jsx)(n.h2,{id:"procargs-return",children:"Proc<Args, Return>"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Proc<Args, Return>"})," represents a proc/lambda with typed parameters and return type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Simple proc\ndoubler: Proc<Integer, Integer> = ->(x: Integer): Integer { x * 2 }\nresult = doubler.call(5)  # 10\n\n# Proc with multiple parameters\nadder: Proc<Integer, Integer, Integer> = ->(x: Integer, y: Integer): Integer { x + y }\nsum = adder.call(3, 4)  # 7\n\n# Proc with no return value\nprinter: Proc<String, void> = ->(msg: String): void { puts msg }\nprinter.call("Hello!")\n\n# Proc as parameter\ndef apply_twice<T>(value: T, fn: Proc<T, T>): T\n  fn.call(fn.call(value))\nend\n\nresult = apply_twice(5, doubler)  # 20 (5 * 2 * 2)\n\n# Array of procs\noperations: Array<Proc<Integer, Integer>> = [\n  ->(x: Integer): Integer { x + 1 },\n  ->(x: Integer): Integer { x * 2 },\n  ->(x: Integer): Integer { x - 3 }\n]\n\nresult = operations.reduce(10) { |acc, op| op.call(acc) }\n# 10 + 1 = 11, 11 * 2 = 22, 22 - 3 = 19\n'})}),"\n",(0,a.jsx)(n.h2,{id:"optional-types-with-nilable",children:"Optional Types with Nilable"}),"\n",(0,a.jsxs)(n.p,{children:["While not strictly a generic, ",(0,a.jsx)(n.code,{children:"T | nil"})," is used so frequently it deserves mention. T-Ruby also supports the shorthand ",(0,a.jsx)(n.code,{children:"T?"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Explicit optional type\nname: String | nil = "Alice"\nage: Integer | nil = nil\n\n# Shorthand syntax\nname: String? = "Alice"\nage: Integer? = nil\n\n# Working with optional arrays\nnumbers: Array<Integer>? = [1, 2, 3]\nnumbers = nil\n\n# Array of optional elements\nnumbers: Array<Integer | nil> = [1, nil, 3, nil, 5]\nnumbers: Array<Integer?> = [1, nil, 3, nil, 5]  # Same as above\n\n# Optional hash\nconfig: Hash<String, String>? = { "key" => "value" }\nconfig = nil\n\n# Hash with optional values\nsettings: Hash<String, String | nil> = {\n  "name" => "MyApp",\n  "description" => nil\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"combining-generic-types",children:"Combining Generic Types"}),"\n",(0,a.jsx)(n.p,{children:"Generic types can be combined in powerful ways:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Array of hashes\nusers: Array<Hash<Symbol, String | Integer>> = [\n  { name: "Alice", age: 30 },\n  { name: "Bob", age: 25 }\n]\n\n# Hash of arrays\ntags_by_category: Hash<String, Array<String>> = {\n  "colors" => ["red", "blue", "green"],\n  "sizes" => ["small", "medium", "large"]\n}\n\n# Array of arrays (matrix)\nmatrix: Array<Array<Integer>> = [\n  [1, 2, 3],\n  [4, 5, 6]\n]\n\n# Hash with complex values\ncache: Hash<String, Array<Hash<Symbol, String>>> = {\n  "users" => [\n    { id: "1", name: "Alice" },\n    { id: "2", name: "Bob" }\n  ]\n}\n\n# Optional array of optional values\ndata: Array<Integer | nil>? = [1, nil, 3]\ndata = nil\n'})}),"\n",(0,a.jsx)(n.h2,{id:"type-aliases-for-built-in-generics",children:"Type Aliases for Built-in Generics"}),"\n",(0,a.jsx)(n.p,{children:"Create readable aliases for complex generic types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Simple aliases\ntype StringArray = Array<String>\ntype IntHash = Hash<String, Integer>\n\n# Complex aliases\ntype UserData = Hash<Symbol, String | Integer>\ntype UserList = Array<UserData>\ntype TagMap = Hash<String, Array<String>>\n\n# Using aliases\nusers: UserList = [\n  { name: "Alice", age: 30 },\n  { name: "Bob", age: 25 }\n]\n\ntags: TagMap = {\n  "ruby" => ["language", "dynamic"],\n  "typescript" => ["language", "static"]\n}\n\n# Generic aliases\ntype Result<T> = T | nil\ntype Callback<T> = Proc<T, void>\ntype Transformer<T, U> = Proc<T, U>\n\n# Using generic aliases\nfind_user: Result<User> = User.find(1)\non_success: Callback<String> = ->(msg: String): void { puts msg }\nto_string: Transformer<Integer, String> = ->(n: Integer): String { n.to_s }\n'})}),"\n",(0,a.jsx)(n.h2,{id:"working-with-built-in-methods",children:"Working with Built-in Methods"}),"\n",(0,a.jsx)(n.p,{children:"T-Ruby's type system understands Ruby's built-in array and hash methods:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Array methods preserve types\nnumbers: Array<Integer> = [1, 2, 3, 4, 5]\n\nfirst_three: Array<Integer> = numbers.take(3)        # [1, 2, 3]\nlast_two: Array<Integer> = numbers.drop(3)           # [4, 5]\nreversed: Array<Integer> = numbers.reverse           # [5, 4, 3, 2, 1]\nunique: Array<Integer> = [1, 2, 2, 3].uniq          # [1, 2, 3]\nsorted: Array<Integer> = [3, 1, 2].sort             # [1, 2, 3]\n\n# Combining arrays\ncombined: Array<Integer> = numbers + [6, 7, 8]      # [1, 2, 3, 4, 5, 6, 7, 8]\nintersection: Array<Integer> = [1, 2, 3] & [2, 3, 4]  # [2, 3]\ndifference: Array<Integer> = [1, 2, 3] - [2, 3]       # [1]\n\n# Hash methods\nhash: Hash<String, Integer> = { "a" => 1, "b" => 2 }\n\nmerged: Hash<String, Integer> = hash.merge({ "c" => 3 })\ninverted: Hash<Integer, String> = hash.invert       # { 1 => "a", 2 => "b" }\n'})}),"\n",(0,a.jsx)(n.h2,{id:"default-values-and-safety",children:"Default Values and Safety"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Hash with default value\ncounts: Hash<String, Integer> = Hash.new(0)\ncounts["a"] += 1  # Safe: default is 0\n\n# Hash with default block\ngroups: Hash<String, Array<String>> = Hash.new { |h, k| h[k] = [] }\ngroups["colors"].push("red")  # Safe: creates array if missing\n\n# Array fetch with default\nnumbers: Array<Integer> = [1, 2, 3]\nvalue: Integer = numbers.fetch(10, 0)  # Returns 0 if index out of bounds\n\n# Hash fetch with default\nconfig: Hash<String, String> = { "name" => "MyApp" }\nport: String = config.fetch("port", "3000")  # Returns "3000" if key missing\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-prefer-specific-types-over-any",children:"1. Prefer Specific Types Over Any"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Good: Specific types\nusers: Array<User> = []\nconfig: Hash<Symbol, String> = {}\n\n# Avoid: Using Any loses type safety\ndata: Array<Any> = []  # No type checking\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-use-type-aliases-for-complex-types",children:"2. Use Type Aliases for Complex Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Good: Clear, reusable alias\ntype UserMap = Hash<Integer, User>\ntype ErrorList = Array<String>\n\ndef process_users(users: UserMap): ErrorList\n  # ...\nend\n\n# Less good: Repeated complex types\ndef process_users(users: Hash<Integer, User>): Array<String>\n  # ...\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-handle-nil-values-explicitly",children:"3. Handle Nil Values Explicitly"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'# Good: Explicit nil handling\nusers: Array<User> = []\nfirst_user: User | nil = users.first\n\nif first_user\n  puts first_user.name\nelse\n  puts "No users found"\nend\n\n# Dangerous: Assuming non-nil\n# first_user.name  # Could crash if nil!\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-use-appropriate-collection-types",children:"4. Use Appropriate Collection Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"# Good: Use Set for unique items\nunique_tags: Set<String> = Set.new\n\n# Less efficient: Using Array for uniqueness\nunique_tags: Array<String> = []\nunique_tags.push(tag) unless unique_tags.include?(tag)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"safe-array-access",children:"Safe Array Access"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"def safe_get<T>(array: Array<T>, index: Integer, default: T): T\n  array.fetch(index, default)\nend\n\nnumbers = [1, 2, 3]\nvalue = safe_get(numbers, 10, 0)  # Returns 0 instead of nil\n"})}),"\n",(0,a.jsx)(n.h3,{id:"grouping-with-hashes",children:"Grouping with Hashes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:'class Person\n  @name: String\n  @age: Integer\n\n  def initialize(name: String, age: Integer): void\n    @name = name\n    @age = age\n  end\n\n  def age: Integer\n    @age\n  end\nend\n\npeople: Array<Person> = [\n  Person.new("Alice", 30),\n  Person.new("Bob", 25),\n  Person.new("Charlie", 30)\n]\n\n# Group by age\nby_age: Hash<Integer, Array<Person>> = people.group_by { |p| p.age }\n# { 30 => [Alice, Charlie], 25 => [Bob] }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"memoization-with-hashes",children:"Memoization with Hashes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"class Calculator\n  @cache: Hash<Integer, Integer>\n\n  def initialize: void\n    @cache = {}\n  end\n\n  def expensive_calculation(n: Integer): Integer\n    if @cache.key?(n)\n      @cache[n]\n    else\n      result = n * n  # Expensive operation\n      @cache[n] = result\n      result\n    end\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"Now that you understand T-Ruby's built-in generic types, you can:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Explore ",(0,a.jsx)(n.a,{href:"/docs/learn/advanced/type-aliases",children:"Type Aliases"})," to create custom names for complex types"]}),"\n",(0,a.jsxs)(n.li,{children:["Learn about ",(0,a.jsx)(n.a,{href:"/docs/learn/advanced/utility-types",children:"Utility Types"})," for advanced type transformations"]}),"\n",(0,a.jsxs)(n.li,{children:["See ",(0,a.jsx)(n.a,{href:"/docs/learn/generics/generic-functions-classes",children:"Generic Functions & Classes"})," to create your own generic types"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8885:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var s=r(9378);const a={},i=s.createContext(a);function t(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);