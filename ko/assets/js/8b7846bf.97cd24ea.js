"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[8354],{6880:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"learn/basics/type-inference","title":"Type Inference","description":"How T-Ruby automatically infers types","source":"@site/docs/learn/basics/type-inference.md","sourceDirName":"learn/basics","slug":"/learn/basics/type-inference","permalink":"/ko/docs/learn/basics/type-inference","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/basics/type-inference.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Type Inference","description":"How T-Ruby automatically infers types"},"sidebar":"docsSidebar","previous":{"title":"Basic Types","permalink":"/ko/docs/learn/basics/basic-types"},"next":{"title":"Primitives","permalink":"/ko/docs/learn/everyday-types/primitives"}}');var r=t(2714),i=t(8885);const l={sidebar_position:3,title:"Type Inference",description:"How T-Ruby automatically infers types"},s="Type Inference",c={},o=[{value:"What Is Type Inference?",id:"what-is-type-inference",level:2},{value:"Basic Inference Example",id:"basic-inference-example",level:3},{value:"How Type Inference Works",id:"how-type-inference-works",level:2},{value:"Literal-Based Inference",id:"literal-based-inference",level:3},{value:"Expression-Based Inference",id:"expression-based-inference",level:3},{value:"Method Return Type Inference",id:"method-return-type-inference",level:3},{value:"When Inference Works Best",id:"when-inference-works-best",level:2},{value:"Local Variables",id:"local-variables",level:3},{value:"Array and Hash Inference",id:"array-and-hash-inference",level:3},{value:"Block Parameter Inference",id:"block-parameter-inference",level:3},{value:"When to Add Explicit Annotations",id:"when-to-add-explicit-annotations",level:2},{value:"1. Method Signatures (Always)",id:"1-method-signatures-always",level:3},{value:"2. Instance Variables",id:"2-instance-variables",level:3},{value:"3. Ambiguous Situations",id:"3-ambiguous-situations",level:3},{value:"4. Union Types",id:"4-union-types",level:3},{value:"5. Public APIs",id:"5-public-apis",level:3},{value:"Inference with Control Flow",id:"inference-with-control-flow",level:2},{value:"If Statements",id:"if-statements",level:3},{value:"Case Statements",id:"case-statements",level:3},{value:"Common Inference Patterns",id:"common-inference-patterns",level:2},{value:"Pattern 1: Initialize Then Use",id:"pattern-1-initialize-then-use",level:3},{value:"Pattern 2: Accumulator Variables",id:"pattern-2-accumulator-variables",level:3},{value:"Pattern 3: Builder Pattern",id:"pattern-3-builder-pattern",level:3},{value:"Limitations of Type Inference",id:"limitations-of-type-inference",level:2},{value:"Empty Collections",id:"empty-collections",level:3},{value:"Complex Union Types",id:"complex-union-types",level:3},{value:"Recursive Functions",id:"recursive-functions",level:3},{value:"Best Practices for Type Inference",id:"best-practices-for-type-inference",level:2},{value:"1. Let Inference Handle Local Variables",id:"1-let-inference-handle-local-variables",level:3},{value:"2. Annotate When Sharing Across Scopes",id:"2-annotate-when-sharing-across-scopes",level:3},{value:"3. Prefer Inference for Intermediate Calculations",id:"3-prefer-inference-for-intermediate-calculations",level:3},{value:"4. Annotate for Clarity in Complex Logic",id:"4-annotate-for-clarity-in-complex-logic",level:3},{value:"Practical Example: Invoice Calculator",id:"practical-example-invoice-calculator",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"type-inference",children:"Type Inference"})}),"\n",(0,r.jsx)(n.p,{children:"One of T-Ruby's most powerful features is type inference. The type system can automatically determine the types of variables and expressions without requiring explicit annotations everywhere. This chapter will teach you how type inference works and when to rely on it."}),"\n",(0,r.jsx)(n.h2,{id:"what-is-type-inference",children:"What Is Type Inference?"}),"\n",(0,r.jsx)(n.p,{children:"Type inference is the ability of T-Ruby's type checker to automatically deduce the type of a variable or expression based on the value assigned to it or the context in which it's used. This means you don't always need to write type annotations."}),"\n",(0,r.jsx)(n.h3,{id:"basic-inference-example",children:"Basic Inference Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="basic_inference.trb"',children:'# T-Ruby infers that name is a String\nname = "Alice"\n\n# T-Ruby infers that count is an Integer\ncount = 42\n\n# T-Ruby infers that price is a Float\nprice = 19.99\n\n# T-Ruby infers that active is a Bool\nactive = true\n'})}),"\n",(0,r.jsx)(n.p,{children:"The transpiled Ruby is identical:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="basic_inference.rb"',children:'name = "Alice"\ncount = 42\nprice = 19.99\nactive = true\n'})}),"\n",(0,r.jsx)(n.h2,{id:"how-type-inference-works",children:"How Type Inference Works"}),"\n",(0,r.jsx)(n.p,{children:"T-Ruby examines the value being assigned and determines its type from the literal:"}),"\n",(0,r.jsx)(n.h3,{id:"literal-based-inference",children:"Literal-Based Inference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="literals.trb"',children:'# String literal \u2192 String type\ngreeting = "Hello"\n\n# Integer literal \u2192 Integer type\nage = 25\n\n# Float literal \u2192 Float type\ntemperature = 98.6\n\n# Boolean literal \u2192 Bool type\nis_valid = false\n\n# Symbol literal \u2192 Symbol type\nstatus = :active\n\n# nil literal \u2192 nil type\nnothing = nil\n'})}),"\n",(0,r.jsx)(n.h3,{id:"expression-based-inference",children:"Expression-Based Inference"}),"\n",(0,r.jsx)(n.p,{children:"T-Ruby can infer types from expressions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="expressions.trb"',children:'x = 10\ny = 20\n\n# Inferred as Integer (result of Integer + Integer)\nsum = x + y\n\n# Inferred as String (result of String + String)\nfirst_name = "Alice"\nlast_name = "Smith"\nfull_name = first_name + " " + last_name\n\n# Inferred as Float (result of Integer.to_f)\ndecimal = x.to_f\n'})}),"\n",(0,r.jsx)(n.h3,{id:"method-return-type-inference",children:"Method Return Type Inference"}),"\n",(0,r.jsx)(n.p,{children:"When a method has a return type annotation, T-Ruby knows the type of the result:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="method_returns.trb"',children:'def get_name(): String\n  "Alice"\nend\n\n# T-Ruby infers that name is a String\nname = get_name()\n\ndef calculate_total(items: Integer, price: Float): Float\n  items * price\nend\n\n# T-Ruby infers that total is a Float\ntotal = calculate_total(3, 9.99)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"when-inference-works-best",children:"When Inference Works Best"}),"\n",(0,r.jsx)(n.p,{children:"Type inference works best for local variables with clear initialization:"}),"\n",(0,r.jsx)(n.h3,{id:"local-variables",children:"Local Variables"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="local_vars.trb"',children:"def process_order(quantity: Integer, unit_price: Float)\n  # These types are all inferred\n  subtotal = quantity * unit_price\n  tax_rate = 0.08\n  tax = subtotal * tax_rate\n  total = subtotal + tax\n\n  {\n    subtotal: subtotal,\n    tax: tax,\n    total: total\n  }\nend\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, T-Ruby infers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"subtotal"})," is ",(0,r.jsx)(n.code,{children:"Float"})," (Integer * Float = Float)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tax_rate"})," is ",(0,r.jsx)(n.code,{children:"Float"})," (0.08 is a float literal)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tax"})," is ",(0,r.jsx)(n.code,{children:"Float"})," (Float * Float = Float)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"total"})," is ",(0,r.jsx)(n.code,{children:"Float"})," (Float + Float = Float)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"array-and-hash-inference",children:"Array and Hash Inference"}),"\n",(0,r.jsx)(n.p,{children:"T-Ruby can infer the types of array and hash elements:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="collections.trb"',children:'# Inferred as Array<Integer>\nnumbers = [1, 2, 3, 4, 5]\n\n# Inferred as Array<String>\nnames = ["Alice", "Bob", "Charlie"]\n\n# Inferred as Hash<Symbol, String>\nuser = {\n  name: "Alice",\n  email: "alice@example.com"\n}\n\n# Inferred as Hash<String, Integer>\nscores = {\n  "math" => 95,\n  "science" => 88\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"block-parameter-inference",children:"Block Parameter Inference"}),"\n",(0,r.jsx)(n.p,{children:"T-Ruby can infer block parameter types when iterating over typed collections:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="blocks.trb"',children:'def sum_numbers(numbers: Array<Integer>): Integer\n  total = 0\n\n  # T-Ruby infers that n is an Integer\n  numbers.each do |n|\n    total += n\n  end\n\n  total\nend\n\ndef greet_all(names: Array<String>)\n  # T-Ruby infers that name is a String\n  names.each do |name|\n    puts "Hello, #{name}!"\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"when-to-add-explicit-annotations",children:"When to Add Explicit Annotations"}),"\n",(0,r.jsx)(n.p,{children:"While inference is powerful, there are times when you should add explicit type annotations:"}),"\n",(0,r.jsx)(n.h3,{id:"1-method-signatures-always",children:"1. Method Signatures (Always)"}),"\n",(0,r.jsx)(n.p,{children:"Always annotate method parameters and return types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="method_sigs.trb"',children:"# Good - explicit annotations\ndef calculate_discount(price: Float, percent: Integer): Float\n  price * (percent / 100.0)\nend\n\n# Avoid - no annotations (harder to understand and use)\ndef calculate_discount(price, percent)\n  price * (percent / 100.0)\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-instance-variables",children:"2. Instance Variables"}),"\n",(0,r.jsx)(n.p,{children:"Instance variables should be annotated when declared:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="instance_vars.trb"',children:"class ShoppingCart\n  def initialize()\n    @items: Array<String> = []\n    @total: Float = 0.0\n  end\n\n  def add_item(item: String, price: Float)\n    @items << item\n    @total += price\n  end\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-ambiguous-situations",children:"3. Ambiguous Situations"}),"\n",(0,r.jsx)(n.p,{children:"When the type isn't clear from the initial value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="ambiguous.trb"',children:"# Ambiguous - is this supposed to be Float or Integer?\nresult = 0  # Inferred as Integer\n\n# Better - explicit when you need a Float\nresult: Float = 0.0\n\n# Or when starting with a temporary value\nusers: Array<String> = []  # Will hold usernames later\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-union-types",children:"4. Union Types"}),"\n",(0,r.jsx)(n.p,{children:"When a variable might hold different types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="unions.trb"',children:'# Explicit annotation needed for union types\ndef find_user(id: Integer): String | nil\n  return nil if id < 0\n  "User #{id}"\nend\n\n# Explicit annotation needed when initially nil\ncurrent_user: String | nil = nil\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-public-apis",children:"5. Public APIs"}),"\n",(0,r.jsx)(n.p,{children:"When defining public methods, classes, or modules:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="public_api.trb"',children:'module MathHelpers\n  # Public method - fully annotated\n  def self.calculate_average(numbers: Array<Float>): Float\n    sum = numbers.reduce(0.0) { |acc, n| acc + n }\n    sum / numbers.length\n  end\n\n  # Public method - fully annotated\n  def self.round_currency(amount: Float): String\n    "$%.2f" % amount\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"inference-with-control-flow",children:"Inference with Control Flow"}),"\n",(0,r.jsx)(n.p,{children:"T-Ruby's inference works through control flow structures:"}),"\n",(0,r.jsx)(n.h3,{id:"if-statements",children:"If Statements"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="if_statements.trb"',children:'def categorize_age(age: Integer): String\n  # category is inferred as String in all branches\n  if age < 13\n    category = "child"\n  elsif age < 20\n    category = "teenager"\n  else\n    category = "adult"\n  end\n\n  category\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"case-statements",children:"Case Statements"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="case_statements.trb"',children:'def get_day_type(day: Symbol): String\n  # day_type is inferred as String\n  day_type = case day\n  when :monday, :tuesday, :wednesday, :thursday, :friday\n    "weekday"\n  when :saturday, :sunday\n    "weekend"\n  else\n    "unknown"\n  end\n\n  day_type\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-inference-patterns",children:"Common Inference Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"pattern-1-initialize-then-use",children:"Pattern 1: Initialize Then Use"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="pattern1.trb"',children:'def process_names(raw_names: String): Array<String>\n  # names is inferred as Array<String>\n  names = raw_names.split(",")\n\n  # cleaned is inferred as Array<String>\n  cleaned = names.map { |n| n.strip.downcase }\n\n  cleaned\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-2-accumulator-variables",children:"Pattern 2: Accumulator Variables"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="pattern2.trb"',children:"def calculate_stats(numbers: Array<Integer>): Hash<Symbol, Float>\n  # sum is inferred as Integer (starts at 0, adds Integers)\n  sum = 0\n  numbers.each { |n| sum += n }\n\n  # avg is inferred as Float (Integer.to_f)\n  avg = sum.to_f / numbers.length\n\n  { sum: sum.to_f, average: avg }\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-3-builder-pattern",children:"Pattern 3: Builder Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="pattern3.trb"',children:'def build_query(table: String, conditions: Array<String>): String\n  # query is inferred as String\n  query = "SELECT * FROM #{table}"\n\n  if conditions.length > 0\n    # where_clause is inferred as String\n    where_clause = conditions.join(" AND ")\n    query += " WHERE #{where_clause}"\n  end\n\n  query\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"limitations-of-type-inference",children:"Limitations of Type Inference"}),"\n",(0,r.jsx)(n.p,{children:"There are situations where T-Ruby cannot infer types automatically:"}),"\n",(0,r.jsx)(n.h3,{id:"empty-collections",children:"Empty Collections"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="empty_collections.trb"',children:'# T-Ruby cannot infer element type from empty array\nitems = []  # Needs annotation!\n\n# Better - annotate the type\nitems: Array<String> = []\n\n# Or initialize with at least one element\nitems = ["first_item"]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"complex-union-types",children:"Complex Union Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="complex_unions.trb"',children:"# T-Ruby cannot infer that this should accept multiple types\ndef process_value(value)  # Needs annotation!\n  if value.is_a?(String)\n    value.upcase\n  elsif value.is_a?(Integer)\n    value * 2\n  end\nend\n\n# Better - explicit union type\ndef process_value(value: String | Integer): String | Integer\n  if value.is_a?(String)\n    value.upcase\n  else\n    value * 2\n  end\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"recursive-functions",children:"Recursive Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="recursive.trb"',children:"# Needs return type annotation for recursion\ndef factorial(n: Integer): Integer\n  return 1 if n <= 1\n  n * factorial(n - 1)\nend\n\ndef fibonacci(n: Integer): Integer\n  return n if n <= 1\n  fibonacci(n - 1) + fibonacci(n - 2)\nend\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-for-type-inference",children:"Best Practices for Type Inference"}),"\n",(0,r.jsx)(n.h3,{id:"1-let-inference-handle-local-variables",children:"1. Let Inference Handle Local Variables"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="locals.trb"',children:"def calculate_discount(price: Float, rate: Float): Float\n  # Let inference work - types are obvious\n  discount = price * rate\n  final_price = price - discount\n\n  final_price\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-annotate-when-sharing-across-scopes",children:"2. Annotate When Sharing Across Scopes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="shared_scope.trb"',children:"class OrderProcessor\n  def initialize()\n    # Annotate - shared across methods\n    @pending_orders: Array<String> = []\n    @completed_count: Integer = 0\n  end\n\n  def add_order(order: String)\n    @pending_orders << order\n  end\n\n  def complete_order()\n    @pending_orders.shift\n    @completed_count += 1\n  end\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-prefer-inference-for-intermediate-calculations",children:"3. Prefer Inference for Intermediate Calculations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="intermediate.trb"',children:"def calculate_compound_interest(\n  principal: Float,\n  rate: Float,\n  years: Integer\n): Float\n  # All intermediate values are inferred\n  rate_decimal = rate / 100.0\n  multiplier = 1.0 + rate_decimal\n  final_multiplier = multiplier ** years\n  final_amount = principal * final_multiplier\n\n  final_amount\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-annotate-for-clarity-in-complex-logic",children:"4. Annotate for Clarity in Complex Logic"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="clarity.trb"',children:'def parse_config(raw: String): Hash<Symbol, String | Integer>\n  # Annotate the result type for clarity\n  config: Hash<Symbol, String | Integer> = {}\n\n  raw.split("\\n").each do |line|\n    key, value = line.split("=")\n    config[key.to_sym] = parse_value(value)\n  end\n\n  config\nend\n\ndef parse_value(value: String): String | Integer\n  integer_value = value.to_i\n  if integer_value.to_s == value\n    integer_value\n  else\n    value\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"practical-example-invoice-calculator",children:"Practical Example: Invoice Calculator"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example showing effective use of type inference:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="invoice.trb"',children:'class Invoice\n  def initialize(customer: String)\n    @customer: String = customer\n    @items: Array<Hash<Symbol, String | Float>> = []\n    @tax_rate: Float = 0.08\n  end\n\n  def add_item(name: String, price: Float, quantity: Integer)\n    # item type is inferred from hash literal\n    item = {\n      name: name,\n      price: price,\n      quantity: quantity,\n      total: price * quantity\n    }\n\n    @items << item\n  end\n\n  def calculate_total(): Float\n    # subtotal is inferred as Float\n    subtotal = 0.0\n\n    @items.each do |item|\n      # T-Ruby infers item properties from array type\n      subtotal += item[:total]\n    end\n\n    # tax and total are inferred as Float\n    tax = subtotal * @tax_rate\n    total = subtotal + tax\n\n    total\n  end\n\n  def generate_summary(): String\n    # Inferred types throughout\n    total = calculate_total()\n    item_count = @items.length\n\n    "Invoice for #{@customer}: #{item_count} items, Total: $#{\'%.2f\' % total}"\n  end\nend\n\n# Usage\ninvoice = Invoice.new("Alice")\ninvoice.add_item("Widget", 9.99, 2)\ninvoice.add_item("Gadget", 14.99, 1)\n\nsummary: String = invoice.generate_summary()\n# Returns: "Invoice for Alice: 2 items, Total: $37.57"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Type inference in T-Ruby allows you to write clean, concise code while maintaining type safety:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inference works"})," for local variables, literals, and expressions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always annotate"})," method signatures, instance variables, and public APIs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add annotations"})," when types are ambiguous or complex"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trust inference"})," for intermediate calculations and local variables"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use explicit types"})," for empty collections and union types"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The goal is to strike a balance: let inference reduce clutter while adding annotations where they improve clarity and safety."}),"\n",(0,r.jsx)(n.p,{children:"In the next section, you'll learn about everyday types like arrays, hashes, and union types that you'll use regularly in T-Ruby."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8885:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var a=t(9378);const r={},i=a.createContext(r);function l(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);