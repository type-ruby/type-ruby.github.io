"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[7888],{8810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"learn/advanced/conditional-types","title":"Conditional Types","description":"Types that depend on conditions","source":"@site/docs/learn/advanced/conditional-types.md","sourceDirName":"learn/advanced","slug":"/learn/advanced/conditional-types","permalink":"/ko/docs/learn/advanced/conditional-types","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/advanced/conditional-types.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Conditional Types","description":"Types that depend on conditions"},"sidebar":"docsSidebar","previous":{"title":"Intersection Types","permalink":"/ko/docs/learn/advanced/intersection-types"},"next":{"title":"Mapped Types","permalink":"/ko/docs/learn/advanced/mapped-types"}}');var i=t(2714),s=t(8885);const a={sidebar_position:3,title:"Conditional Types",description:"Types that depend on conditions"},l="Conditional Types",d={},o=[{value:"Understanding Conditional Types",id:"understanding-conditional-types",level:2},{value:"Basic Syntax",id:"basic-syntax",level:3},{value:"Extends Keyword",id:"extends-keyword",level:2},{value:"Checking for Specific Types",id:"checking-for-specific-types",level:3},{value:"Conditional Type Patterns",id:"conditional-type-patterns",level:2},{value:"Extract Non-Nil Types",id:"extract-non-nil-types",level:3},{value:"Extract Function Return Types",id:"extract-function-return-types",level:3},{value:"Extract Array Element Types",id:"extract-array-element-types",level:3},{value:"The <code>infer</code> Keyword",id:"the-infer-keyword",level:2},{value:"Multiple Infer Usage",id:"multiple-infer-usage",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Unwrap Types",id:"unwrap-types",level:3},{value:"Flatten Union Types",id:"flatten-union-types",level:3},{value:"Promise-like Types",id:"promise-like-types",level:3},{value:"Distributive Conditional Types",id:"distributive-conditional-types",level:2},{value:"Preventing Distribution",id:"preventing-distribution",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Type Narrowing",id:"type-narrowing",level:3},{value:"Recursive Conditional Types",id:"recursive-conditional-types",level:3},{value:"Type Guard Functions",id:"type-guard-functions",level:3},{value:"Conditional Types with Generics",id:"conditional-types-with-generics",level:2},{value:"Practical Use Cases",id:"practical-use-cases",level:2},{value:"API Response Types",id:"api-response-types",level:3},{value:"Smart Defaults",id:"smart-defaults",level:3},{value:"Collection Element Access",id:"collection-element-access",level:3},{value:"Function Composition",id:"function-composition",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Conditions Simple",id:"1-keep-conditions-simple",level:3},{value:"2. Use Descriptive Names",id:"2-use-descriptive-names",level:3},{value:"3. Document Complex Types",id:"3-document-complex-types",level:3},{value:"4. Avoid Deep Nesting",id:"4-avoid-deep-nesting",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Recursion Depth",id:"recursion-depth",level:3},{value:"Type Inference Complexity",id:"type-inference-complexity",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"conditional-types",children:"Conditional Types"})}),"\n",(0,i.jsx)(n.admonition,{title:"Coming Soon",type:"caution",children:(0,i.jsx)(n.p,{children:"This feature is planned for a future release."})}),"\n",(0,i.jsx)(n.p,{children:'Conditional types allow you to create types that change based on conditions. Think of them as "if-else" statements at the type level\u2014the resulting type depends on whether a condition is true or false.'}),"\n",(0,i.jsx)(n.h2,{id:"understanding-conditional-types",children:"Understanding Conditional Types"}),"\n",(0,i.jsx)(n.p,{children:"Conditional types use a ternary-like syntax to select between two types based on a type relationship:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"type Result = Condition ? TrueType : FalseType\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"Condition"})," is true, the result is ",(0,i.jsx)(n.code,{children:"TrueType"}),". Otherwise, it's ",(0,i.jsx)(n.code,{children:"FalseType"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"basic-syntax",children:"Basic Syntax"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Conditional type syntax\ntype TypeName<T> = T extends SomeType ? TypeIfTrue : TypeIfFalse\n\n# Example: Check if T is a string\ntype IsString<T> = T extends String ? true : false\n\n# Usage\ntype Test1 = IsString<String>   # true\ntype Test2 = IsString<Integer>  # false\n"})}),"\n",(0,i.jsx)(n.h2,{id:"extends-keyword",children:"Extends Keyword"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"extends"})," keyword in conditional types checks if a type is assignable to another type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# T extends U means "Can T be assigned to U?"\n\ntype IsArray<T> = T extends Array<any> ? true : false\n\ntype Test1 = IsArray<Array<Integer>>  # true\ntype Test2 = IsArray<String>          # false\ntype Test3 = IsArray<Hash<String, Integer>>  # false\n'})}),"\n",(0,i.jsx)(n.h3,{id:"checking-for-specific-types",children:"Checking for Specific Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Check if type is a number\ntype IsNumeric<T> = T extends Integer | Float ? true : false\n\n# Check if type is nil\ntype IsNil<T> = T extends nil ? true : false\n\n# Check if type is a function\ntype IsFunction<T> = T extends Proc<any, any> ? true : false\n\n# Usage examples\ntype NumTest = IsNumeric<Integer>  # true\ntype NilTest = IsNil<nil>          # true\ntype FnTest = IsFunction<Proc<String, Integer>>  # true\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conditional-type-patterns",children:"Conditional Type Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"extract-non-nil-types",children:"Extract Non-Nil Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Remove nil from a union type\ntype NonNil<T> = T extends nil ? never : T\n\n# Usage\ntype MaybeString = String | nil\ntype JustString = NonNil<MaybeString>  # String\n\ntype MixedTypes = String | Integer | nil | Float\ntype WithoutNil = NonNil<MixedTypes>  # String | Integer | Float\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extract-function-return-types",children:"Extract Function Return Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Get the return type of a function\ntype ReturnType<T> = T extends Proc<any, infer R> ? R : never\n\n# Usage\ntype AddFunction = Proc<Integer, Integer, Integer>\ntype AddReturnType = ReturnType<AddFunction>  # Integer\n\ntype GetUserFunction = Proc<Integer, User>\ntype UserReturnType = ReturnType<GetUserFunction>  # User\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extract-array-element-types",children:"Extract Array Element Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Get the element type of an array\ntype ElementType<T> = T extends Array<infer E> ? E : never\n\n# Usage\ntype StringArray = Array<String>\ntype StringElement = ElementType<StringArray>  # String\n\ntype NumberArray = Array<Integer>\ntype NumberElement = ElementType<NumberArray>  # Integer\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"the-infer-keyword",children:["The ",(0,i.jsx)(n.code,{children:"infer"})," Keyword"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"infer"})," keyword allows you to capture and name a type within a conditional type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Infer the parameter type of a function\ntype ParamType<T> = T extends Proc<infer P, any> ? P : never\n\n# Infer the key type of a hash\ntype KeyType<T> = T extends Hash<infer K, any> ? K : never\n\n# Infer the value type of a hash\ntype ValueError<T> = T extends Hash<any, infer V> ? V : never\n\n# Usage\ntype MyFunction = Proc<String, Integer>\ntype Param = ParamType<MyFunction>  # String\n\ntype MyHash = Hash<Symbol, User>\ntype Key = KeyType<MyHash>    # Symbol\ntype Value = ValueError<MyHash>  # User\n"})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-infer-usage",children:"Multiple Infer Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Extract both parts of a pair\ntype Unpair<T> = T extends Hash<Symbol, { first: infer F, second: infer S }>\n  ? [F, S]\n  : never\n\n# Extract function signature parts\ntype FunctionParts<T> =\n  T extends Proc<infer P, infer R>\n    ? { params: P, return: R }\n    : never\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(n.h3,{id:"unwrap-types",children:"Unwrap Types"}),"\n",(0,i.jsx)(n.p,{children:"Remove wrapper types to get the inner type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Unwrap Array\ntype Unwrap<T> = T extends Array<infer U> ? U : T\n\n# Usage\ntype Wrapped1 = Unwrap<Array<String>>  # String\ntype Wrapped2 = Unwrap<String>         # String (no change)\n\n# Unwrap nested arrays\ntype DeepUnwrap<T> =\n  T extends Array<infer U>\n    ? DeepUnwrap<U>\n    : T\n\ntype NestedArray = Array<Array<Array<Integer>>>\ntype Unwrapped = DeepUnwrap<NestedArray>  # Integer\n"})}),"\n",(0,i.jsx)(n.h3,{id:"flatten-union-types",children:"Flatten Union Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Flatten nested unions\ntype Flatten<T> =\n  T extends Array<infer U>\n    ? Flatten<U>\n    : T extends Hash<any, infer V>\n      ? Flatten<V>\n      : T\n\n# Remove duplicates from union (if possible)\ntype Unique<T, U = T> =\n  T extends U\n    ? [U] extends [T]\n      ? T\n      : Unique<T, Exclude<U, T>>\n    : never\n"})}),"\n",(0,i.jsx)(n.h3,{id:"promise-like-types",children:"Promise-like Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Unwrap promise-like types\ntype Awaited<T> =\n  T extends Promise<infer U>\n    ? Awaited<U>\n    : T\n\n# Simulate async return type\ntype AsyncReturnType<T> =\n  T extends Proc<any, infer R>\n    ? Awaited<R>\n    : never\n"})}),"\n",(0,i.jsx)(n.h2,{id:"distributive-conditional-types",children:"Distributive Conditional Types"}),"\n",(0,i.jsx)(n.p,{children:"When a conditional type acts on a union type, it distributes over the union:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# This conditional type is distributive\ntype ToArray<T> = T extends any ? Array<T> : never\n\n# When applied to a union, it distributes:\ntype StringOrNumber = String | Integer\ntype Result = ToArray<StringOrNumber>\n# Result: Array<String> | Array<Integer>\n# Not: Array<String | Integer>\n\n# Another example\ntype BoxedType<T> = T extends any ? { value: T } : never\n\ntype Mixed = String | Integer | Bool\ntype Boxed = BoxedType<Mixed>\n# Result: { value: String } | { value: Integer } | { value: Bool }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"preventing-distribution",children:"Preventing Distribution"}),"\n",(0,i.jsx)(n.p,{children:"To prevent distribution, wrap types in a tuple:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Non-distributive version\ntype ToArrayNonDist<T> = [T] extends [any] ? Array<T> : never\n\ntype StringOrNumber = String | Integer\ntype Result = ToArrayNonDist<StringOrNumber>\n# Result: Array<String | Integer>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"type-narrowing",children:"Type Narrowing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Narrow types based on properties\ntype NarrowByProperty<T, K extends keyof T, V> =\n  T extends { K: V } ? T : never\n\n# Filter types from union based on property\ntype FilterByProperty<T, K, V> =\n  T extends infer U\n    ? U extends { K: V }\n      ? U\n      : never\n    : never\n"})}),"\n",(0,i.jsx)(n.h3,{id:"recursive-conditional-types",children:"Recursive Conditional Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Deep readonly type\ntype DeepReadonly<T> =\n  T extends (Array<infer U> | Hash<any, infer U>)\n    ? ReadonlyArray<DeepReadonly<U>>\n    : T extends Hash<infer K, infer V>\n      ? ReadonlyHash<K, DeepReadonly<V>>\n      : T\n\n# Deep partial type\ntype DeepPartial<T> =\n  T extends Hash<infer K, infer V>\n    ? Hash<K, DeepPartial<V> | nil>\n    : T extends Array<infer U>\n      ? Array<DeepPartial<U>>\n      : T\n"})}),"\n",(0,i.jsx)(n.h3,{id:"type-guard-functions",children:"Type Guard Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Create type predicates\ndef is_string<T>(value: T): value is String\n  value.is_a?(String)\nend\n\ndef is_array<T>(value: T): value is Array<any>\n  value.is_a?(Array)\nend\n\n# Use with conditional types\ntype TypeGuardReturn<T, G> =\n  G extends true ? T : never\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conditional-types-with-generics",children:"Conditional Types with Generics"}),"\n",(0,i.jsx)(n.p,{children:"Combine conditional types with generic constraints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Only allow certain types\ntype Addable<T> =\n  T extends Integer | Float | String\n    ? T\n    : never\n\ndef add<T extends Addable<T>>(a: T, b: T): T\n  a + b\nend\n\n# Transform types conditionally\ntype Transform<T> =\n  T extends String ? Integer :\n  T extends Integer ? Float :\n  T extends Float ? String :\n  T\n\n# Usage\ndef transform<T>(value: T): Transform<T>\n  case value\n  when String\n    value.length  # Returns Integer\n  when Integer\n    value.to_f    # Returns Float\n  when Float\n    value.to_s    # Returns String\n  else\n    value\n  end\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-use-cases",children:"Practical Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"api-response-types",children:"API Response Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Conditionally add error field based on success status\ntype APIResponse<T, Success extends Bool> =\n  Success extends true\n    ? { success: true, data: T }\n    : { success: false, error: String }\n\n# Usage\ntype SuccessResponse = APIResponse<User, true>\n# { success: true, data: User }\n\ntype ErrorResponse = APIResponse<User, false>\n# { success: false, error: String }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"smart-defaults",children:"Smart Defaults"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Provide default types conditionally\ntype WithDefault<T, D> = T extends nil ? D : T\n\n# Usage\ntype MaybeString = String | nil\ntype StringWithDefault = WithDefault<MaybeString, String>  # String\n\ntype DefiniteValue = Integer\ntype IntegerWithDefault = WithDefault<DefiniteValue, Float>  # Integer\n"})}),"\n",(0,i.jsx)(n.h3,{id:"collection-element-access",children:"Collection Element Access"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Get type based on collection type\ntype CollectionElement<T> =\n  T extends Array<infer E> ? E :\n  T extends Hash<any, infer V> ? V :\n  T extends Set<infer S> ? S :\n  never\n\n# Usage\ntype ArrayElement = CollectionElement<Array<String>>  # String\ntype HashValue = CollectionElement<Hash<Symbol, Integer>>  # Integer\ntype SetElement = CollectionElement<Set<User>>  # User\n"})}),"\n",(0,i.jsx)(n.h3,{id:"function-composition",children:"Function Composition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Compose function types\ntype Compose<F, G> =\n  F extends Proc<infer A, infer B>\n    ? G extends Proc<B, infer C>\n      ? Proc<A, C>\n      : never\n    : never\n\n# Usage\ntype F = Proc<String, Integer>  # String -> Integer\ntype G = Proc<Integer, Bool>    # Integer -> Bool\ntype Composed = Compose<F, G>   # String -> Bool\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-keep-conditions-simple",children:"1. Keep Conditions Simple"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Good: Simple, clear condition\ntype IsString<T> = T extends String ? true : false\n\n# Less good: Complex nested conditions\ntype ComplexCheck<T> =\n  T extends String\n    ? T extends "hello"\n      ? true\n      : T extends "world"\n        ? true\n        : false\n    : false\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-use-descriptive-names",children:"2. Use Descriptive Names"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Good: Clear names\ntype NonNilable<T> = T extends nil ? never : T\ntype Unwrap<T> = T extends Array<infer U> ? U : T\n\n# Less good: Cryptic names\ntype NN<T> = T extends nil ? never : T\ntype UW<T> = T extends Array<infer U> ? U : T\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-document-complex-types",children:"3. Document Complex Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Good: Documented conditional type\n# Extracts the return type of a function type\n# @example ReturnType<Proc<String, Integer>> => Integer\ntype ReturnType<T> = T extends Proc<any, infer R> ? R : never\n\n# Recursively makes all properties optional\n# @example DeepPartial<User> => All User properties become T | nil\ntype DeepPartial<T> =\n  T extends Hash<infer K, infer V>\n    ? Hash<K, DeepPartial<V> | nil>\n    : T\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-avoid-deep-nesting",children:"4. Avoid Deep Nesting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Good: Flat, manageable structure\ntype FirstType<T> = T extends [infer F, ...any] ? F : never\ntype RestTypes<T> = T extends [any, ...infer R] ? R : never\n\n# Less good: Deeply nested\ntype Extract<T> =\n  T extends [infer F, ...infer R]\n    ? F extends String\n      ? R extends Array<infer U>\n        ? U extends Integer\n          ? [F, U]\n          : never\n        : never\n      : never\n    : never\n"})}),"\n",(0,i.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsx)(n.h3,{id:"recursion-depth",children:"Recursion Depth"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Very deep recursion may hit limits\ntype DeepNested<T, N> =\n  N extends 0\n    ? T\n    : Array<DeepNested<T, Decrement<N>>>  # May hit depth limit\n"})}),"\n",(0,i.jsx)(n.h3,{id:"type-inference-complexity",children:"Type Inference Complexity"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Complex inference may not always work as expected\ntype ComplexInfer<T> =\n  T extends {\n    a: infer A,\n    b: infer B,\n    c: (x: infer C) => infer D\n  } ? [A, B, C, D] : never\n"})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you understand conditional types, explore:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/learn/advanced/mapped-types",children:"Mapped Types"})," to transform properties of types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/learn/advanced/utility-types",children:"Utility Types"})," which use conditional types internally"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/learn/basics/type-inference",children:"Type Inference"})," to understand how T-Ruby infers types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/learn/generics/constraints",children:"Generics with Constraints"})," for controlled type parameters"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8885:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(9378);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);