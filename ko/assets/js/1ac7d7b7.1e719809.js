"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[5617],{6239:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"learn/everyday-types/type-narrowing","title":"Type Narrowing","description":"Narrowing types with control flow analysis","source":"@site/docs/learn/everyday-types/type-narrowing.md","sourceDirName":"learn/everyday-types","slug":"/learn/everyday-types/type-narrowing","permalink":"/ko/docs/learn/everyday-types/type-narrowing","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/everyday-types/type-narrowing.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Type Narrowing","description":"Narrowing types with control flow analysis"},"sidebar":"docsSidebar","previous":{"title":"Union Types","permalink":"/ko/docs/learn/everyday-types/union-types"},"next":{"title":"Literal Types","permalink":"/ko/docs/learn/everyday-types/literal-types"}}');var t=r(2714),a=r(8885);const l={sidebar_position:4,title:"Type Narrowing",description:"Narrowing types with control flow analysis"},s="Type Narrowing",o={},d=[{value:"What Is Type Narrowing?",id:"what-is-type-narrowing",level:2},{value:"Type Guards",id:"type-guards",level:2},{value:"The <code>is_a?</code> Type Guard",id:"the-is_a-type-guard",level:3},{value:"The <code>nil?</code> Type Guard",id:"the-nil-type-guard",level:3},{value:"The <code>empty?</code> Type Guard",id:"the-empty-type-guard",level:3},{value:"Narrowing with Equality Checks",id:"narrowing-with-equality-checks",level:2},{value:"Comparing to nil",id:"comparing-to-nil",level:3},{value:"Comparing to Specific Values",id:"comparing-to-specific-values",level:3},{value:"Narrowing in Different Control Flow Structures",id:"narrowing-in-different-control-flow-structures",level:2},{value:"If/Elsif/Else Statements",id:"ifelsifelse-statements",level:3},{value:"Unless Statements",id:"unless-statements",level:3},{value:"Case/When Statements",id:"casewhen-statements",level:3},{value:"Ternary Operator",id:"ternary-operator",level:3},{value:"Narrowing with Logical Operators",id:"narrowing-with-logical-operators",level:2},{value:"AND Operator (<code>&amp;&amp;</code>)",id:"and-operator-",level:3},{value:"OR Operator (<code>||</code>)",id:"or-operator-",level:3},{value:"Early Returns and Type Narrowing",id:"early-returns-and-type-narrowing",level:2},{value:"Narrowing with Method Calls",id:"narrowing-with-method-calls",level:2},{value:"String Methods",id:"string-methods",level:3},{value:"Array Methods",id:"array-methods",level:3},{value:"Narrowing in Blocks and Lambdas",id:"narrowing-in-blocks-and-lambdas",level:2},{value:"Practical Example: Form Validator",id:"practical-example-form-validator",level:2},{value:"Narrowing Limitations",id:"narrowing-limitations",level:2},{value:"Narrowing Doesn&#39;t Persist Across Function Calls",id:"narrowing-doesnt-persist-across-function-calls",level:3},{value:"Narrowing Doesn&#39;t Work After Mutation",id:"narrowing-doesnt-work-after-mutation",level:3},{value:"Complex Conditions May Not Narrow",id:"complex-conditions-may-not-narrow",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Guard Clauses",id:"1-use-guard-clauses",level:3},{value:"2. Check nil First",id:"2-check-nil-first",level:3},{value:"3. Use Specific Type Checks",id:"3-use-specific-type-checks",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"type-narrowing",children:"Type Narrowing"})}),"\n",(0,t.jsx)(n.p,{children:"Type narrowing is the process by which T-Ruby automatically refines the type of a variable based on control flow analysis. When you check the type or value of a variable, T-Ruby narrows down what that variable can be within that code path. This chapter will teach you how type narrowing works and how to leverage it for type-safe code."}),"\n",(0,t.jsx)(n.h2,{id:"what-is-type-narrowing",children:"What Is Type Narrowing?"}),"\n",(0,t.jsx)(n.p,{children:"Type narrowing occurs when T-Ruby analyzes your code and determines that within a certain scope, a variable must be a more specific type than its declared type."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="narrowing_basics.trb"',children:"def process(value: String | Integer): String\n  if value.is_a?(String)\n    # Inside this block, T-Ruby knows value is a String\n    # You can use String-specific methods\n    value.upcase\n  else\n    # Here, T-Ruby knows value must be an Integer\n    # You can use Integer-specific methods\n    value.to_s\n  end\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the type ",(0,t.jsx)(n.code,{children:"String | Integer"})," is narrowed to just ",(0,t.jsx)(n.code,{children:"String"})," in the first branch and just ",(0,t.jsx)(n.code,{children:"Integer"})," in the else branch."]}),"\n",(0,t.jsx)(n.h2,{id:"type-guards",children:"Type Guards"}),"\n",(0,t.jsx)(n.p,{children:"Type guards are expressions that allow T-Ruby to narrow types. The most common type guards are:"}),"\n",(0,t.jsxs)(n.h3,{id:"the-is_a-type-guard",children:["The ",(0,t.jsx)(n.code,{children:"is_a?"})," Type Guard"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"is_a?"})," method checks if a value is an instance of a particular type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="is_a_guard.trb"',children:'def format_value(value: String | Integer | Bool): String\n  if value.is_a?(String)\n    # value is String here\n    "Text: #{value}"\n  elsif value.is_a?(Integer)\n    # value is Integer here\n    "Number: #{value}"\n  elsif value.is_a?(Bool)\n    # value is Bool here\n    "Boolean: #{value}"\n  else\n    "Unknown"\n  end\nend\n\nresult1: String = format_value("hello")  # "Text: hello"\nresult2: String = format_value(42)  # "Number: 42"\nresult3: String = format_value(true)  # "Boolean: true"\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"the-nil-type-guard",children:["The ",(0,t.jsx)(n.code,{children:"nil?"})," Type Guard"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"nil?"})," method narrows optional types:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="nil_guard.trb"',children:'def get_length(text: String | nil): Integer\n  if text.nil?\n    # text is nil here\n    0\n  else\n    # text is String here (not nil)\n    text.length\n  end\nend\n\n# Alternative with negation\ndef get_length_alt(text: String | nil): Integer\n  if !text.nil?\n    # text is String here\n    text.length\n  else\n    # text is nil here\n    0\n  end\nend\n\nlen1: Integer = get_length("hello")  # 5\nlen2: Integer = get_length(nil)  # 0\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"the-empty-type-guard",children:["The ",(0,t.jsx)(n.code,{children:"empty?"})," Type Guard"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"empty?"})," method can narrow types for collections:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="empty_guard.trb"',children:'def process_array(items: Array<String> | nil): String\n  if items.nil? || items.empty?\n    "No items"\n  else\n    # items is a non-empty Array<String> here\n    "First item: #{items.first}"\n  end\nend\n\nresult1: String = process_array(["a", "b"])  # "First item: a"\nresult2: String = process_array([])  # "No items"\nresult3: String = process_array(nil)  # "No items"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"narrowing-with-equality-checks",children:"Narrowing with Equality Checks"}),"\n",(0,t.jsx)(n.p,{children:"Comparing a value to a specific constant narrows its type:"}),"\n",(0,t.jsx)(n.h3,{id:"comparing-to-nil",children:"Comparing to nil"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="nil_comparison.trb"',children:'def greet(name: String | nil): String\n  if name == nil\n    # name is nil here\n    "Hello, stranger!"\n  else\n    # name is String here\n    "Hello, #{name}!"\n  end\nend\n\n# Alternative syntax\ndef greet_alt(name: String | nil): String\n  if name != nil\n    # name is String here\n    "Hello, #{name}!"\n  else\n    # name is nil here\n    "Hello, stranger!"\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"comparing-to-specific-values",children:"Comparing to Specific Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="value_comparison.trb"',children:'def process_status(status: String): String\n  if status == "active"\n    # status is still String, but we know its value\n    "The status is active"\n  elsif status == "pending"\n    "The status is pending"\n  else\n    "Unknown status: #{status}"\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"narrowing-in-different-control-flow-structures",children:"Narrowing in Different Control Flow Structures"}),"\n",(0,t.jsx)(n.h3,{id:"ifelsifelse-statements",children:"If/Elsif/Else Statements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="if_narrowing.trb"',children:'def categorize(value: String | Integer | nil): String\n  if value.nil?\n    # value is nil\n    "Empty"\n  elsif value.is_a?(String)\n    # value is String (not nil, not Integer)\n    "Text: #{value.length} chars"\n  else\n    # value is Integer (not nil, not String)\n    "Number: #{value}"\n  end\nend\n\ncat1: String = categorize(nil)  # "Empty"\ncat2: String = categorize("hello")  # "Text: 5 chars"\ncat3: String = categorize(42)  # "Number: 42"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"unless-statements",children:"Unless Statements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="unless_narrowing.trb"',children:'def process_unless(value: String | nil): String\n  unless value.nil?\n    # value is String here\n    value.upcase\n  else\n    # value is nil here\n    "NO VALUE"\n  end\nend\n\nresult1: String = process_unless("hello")  # "HELLO"\nresult2: String = process_unless(nil)  # "NO VALUE"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"casewhen-statements",children:"Case/When Statements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="case_narrowing.trb"',children:'def describe(value: String | Integer | Symbol): String\n  case value\n  when String\n    # value is String here\n    "String with length #{value.length}"\n  when Integer\n    # value is Integer here\n    "Number: #{value}"\n  when Symbol\n    # value is Symbol here\n    "Symbol: #{value}"\n  else\n    "Unknown"\n  end\nend\n\ndesc1: String = describe("hello")  # "String with length 5"\ndesc2: String = describe(42)  # "Number: 42"\ndesc3: String = describe(:active)  # "Symbol: active"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"ternary-operator",children:"Ternary Operator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="ternary_narrowing.trb"',children:'def get_display_name(name: String | nil): String\n  name.nil? ? "Anonymous" : name.upcase\nend\n\ndisplay1: String = get_display_name("alice")  # "ALICE"\ndisplay2: String = get_display_name(nil)  # "Anonymous"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"narrowing-with-logical-operators",children:"Narrowing with Logical Operators"}),"\n",(0,t.jsxs)(n.h3,{id:"and-operator-",children:["AND Operator (",(0,t.jsx)(n.code,{children:"&&"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="and_narrowing.trb"',children:'def process_and(\n  value: String | nil,\n  flag: Bool\n): String\n  if !value.nil? && flag\n    # value is String here (not nil)\n    # flag is true\n    value.upcase\n  else\n    "Skipped"\n  end\nend\n\ndef safe_access(items: Array<String> | nil, index: Integer): String | nil\n  if !items.nil? && index < items.length\n    # items is Array<String> here\n    items[index]\n  else\n    nil\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"or-operator-",children:["OR Operator (",(0,t.jsx)(n.code,{children:"||"}),")"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="or_narrowing.trb"',children:'def process_or(value: String | nil): String\n  if value.nil? || value.empty?\n    "No value"\n  else\n    # value is non-empty String here\n    value.upcase\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"early-returns-and-type-narrowing",children:"Early Returns and Type Narrowing"}),"\n",(0,t.jsx)(n.p,{children:"Early returns narrow types for the remainder of the function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="early_return.trb"',children:'def process_with_guard(value: String | nil): String\n  # Guard clause\n  return "No value" if value.nil?\n\n  # After this point, value is String (not nil)\n  # No need for else block\n  value.upcase\nend\n\ndef validate_and_process(input: String | Integer): String\n  # Multiple guards\n  return "Invalid" if input.nil?\n\n  if input.is_a?(String)\n    return "Too short" if input.length < 3\n    # input is String with length >= 3\n    return input.upcase\n  end\n\n  # input is Integer here\n  return "Too small" if input < 10\n  # input is Integer >= 10\n  "Valid number: #{input}"\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"narrowing-with-method-calls",children:"Narrowing with Method Calls"}),"\n",(0,t.jsx)(n.p,{children:"Some method calls provide type narrowing:"}),"\n",(0,t.jsx)(n.h3,{id:"string-methods",children:"String Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="string_method_narrowing.trb"',children:'def process_string(value: String | nil): String\n  return "Empty" if value.nil? || value.empty?\n\n  # value is non-empty String here\n  first_char = value[0]\n  "Starts with: #{first_char}"\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"array-methods",children:"Array Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="array_method_narrowing.trb"',children:'def get_first_element(items: Array<String> | nil): String\n  return "No items" if items.nil? || items.empty?\n\n  # items is non-empty Array<String> here\n  first: String = items.first\n  first\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"narrowing-in-blocks-and-lambdas",children:"Narrowing in Blocks and Lambdas"}),"\n",(0,t.jsx)(n.p,{children:"Type narrowing works within blocks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="block_narrowing.trb"',children:"def process_items(items: Array<String | nil>): Array<String>\n  result: Array<String> = []\n\n  items.each do |item|\n    # item is String | nil here\n    unless item.nil?\n      # item is String here\n      result << item.upcase\n    end\n  end\n\n  result\nend\n\ndef filter_and_map(items: Array<String | Integer>): Array<String>\n  items.map do |item|\n    if item.is_a?(String)\n      # item is String here\n      item.upcase\n    else\n      # item is Integer here\n      item.to_s\n    end\n  end\nend\n"})}),"\n",(0,t.jsx)(n.h2,{id:"practical-example-form-validator",children:"Practical Example: Form Validator"}),"\n",(0,t.jsx)(n.p,{children:"Here's a comprehensive example using type narrowing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="form_validator.trb"',children:'class FormValidator\n  def validate_field(\n    name: String,\n    value: String | Integer | Bool | nil,\n    required: Bool\n  ): String | nil\n    # Early return if required field is missing\n    if required && value.nil?\n      return "#{name} is required"\n    end\n\n    # If not required and nil, it\'s valid\n    return nil if value.nil?\n\n    # Now we know value is not nil\n    # Type narrowing allows us to check specific types\n\n    if value.is_a?(String)\n      # value is String here\n      return "#{name} cannot be empty" if value.empty?\n      return "#{name} is too long" if value.length > 100\n    elsif value.is_a?(Integer)\n      # value is Integer here\n      return "#{name} must be positive" if value < 0\n      return "#{name} is too large" if value > 1000\n    end\n    # value is Bool here (if it wasn\'t String or Integer)\n\n    # No errors\n    nil\n  end\n\n  def validate_email(email: String | nil): String | nil\n    return "Email is required" if email.nil?\n\n    # email is String here\n    return "Email cannot be empty" if email.empty?\n    return "Email must contain @" unless email.include?("@")\n    return "Email must contain domain" unless email.include?(".")\n\n    # All checks passed\n    nil\n  end\n\n  def validate_age(age: Integer | String | nil): String | nil\n    return "Age is required" if age.nil?\n\n    # Convert to integer if string\n    age_int: Integer\n\n    if age.is_a?(Integer)\n      age_int = age\n    else\n      # age is String here\n      return "Age must be a number" if age.to_i.to_s != age\n      age_int = age.to_i\n    end\n\n    # Now age_int is definitely an Integer\n    return "Age must be positive" if age_int < 0\n    return "Age must be realistic" if age_int > 150\n\n    nil\n  end\n\n  def validate_form(\n    name: String | nil,\n    email: String | nil,\n    age: Integer | String | nil\n  ): Hash<Symbol, Array<String>>\n    errors: Hash<Symbol, Array<String>> = {}\n\n    # Validate name\n    name_error = validate_field("Name", name, true)\n    if !name_error.nil?\n      errors[:name] = [name_error]\n    end\n\n    # Validate email\n    email_error = validate_email(email)\n    if !email_error.nil?\n      errors[:email] = [email_error]\n    end\n\n    # Validate age\n    age_error = validate_age(age)\n    if !age_error.nil?\n      errors[:age] = [age_error]\n    end\n\n    errors\n  end\nend\n\n# Usage\nvalidator = FormValidator.new()\n\n# Valid form\nerrors1 = validator.validate_form("Alice", "alice@example.com", 30)\n# Returns {}\n\n# Invalid form\nerrors2 = validator.validate_form(nil, "invalid-email", -5)\n# Returns {\n#   name: ["Name is required"],\n#   email: ["Email must contain @"],\n#   age: ["Age must be positive"]\n# }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"narrowing-limitations",children:"Narrowing Limitations"}),"\n",(0,t.jsx)(n.p,{children:"Type narrowing has some limitations to be aware of:"}),"\n",(0,t.jsx)(n.h3,{id:"narrowing-doesnt-persist-across-function-calls",children:"Narrowing Doesn't Persist Across Function Calls"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="narrowing_limits.trb"',children:"def helper(value: String | Integer)\n  # Cannot rely on narrowing from caller\n  if value.is_a?(String)\n    value.upcase\n  else\n    value.to_s\n  end\nend\n\ndef caller(value: String | Integer)\n  if value.is_a?(String)\n    # value is String here\n    result = helper(value)  # But helper doesn't know this\n  end\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"narrowing-doesnt-work-after-mutation",children:"Narrowing Doesn't Work After Mutation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="mutation_limits.trb"',children:"def example(value: String | Integer)\n  if value.is_a?(String)\n    # value is String here\n    value = value.to_i\n    # value is now Integer, not String!\n  end\n\n  # Cannot assume value is String here\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"complex-conditions-may-not-narrow",children:"Complex Conditions May Not Narrow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="complex_limits.trb"',children:'def complex(a: String | nil, b: String | nil): String\n  # This works\n  if !a.nil? && !b.nil?\n    # Both a and b are String here\n    a + b\n  else\n    "Missing values"\n  end\nend\n\ndef very_complex(value: String | Integer | nil): String\n  # Very complex conditions might not narrow as expected\n  # Better to use simpler, explicit checks\n  if value.is_a?(String)\n    value\n  elsif value.is_a?(Integer)\n    value.to_s\n  else\n    "nil"\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-use-guard-clauses",children:"1. Use Guard Clauses"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="guard_clauses.trb"',children:'# Good - early returns make narrowing clear\ndef process(value: String | nil): String\n  return "Empty" if value.nil?\n\n  # value is String from here on\n  value.upcase\nend\n\n# Avoid - nested ifs harder to follow\ndef process_nested(value: String | nil): String\n  if !value.nil?\n    value.upcase\n  else\n    "Empty"\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-check-nil-first",children:"2. Check nil First"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="nil_first.trb"',children:'# Good - check nil before other types\ndef process(value: String | Integer | nil): String\n  return "None" if value.nil?\n\n  if value.is_a?(String)\n    value\n  else\n    value.to_s\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-use-specific-type-checks",children:"3. Use Specific Type Checks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",metastring:'title="specific_checks.trb"',children:"# Good - specific type checks\ndef process(value: String | Integer): String\n  if value.is_a?(String)\n    value.upcase\n  else\n    value.to_s\n  end\nend\n\n# Avoid - vague checks\ndef process_vague(value: String | Integer): String\n  if value.respond_to?(:upcase)\n    # Less clear for type checker\n    value.upcase\n  else\n    value.to_s\n  end\nend\n"})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Type narrowing in T-Ruby allows the type checker to automatically refine types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type guards"}),": ",(0,t.jsx)(n.code,{children:"is_a?"}),", ",(0,t.jsx)(n.code,{children:"nil?"}),", and comparison operators"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Control flow"}),": Works with if/elsif/else, case/when, and ternary operators"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logical operators"}),": ",(0,t.jsx)(n.code,{children:"&&"})," and ",(0,t.jsx)(n.code,{children:"||"})," allow combined checks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Early returns"}),": Guard clauses narrow types for remaining code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Blocks"}),": Narrowing works within block scope"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Type narrowing makes union types practical by letting you safely access type-specific methods after checking the type. Combined with union types, it provides a powerful and type-safe way to handle diverse data."}),"\n",(0,t.jsx)(n.p,{children:"In the next chapter, you'll learn about literal types, which allow you to specify exact values as types."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8885:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var i=r(9378);const t={},a=i.createContext(t);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);