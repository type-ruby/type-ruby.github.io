"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"keyword-arguments-type-definitions","metadata":{"permalink":"/blog/keyword-arguments-type-definitions","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/blog/2025-12-29-keyword-arguments/index.md","source":"@site/blog/2025-12-29-keyword-arguments/index.md","title":"Handling Keyword Arguments in T-Ruby","description":"When we first released T-Ruby, one of the most frequently asked questions was: \\"How do I define keyword arguments?\\" \u2014 this was Issue #19 - and it turned out to be one of the most important design decisions for the language.","date":"2025-12-29T00:00:00.000Z","tags":[{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"},{"inline":true,"label":"syntax","permalink":"/blog/tags/syntax"},{"inline":true,"label":"keyword-arguments","permalink":"/blog/tags/keyword-arguments"}],"readingTime":4.74,"hasTruncateMarker":true,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"keyword-arguments-type-definitions","title":"Handling Keyword Arguments in T-Ruby","authors":["yhk1038"],"tags":["tutorial","syntax","keyword-arguments"]},"unlisted":false,"nextItem":{"title":"Building TypeScript-Style Type Inference for T-Ruby","permalink":"/blog/typescript-style-type-inference"}},"content":"When we first released T-Ruby, one of the most frequently asked questions was: **\\"How do I define keyword arguments?\\"** \u2014 this was [Issue #19](https://github.com/aspect-build/t-ruby/issues/19) - and it turned out to be one of the most important design decisions for the language.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Problem: Syntax Collision\\n\\nIn T-Ruby, type annotations use the colon syntax: `name: Type`. But Ruby\'s keyword arguments also use a colon: `name: value`. This creates a fundamental conflict.\\n\\nConsider this T-Ruby code:\\n\\n```ruby\\ndef foo(x: String, y: Integer = 10)\\n```\\n\\nIs `x` a keyword argument or a positional argument with a type annotation? In early T-Ruby, this was always treated as a **positional argument** - you\'d call it as `foo(\\"hi\\", 20)`.\\n\\nBut what if you wanted actual keyword arguments that you call as `foo(x: \\"hi\\", y: 20)`?\\n\\n## The Solution: A Simple Rule\\n\\nT-Ruby solves this with one elegant rule: **the presence of a variable name determines the meaning**.\\n\\n| Syntax | Meaning | Compiles To |\\n|--------|---------|-------------|\\n| `{ name: String }` | Keyword argument (destructuring) | `def foo(name:)` |\\n| `config: { host: String }` | Hash literal parameter | `def foo(config)` |\\n| `**opts: Type` | Double splat for forwarding | `def foo(**opts)` |\\n\\nLet\'s explore each pattern.\\n\\n## Pattern 1: Keyword Arguments with `{ }`\\n\\nWhen you use curly braces **without a variable name**, T-Ruby treats it as keyword argument destructuring:\\n\\n```ruby\\n# T-Ruby\\ndef greet({ name: String, prefix: String = \\"Hello\\" }): String\\n  \\"#{prefix}, #{name}!\\"\\nend\\n\\n# How to call it\\ngreet(name: \\"Alice\\")\\ngreet(name: \\"Bob\\", prefix: \\"Hi\\")\\n```\\n\\nThis compiles to:\\n\\n```ruby\\n# Ruby\\ndef greet(name:, prefix: \\"Hello\\")\\n  \\"#{prefix}, #{name}!\\"\\nend\\n```\\n\\nAnd generates this RBS signature:\\n\\n```rbs\\ndef greet: (name: String, ?prefix: String) -> String\\n```\\n\\n### Key Points\\n\\n- Wrap keyword arguments in `{ }`\\n- Each argument has a type: `name: String`\\n- Default values work naturally: `prefix: String = \\"Hello\\"`\\n- The `?` in RBS indicates optional parameters\\n\\n## Pattern 2: Hash Literal with Variable Name\\n\\nWhen you add a variable name before the braces, T-Ruby treats it as a Hash parameter:\\n\\n```ruby\\n# T-Ruby\\ndef process(config: { host: String, port: Integer }): String\\n  \\"#{config[:host]}:#{config[:port]}\\"\\nend\\n\\n# How to call it\\nprocess(config: { host: \\"localhost\\", port: 8080 })\\n```\\n\\nThis compiles to:\\n\\n```ruby\\n# Ruby\\ndef process(config)\\n  \\"#{config[:host]}:#{config[:port]}\\"\\nend\\n```\\n\\nUse this pattern when:\\n- You want to pass an entire Hash object\\n- You need to access values with `config[:key]` syntax\\n- The Hash might be stored or passed to other methods\\n\\n## Pattern 3: Double Splat with `**`\\n\\nFor collecting arbitrary keyword arguments or forwarding them to other methods:\\n\\n```ruby\\n# T-Ruby\\ndef with_transaction(**config: DbConfig): String\\n  conn = connect_db(**config)\\n  \\"BEGIN; #{conn}; COMMIT;\\"\\nend\\n```\\n\\nThis compiles to:\\n\\n```ruby\\n# Ruby\\ndef with_transaction(**config)\\n  conn = connect_db(**config)\\n  \\"BEGIN; #{conn}; COMMIT;\\"\\nend\\n```\\n\\nThe `**` is preserved because Ruby\'s `opts: Type` compiles to `def foo(opts:)` (a single keyword argument named `opts`), not `def foo(**opts)` (collecting all keyword arguments).\\n\\n## Mixing Positional and Keyword Arguments\\n\\nYou can combine positional arguments with keyword arguments:\\n\\n```ruby\\n# T-Ruby\\ndef mixed(id: Integer, { name: String, age: Integer = 0 }): String\\n  \\"#{id}: #{name} (#{age})\\"\\nend\\n\\n# How to call it\\nmixed(1, name: \\"Alice\\")\\nmixed(2, name: \\"Bob\\", age: 30)\\n```\\n\\nCompiles to:\\n\\n```ruby\\n# Ruby\\ndef mixed(id, name:, age: 0)\\n  \\"#{id}: #{name} (#{age})\\"\\nend\\n```\\n\\n## Using Interfaces\\n\\nFor complex configurations, define an interface and reference it:\\n\\n```ruby\\n# Define the interface\\ninterface ConnectionOptions\\n  host: String\\n  port?: Integer\\n  timeout?: Integer\\nend\\n\\n# Destructuring with interface reference - specify field names with defaults\\ndef connect({ host:, port: 8080, timeout: 30 }: ConnectionOptions): String\\n  \\"#{host}:#{port}\\"\\nend\\n\\n# How to call it\\nconnect(host: \\"localhost\\")\\nconnect(host: \\"localhost\\", port: 3000)\\n\\n# Double splat - for forwarding keyword arguments\\ndef forward(**opts: ConnectionOptions): String\\n  connect(**opts)\\nend\\n```\\n\\nNote that when using interface references, you must explicitly list the field names in the destructuring pattern. Default values are specified in the function definition, not in the interface.\\n\\n## Complete Example\\n\\nHere\'s a real-world example combining multiple patterns:\\n\\n```ruby\\n# T-Ruby\\nclass ApiClient\\n  def initialize({ base_url: String, timeout: Integer = 30 })\\n    @base_url = base_url\\n    @timeout = timeout\\n  end\\n\\n  def get({ path: String }): String\\n    \\"#{@base_url}#{path}\\"\\n  end\\n\\n  def post(path: String, { body: String, headers: Hash = {} }): String\\n    \\"POST #{@base_url}#{path}\\"\\n  end\\nend\\n\\n# Usage\\nclient = ApiClient.new(base_url: \\"https://api.example.com\\")\\nclient.get(path: \\"/users\\")\\nclient.post(\\"/users\\", body: \\"{}\\", headers: { \\"Content-Type\\" => \\"application/json\\" })\\n```\\n\\nThis compiles to:\\n\\n```ruby\\n# Ruby\\nclass ApiClient\\n  def initialize(base_url:, timeout: 30)\\n    @base_url = base_url\\n    @timeout = timeout\\n  end\\n\\n  def get(path:)\\n    \\"#{@base_url}#{path}\\"\\n  end\\n\\n  def post(path, body:, headers: {})\\n    \\"POST #{@base_url}#{path}\\"\\n  end\\nend\\n```\\n\\n## Quick Reference\\n\\n| What You Want | T-Ruby Syntax | Ruby Output |\\n|---------------|---------------|-------------|\\n| Required keyword arg | `{ name: String }` | `name:` |\\n| Optional keyword arg | `{ name: String = \\"default\\" }` | `name: \\"default\\"` |\\n| Multiple keyword args | `{ a: String, b: Integer }` | `a:, b:` |\\n| Hash parameter | `opts: { a: String }` | `opts` |\\n| Double splat | `**opts: Type` | `**opts` |\\n| Mixed | `id: Integer, { name: String }` | `id, name:` |\\n\\n## Design History\\n\\nWhen we first announced T-Ruby, the initial syntax used `**{}` for keyword arguments:\\n\\n```ruby\\n# Initial design (rejected)\\ndef greet(**{ name: String, prefix: String = \\"Hello\\" }): String\\n```\\n\\nCommunity feedback pointed out this was too complex. We explored several alternatives:\\n\\n| Alternative | Example | Result |\\n|-------------|---------|--------|\\n| Semicolon | `; name: String` | Rejected (worse readability) |\\n| Double colon | `name:: String` | Rejected (`::` conflicts with Ruby constants) |\\n| `named` keyword | `named name: String` | Considered |\\n| **Braces only** | `{ name: String }` | **Adopted** |\\n\\nThe final design uses a simple rule: the presence of a variable name determines the meaning. This creates a clean, intuitive syntax that doesn\'t require new keywords.\\n\\n## Summary\\n\\nT-Ruby\'s keyword argument syntax is designed to be intuitive:\\n\\n1. **Wrap in `{ }`** for keyword arguments\\n2. **Add a variable name** for Hash parameters\\n3. **Use `**`** for double splat forwarding\\n\\nThis simple rule eliminates the confusion between type annotations and Ruby keyword syntax, giving you the best of both worlds: TypeScript-style type safety with Ruby\'s expressive keyword arguments.\\n\\n---\\n\\n*Keyword argument support is available in T-Ruby v0.0.41 and later. Try it out and let us know what you think!*"},{"id":"typescript-style-type-inference","metadata":{"permalink":"/blog/typescript-style-type-inference","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/blog/2025-12-24-type-inference/index.md","source":"@site/blog/2025-12-24-type-inference/index.md","title":"Building TypeScript-Style Type Inference for T-Ruby","description":"How we implemented TypeScript-inspired static type inference for T-Ruby, enabling automatic type detection without explicit annotations.","date":"2025-12-24T00:00:00.000Z","tags":[{"inline":true,"label":"technical","permalink":"/blog/tags/technical"},{"inline":true,"label":"type-inference","permalink":"/blog/tags/type-inference"},{"inline":true,"label":"compiler","permalink":"/blog/tags/compiler"}],"readingTime":4.73,"hasTruncateMarker":true,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"typescript-style-type-inference","title":"Building TypeScript-Style Type Inference for T-Ruby","authors":["yhk1038"],"tags":["technical","type-inference","compiler"]},"unlisted":false,"prevItem":{"title":"Handling Keyword Arguments in T-Ruby","permalink":"/blog/keyword-arguments-type-definitions"},"nextItem":{"title":"Welcome to the T-Ruby Blog","permalink":"/blog/welcome"}},"content":"How we implemented TypeScript-inspired static type inference for T-Ruby, enabling automatic type detection without explicit annotations.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Problem\\n\\nWhen writing T-Ruby code, developers had to explicitly annotate every return type:\\n\\n```ruby\\ndef greet(name: String): String\\n  \\"Hello, #{name}!\\"\\nend\\n```\\n\\nWithout the `: String` return type, the generated RBS would show `untyped`:\\n\\n```rbs\\ndef greet: (name: String) -> untyped\\n```\\n\\nThis was frustrating. The return type is obviously `String` - why can\'t T-Ruby figure it out?\\n\\n## Inspiration: TypeScript\'s Approach\\n\\nTypeScript handles this elegantly. You can write:\\n\\n```typescript\\nfunction greet(name: string) {\\n  return `Hello, ${name}!`;\\n}\\n```\\n\\nAnd TypeScript infers the return type as `string`. We wanted the same experience for T-Ruby.\\n\\n### How TypeScript Does It\\n\\nTypeScript\'s type inference is built on two key components:\\n\\n1. **Binder**: Builds a Control Flow Graph (CFG) during parsing\\n2. **Checker**: Lazily evaluates types when needed, using flow analysis\\n\\nThe magic happens in `getFlowTypeOfReference` - a 1200+ line function that determines a symbol\'s type at any point in the code by walking backwards through flow nodes.\\n\\n### Our Simplified Approach\\n\\nRuby\'s control flow is simpler than JavaScript\'s. We don\'t need the full complexity of TypeScript\'s flow graph. Instead, we implemented:\\n\\n- **Linear data flow analysis** - Ruby\'s straightforward execution model\\n- **Separation of concerns** - IR Builder (Binder role) + ASTTypeInferrer (Checker role)\\n- **Lazy evaluation** - Types computed only when generating RBS\\n\\n## Architecture\\n\\n```\\n[Binder Stage - IR Builder]\\nSource (.trb) \u2192 Parser \u2192 IR Tree (with method bodies)\\n\\n[Checker Stage - Type Inferrer]\\nIR Node traversal \u2192 Type determination \u2192 Caching\\n\\n[Output Stage]\\nInferred types \u2192 RBS generation\\n```\\n\\n### The Core Components\\n\\n#### 1. BodyParser - Parsing Method Bodies\\n\\nThe first challenge was that our parser didn\'t analyze method bodies - it only extracted signatures. We built `BodyParser` to convert T-Ruby method bodies into IR nodes:\\n\\n```ruby\\nclass BodyParser\\n  def parse(lines, start_line, end_line)\\n    statements = []\\n    # Parse each line into IR nodes\\n    # Handle: literals, variables, operators, method calls, conditionals\\n    IR::Block.new(statements: statements)\\n  end\\nend\\n```\\n\\nSupported constructs:\\n- Literals: `\\"hello\\"`, `42`, `true`, `:symbol`\\n- Variables: `name`, `@instance_var`, `@@class_var`\\n- Operators: `a + b`, `x == y`, `!flag`\\n- Method calls: `str.upcase`, `array.map { |x| x * 2 }`\\n- Conditionals: `if`/`unless`/`elsif`/`else`\\n\\n#### 2. TypeEnv - Scope Chain Management\\n\\n```ruby\\nclass TypeEnv\\n  def initialize(parent = nil)\\n    @parent = parent\\n    @bindings = {}       # Local variables\\n    @instance_vars = {}  # Instance variables\\n  end\\n\\n  def lookup(name)\\n    @bindings[name] || @instance_vars[name] || @parent&.lookup(name)\\n  end\\n\\n  def child_scope\\n    TypeEnv.new(self)\\n  end\\nend\\n```\\n\\nThis enables proper scoping - a method\'s local variables don\'t leak into other methods, but instance variables are shared across the class.\\n\\n#### 3. ASTTypeInferrer - The Type Inference Engine\\n\\nThe heart of the system:\\n\\n```ruby\\nclass ASTTypeInferrer\\n  LITERAL_TYPE_MAP = {\\n    string: \\"String\\",\\n    integer: \\"Integer\\",\\n    float: \\"Float\\",\\n    boolean: \\"bool\\",\\n    symbol: \\"Symbol\\",\\n    nil: \\"nil\\"\\n  }.freeze\\n\\n  def infer_expression(node, env)\\n    # Check cache first (lazy evaluation)\\n    return @type_cache[node.object_id] if @type_cache[node.object_id]\\n\\n    type = case node\\n    when IR::Literal\\n      LITERAL_TYPE_MAP[node.literal_type]\\n    when IR::VariableRef\\n      env.lookup(node.name)\\n    when IR::BinaryOp\\n      infer_binary_op(node, env)\\n    when IR::MethodCall\\n      infer_method_call(node, env)\\n    # ... more cases\\n    end\\n\\n    @type_cache[node.object_id] = type\\n  end\\nend\\n```\\n\\n### Handling Ruby\'s Implicit Returns\\n\\nRuby\'s last expression is the implicit return value. This is crucial for type inference:\\n\\n```ruby\\ndef status\\n  if active?\\n    \\"running\\"\\n  else\\n    \\"stopped\\"\\n  end\\nend\\n# Implicit return: String (from both branches)\\n```\\n\\nWe handle this by:\\n1. Collecting all explicit `return` types\\n2. Finding the last expression (implicit return)\\n3. Unifying all return types\\n\\n```ruby\\ndef infer_method_return_type(method_node, env)\\n  # Collect explicit returns\\n  return_types, terminated = collect_return_types(method_node.body, env)\\n\\n  # Add implicit return (unless method always returns explicitly)\\n  unless terminated\\n    implicit_return = infer_implicit_return(method_node.body, env)\\n    return_types << implicit_return if implicit_return\\n  end\\n\\n  unify_types(return_types)\\nend\\n```\\n\\n### Special Case: `initialize` Method\\n\\nRuby\'s `initialize` is a constructor. Its return value is ignored - `Class.new` returns the instance. Following RBS conventions, we always infer `void`:\\n\\n```ruby\\nclass User\\n  def initialize(name: String)\\n    @name = name\\n  end\\nend\\n```\\n\\nGenerates:\\n\\n```rbs\\nclass User\\n  def initialize: (name: String) -> void\\nend\\n```\\n\\n### Built-in Method Type Knowledge\\n\\nWe maintain a table of common Ruby method return types:\\n\\n```ruby\\nBUILTIN_METHOD_TYPES = {\\n  %w[String upcase] => \\"String\\",\\n  %w[String downcase] => \\"String\\",\\n  %w[String length] => \\"Integer\\",\\n  %w[String to_i] => \\"Integer\\",\\n  %w[Array first] => \\"untyped\\",  # Element type\\n  %w[Array length] => \\"Integer\\",\\n  %w[Integer to_s] => \\"String\\",\\n  # ... 200+ methods\\n}.freeze\\n```\\n\\n## Results\\n\\nNow this T-Ruby code:\\n\\n```ruby\\nclass Greeter\\n  def initialize(name: String)\\n    @name = name\\n  end\\n\\n  def greet\\n    \\"Hello, #{@name}!\\"\\n  end\\n\\n  def shout\\n    @name.upcase\\n  end\\nend\\n```\\n\\nAutomatically generates correct RBS:\\n\\n```rbs\\nclass Greeter\\n  @name: String\\n\\n  def initialize: (name: String) -> void\\n  def greet: () -> String\\n  def shout: () -> String\\nend\\n```\\n\\nNo explicit return types needed!\\n\\n## Testing\\n\\nWe built comprehensive tests:\\n\\n- **Unit tests**: Literal inference, operator types, method call types\\n- **E2E tests**: Full compilation with RBS validation\\n\\n```ruby\\nit \\"infers String from string literal\\" do\\n  create_trb_file(\\"src/test.trb\\", <<~TRB)\\n    class Test\\n      def message\\n        \\"hello world\\"\\n      end\\n    end\\n  TRB\\n\\n  rbs_content = compile_and_get_rbs(\\"src/test.trb\\")\\n  expect(rbs_content).to include(\\"def message: () -> String\\")\\nend\\n```\\n\\n## Challenges & Solutions\\n\\n| Challenge | Solution |\\n|-----------|----------|\\n| Method bodies not parsed | Built custom BodyParser for T-Ruby syntax |\\n| Implicit returns | Analyze last expression in blocks |\\n| Recursive methods | 2-pass analysis (signatures first, then bodies) |\\n| Complex expressions | Gradual expansion: literals \u2192 variables \u2192 operators \u2192 method calls |\\n| Union types | Collect all return paths and unify |\\n\\n## Future Work\\n\\n- **Generic inference**: `[1, 2, 3]` \u2192 `Array[Integer]`\\n- **Block/lambda types**: Infer block parameter and return types\\n- **Type narrowing**: Smarter types after `if x.is_a?(String)`\\n- **Cross-method inference**: Use inferred types from other methods\\n\\n## Conclusion\\n\\nBy studying TypeScript\'s approach and adapting it for Ruby\'s simpler semantics, we built a practical type inference system. The key insights:\\n\\n1. **Parse method bodies** - You can\'t infer types without seeing the code\\n2. **Lazy evaluation with caching** - Don\'t compute until needed\\n3. **Handle Ruby idioms** - Implicit returns, `initialize`, etc.\\n4. **Start simple** - Literals first, then build up complexity\\n\\nType inference makes T-Ruby feel more natural. Write Ruby code, get type safety - no annotations required.\\n\\n---\\n\\n*The type inference system is available in T-Ruby. Try it out and let us know what you think!*"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/blog/2025-12-24-welcome/index.md","source":"@site/blog/2025-12-24-welcome/index.md","title":"Welcome to the T-Ruby Blog","description":"Welcome to the official T-Ruby blog! This is where we\'ll share tutorials, technical deep-dives, and insights about type-safe Ruby development.","date":"2025-12-24T00:00:00.000Z","tags":[{"inline":true,"label":"announcement","permalink":"/blog/tags/announcement"}],"readingTime":0.82,"hasTruncateMarker":true,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"welcome","title":"Welcome to the T-Ruby Blog","authors":["yhk1038"],"tags":["announcement"]},"unlisted":false,"prevItem":{"title":"Building TypeScript-Style Type Inference for T-Ruby","permalink":"/blog/typescript-style-type-inference"}},"content":"Welcome to the official T-Ruby blog! This is where we\'ll share tutorials, technical deep-dives, and insights about type-safe Ruby development.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What You\'ll Find Here\\n\\nThis blog will be your go-to resource for:\\n\\n### Tutorials\\n\\nStep-by-step guides to help you get the most out of T-Ruby. From basic type annotations to advanced generic patterns, we\'ll cover it all.\\n\\n### Technical Deep-Dives\\n\\nExplore the internals of T-Ruby\'s type system. Learn how type inference works, how RBS files are generated, and the design decisions behind the project.\\n\\n### Best Practices\\n\\nReal-world patterns and practices for writing type-safe Ruby code. We\'ll share examples from actual projects and discuss common pitfalls to avoid.\\n\\n### Community Highlights\\n\\nShowcasing interesting projects and contributions from the T-Ruby community.\\n\\n## Stay Updated\\n\\nFollow our [News](/news) section for release announcements and project updates. For in-depth content, bookmark this blog and check back regularly.\\n\\nWe\'re excited to share this journey with you. Happy typing!"}]}}')}}]);