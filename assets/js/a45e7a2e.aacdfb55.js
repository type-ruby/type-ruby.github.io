"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[7169],{3019:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"learn/functions/parameter-return-types","title":"Parameter & Return Types","description":"Typing function parameters and return values","source":"@site/docs/learn/functions/parameter-return-types.md","sourceDirName":"learn/functions","slug":"/learn/functions/parameter-return-types","permalink":"/docs/learn/functions/parameter-return-types","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/functions/parameter-return-types.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Parameter & Return Types","description":"Typing function parameters and return values"},"sidebar":"docsSidebar","previous":{"title":"Literal Types","permalink":"/docs/learn/everyday-types/literal-types"},"next":{"title":"Optional & Rest Parameters","permalink":"/docs/learn/functions/optional-rest-parameters"}}');var i=r(2714),s=r(8885);const a={sidebar_position:1,title:"Parameter & Return Types",description:"Typing function parameters and return values"},l="Parameter & Return Types",d={},o=[{value:"Basic Function Typing",id:"basic-function-typing",level:2},{value:"Return Type Inference",id:"return-type-inference",level:2},{value:"Multiple Return Types with Union Types",id:"multiple-return-types-with-union-types",level:2},{value:"Void Functions",id:"void-functions",level:2},{value:"Complex Parameter Types",id:"complex-parameter-types",level:2},{value:"Multiple Parameters",id:"multiple-parameters",level:2},{value:"Nilable Parameters",id:"nilable-parameters",level:2},{value:"Boolean Return Types",id:"boolean-return-types",level:2},{value:"Generic Return Types",id:"generic-return-types",level:2},{value:"Practical Example: User Service",id:"practical-example-user-service",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Factory Functions",id:"factory-functions",level:3},{value:"Converter Functions",id:"converter-functions",level:3},{value:"Validator Functions",id:"validator-functions",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"parameter--return-types",children:"Parameter & Return Types"})}),"\n",(0,i.jsx)(n.p,{children:"Functions are the building blocks of any Ruby program. In T-Ruby, you can add type annotations to function parameters and return values to catch errors early and make your code more self-documenting."}),"\n",(0,i.jsx)(n.h2,{id:"basic-function-typing",children:"Basic Function Typing"}),"\n",(0,i.jsx)(n.p,{children:"The simplest way to add types to a function is to annotate its parameters and return value:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="greetings.trb"',children:'def greet(name: String): String\n  "Hello, #{name}!"\nend\n\ndef add(x: Integer, y: Integer): Integer\n  x + y\nend\n\n# Using the functions\nputs greet("Alice")  # \u2713 OK\nputs add(5, 3)       # \u2713 OK\n\n# Type errors caught at compile time\ngreet(42)            # \u2717 Error: Expected String, got Integer\nadd("5", "3")        # \u2717 Error: Expected Integer, got String\n'})}),"\n",(0,i.jsx)(n.p,{children:"The syntax follows this pattern:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameter types"}),": ",(0,i.jsx)(n.code,{children:"parameter_name: Type"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Return type"}),": ",(0,i.jsx)(n.code,{children:": Type"})," after the parameter list"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"return-type-inference",children:"Return Type Inference"}),"\n",(0,i.jsx)(n.p,{children:"T-Ruby can often infer the return type based on your function body, but it's good practice to be explicit:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="inference.trb"',children:"# Return type explicitly annotated\ndef double(n: Integer): Integer\n  n * 2\nend\n\n# Return type inferred (but less clear)\ndef triple(n: Integer)\n  n * 3  # T-Ruby infers Integer return type\nend\n\n# Explicit is better - clearer for other developers\ndef quadruple(n: Integer): Integer\n  n * 4\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"multiple-return-types-with-union-types",children:"Multiple Return Types with Union Types"}),"\n",(0,i.jsx)(n.p,{children:"Sometimes a function can return different types depending on the situation. Use union types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="unions.trb"',children:'def find_user(id: Integer): User | nil\n  # Returns a User if found, or nil if not found\n  users = load_users()\n  users.find { |u| u.id == id }\nend\n\ndef parse_value(input: String): Integer | Float | nil\n  return nil if input.empty?\n\n  if input.include?(".")\n    input.to_f\n  else\n    input.to_i\n  end\nend\n\n# Using the functions\nuser = find_user(123)\nif user\n  puts user.name  # T-Ruby knows user is not nil here\nend\n\nvalue = parse_value("3.14")\n# value could be Integer, Float, or nil\n'})}),"\n",(0,i.jsx)(n.h2,{id:"void-functions",children:"Void Functions"}),"\n",(0,i.jsxs)(n.p,{children:["Functions that don't return a meaningful value use the ",(0,i.jsx)(n.code,{children:"void"})," return type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="void.trb"',children:'def log_message(message: String): void\n  puts "[LOG] #{message}"\n  # No explicit return needed\nend\n\ndef save_to_database(record: Record): void\n  database.insert(record)\n  # Side effect only, no return value\nend\n\n# These functions are called for their side effects\nlog_message("Application started")\nsave_to_database(user_record)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"complex-parameter-types",children:"Complex Parameter Types"}),"\n",(0,i.jsx)(n.p,{children:"Parameters can have any type, including arrays, hashes, and custom classes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="complex.trb"',children:'def process_names(names: Array<String>): Integer\n  names.map(&:capitalize).length\nend\n\ndef merge_configs(base: Hash<String, String>, override: Hash<String, String>): Hash<String, String>\n  base.merge(override)\nend\n\ndef send_email(user: User, message: EmailMessage): Boolean\n  email_service.send(user.email, message)\nend\n\n# Using complex types\ncount = process_names(["alice", "bob", "charlie"])\n\nconfig = merge_configs(\n  { "host" => "localhost", "port" => "3000" },\n  { "port" => "8080" }\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"multiple-parameters",children:"Multiple Parameters"}),"\n",(0,i.jsx)(n.p,{children:"Type each parameter individually:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="multiple_params.trb"',children:'def create_user(\n  name: String,\n  email: String,\n  age: Integer,\n  admin: Boolean\n): User\n  User.new(\n    name: name,\n    email: email,\n    age: age,\n    admin: admin\n  )\nend\n\ndef calculate_price(\n  base_price: Float,\n  tax_rate: Float,\n  discount: Float\n): Float\n  base_price * (1 + tax_rate) * (1 - discount)\nend\n\n# Calling with all parameters\nuser = create_user("Alice", "alice@example.com", 30, false)\nprice = calculate_price(100.0, 0.08, 0.10)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"nilable-parameters",children:"Nilable Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"?"})," shorthand for parameters that can be nil:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="nilable.trb"',children:'def format_name(first: String, middle: String?, last: String): String\n  if middle\n    "#{first} #{middle} #{last}"\n  else\n    "#{first} #{last}"\n  end\nend\n\ndef greet_with_title(name: String, title: String?): String\n  if title\n    "Hello, #{title} #{name}"\n  else\n    "Hello, #{name}"\n  end\nend\n\n# Calling with and without optional values\nfull_name = format_name("John", "Q", "Public")\nshort_name = format_name("Jane", nil, "Doe")\n\ngreeting1 = greet_with_title("Smith", "Dr.")\ngreeting2 = greet_with_title("Jones", nil)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note: ",(0,i.jsx)(n.code,{children:"String?"})," is shorthand for ",(0,i.jsx)(n.code,{children:"String | nil"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"boolean-return-types",children:"Boolean Return Types"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"Boolean"})," for functions that return true/false:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="boolean.trb"',children:'def is_valid_email(email: String): Boolean\n  email.include?("@") && email.include?(".")\nend\n\ndef has_permission(user: User, resource: String): Boolean\n  user.permissions.include?(resource)\nend\n\ndef is_adult(age: Integer): Boolean\n  age >= 18\nend\n\n# Using boolean functions\nif is_valid_email("user@example.com")\n  puts "Email is valid"\nend\n\ncan_edit = has_permission(current_user, "posts:edit")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"generic-return-types",children:"Generic Return Types"}),"\n",(0,i.jsx)(n.p,{children:"Functions can return generic types that preserve type information:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="generics.trb"',children:'def first_element<T>(array: Array<T>): T | nil\n  array.first\nend\n\ndef wrap_in_array<T>(value: T): Array<T>\n  [value]\nend\n\n# Type is preserved\nnumbers = [1, 2, 3]\nfirst_num = first_element(numbers)  # Type: Integer | nil\n\nstrings = ["a", "b", "c"]\nfirst_str = first_element(strings)  # Type: String | nil\n\nwrapped = wrap_in_array(42)  # Type: Array<Integer>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"practical-example-user-service",children:"Practical Example: User Service"}),"\n",(0,i.jsx)(n.p,{children:"Here's a complete example showing function typing in a real-world scenario:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="user_service.trb"',children:'class UserService\n  def find_by_id(id: Integer): User | nil\n    database.query("SELECT * FROM users WHERE id = ?", id).first\n  end\n\n  def find_by_email(email: String): User | nil\n    database.query("SELECT * FROM users WHERE email = ?", email).first\n  end\n\n  def create(name: String, email: String, age: Integer): User\n    user = User.new(name: name, email: email, age: age)\n    database.insert(user)\n    user\n  end\n\n  def update(id: Integer, attributes: Hash<String, String | Integer>): Boolean\n    result = database.update("users", id, attributes)\n    result.success?\n  end\n\n  def delete(id: Integer): void\n    database.delete("users", id)\n  end\n\n  def list_all(): Array<User>\n    database.query("SELECT * FROM users").map { |row| User.from_row(row) }\n  end\n\n  def count_users(): Integer\n    database.query("SELECT COUNT(*) FROM users").first\n  end\n\n  def is_email_taken(email: String): Boolean\n    find_by_email(email) != nil\n  end\nend\n\n# Using the service\nservice = UserService.new\n\n# Returns User | nil\nuser = service.find_by_id(123)\n\n# Returns User\nnew_user = service.create("Alice", "alice@example.com", 30)\n\n# Returns Boolean\nupdated = service.update(123, { "name" => "Bob", "age" => 31 })\n\n# Returns void\nservice.delete(456)\n\n# Returns Array<User>\nall_users = service.list_all()\n\n# Returns Integer\ntotal = service.count_users()\n\n# Returns Boolean\nexists = service.is_email_taken("test@example.com")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Always annotate public APIs"}),": Functions that are part of your public interface should always have explicit type annotations."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Be explicit with return types"}),": Even when T-Ruby can infer them, explicit return types serve as documentation."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use specific types"}),": Prefer ",(0,i.jsx)(n.code,{children:"String"})," over ",(0,i.jsx)(n.code,{children:"Object"}),", ",(0,i.jsx)(n.code,{children:"Array<Integer>"})," over ",(0,i.jsx)(n.code,{children:"Array"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use union types for multiple return values"}),": ",(0,i.jsx)(n.code,{children:"User | nil"})," is clearer than just returning any value."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use void for side-effect-only functions"}),": Makes it clear the function is called for its side effects, not its return value."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"factory-functions",children:"Factory Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="factory.trb"',children:'def create_admin_user(name: String, email: String): User\n  User.new(name: name, email: email, role: "admin", permissions: ["all"])\nend\n\ndef create_guest_user(): User\n  User.new(name: "Guest", email: "guest@example.com", role: "guest", permissions: [])\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"converter-functions",children:"Converter Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="converters.trb"',children:'def to_integer(value: String): Integer | nil\n  Integer(value) rescue nil\nend\n\ndef to_boolean(value: String): Boolean\n  ["true", "yes", "1"].include?(value.downcase)\nend\n\ndef to_array(value: String): Array<String>\n  value.split(",").map(&:strip)\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"validator-functions",children:"Validator Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",metastring:'title="validators.trb"',children:"def validate_password(password: String): Boolean\n  password.length >= 8 && password.match?(/[A-Z]/) && password.match?(/[0-9]/)\nend\n\ndef validate_age(age: Integer): Boolean\n  age >= 0 && age <= 150\nend\n\ndef validate_email(email: String): Boolean\n  email.match?(/\\A[^@\\s]+@[^@\\s]+\\z/)\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Function parameter and return type annotations are fundamental to T-Ruby. They:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Catch type errors at compile time"}),"\n",(0,i.jsx)(n.li,{children:"Serve as documentation for your code"}),"\n",(0,i.jsx)(n.li,{children:"Enable better IDE support with autocomplete and refactoring"}),"\n",(0,i.jsx)(n.li,{children:"Make your code more maintainable"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Start by adding types to your function signatures, and you'll immediately benefit from T-Ruby's type checking capabilities."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8885:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var t=r(9378);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);