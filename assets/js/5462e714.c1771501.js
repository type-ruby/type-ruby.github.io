"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[6539],{4479:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"learn/basics/type-annotations","title":"Type Annotations","description":"Learn the basics of type annotations in T-Ruby","source":"@site/docs/learn/basics/type-annotations.md","sourceDirName":"learn/basics","slug":"/learn/basics/type-annotations","permalink":"/docs/learn/basics/type-annotations","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/basics/type-annotations.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Type Annotations","description":"Learn the basics of type annotations in T-Ruby"},"sidebar":"docsSidebar","previous":{"title":"Project Configuration","permalink":"/docs/getting-started/project-configuration"},"next":{"title":"Basic Types","permalink":"/docs/learn/basics/basic-types"}}');var r=t(2714),i=t(8885);const s={sidebar_position:1,title:"Type Annotations",description:"Learn the basics of type annotations in T-Ruby"},l="Type Annotations",o={},c=[{value:"What Are Type Annotations?",id:"what-are-type-annotations",level:2},{value:"Variable Type Annotations",id:"variable-type-annotations",level:2},{value:"Basic Examples",id:"basic-examples",level:3},{value:"Why Annotate Variables?",id:"why-annotate-variables",level:3},{value:"Method Parameter Annotations",id:"method-parameter-annotations",level:2},{value:"Multiple Parameters",id:"multiple-parameters",level:3},{value:"Optional Parameters with Defaults",id:"optional-parameters-with-defaults",level:3},{value:"Return Type Annotations",id:"return-type-annotations",level:2},{value:"Why Return Types Matter",id:"why-return-types-matter",level:3},{value:"Complete Method Example",id:"complete-method-example",level:2},{value:"Block Parameter Annotations",id:"block-parameter-annotations",level:2},{value:"Instance Variables",id:"instance-variables",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Don&#39;t Over-Annotate",id:"dont-over-annotate",level:3},{value:"Be Consistent with Return Types",id:"be-consistent-with-return-types",level:3},{value:"Remember Nil Values",id:"remember-nil-values",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"type-annotations",children:"Type Annotations"})}),"\n",(0,r.jsx)(n.p,{children:"Type annotations are the foundation of T-Ruby's type system. They allow you to explicitly declare the types of variables, method parameters, and return values. This chapter will teach you the syntax and best practices for adding type information to your Ruby code."}),"\n",(0,r.jsx)(n.h2,{id:"what-are-type-annotations",children:"What Are Type Annotations?"}),"\n",(0,r.jsx)(n.p,{children:"Type annotations are special syntax that tells T-Ruby what type of data a variable, parameter, or return value should be. They help catch bugs early by ensuring that data flows through your program in the way you expect."}),"\n",(0,r.jsxs)(n.p,{children:["In T-Ruby, type annotations use a colon (",(0,r.jsx)(n.code,{children:":"}),") followed by the type name:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="hello.trb"',children:'# Variable with type annotation\nname: String = "Alice"\n\n# Method parameter with type annotation\ndef greet(person: String)\n  puts "Hello, #{person}!"\nend\n\n# Method with return type annotation\ndef get_age(): Integer\n  25\nend\n'})}),"\n",(0,r.jsx)(n.p,{children:"When T-Ruby transpiles this code, the type annotations are removed, leaving pure Ruby:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="hello.rb"',children:'# Variable with type annotation removed\nname = "Alice"\n\n# Method parameter without type annotation\ndef greet(person)\n  puts "Hello, #{person}!"\nend\n\n# Method without return type annotation\ndef get_age()\n  25\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"variable-type-annotations",children:"Variable Type Annotations"}),"\n",(0,r.jsx)(n.p,{children:"You can annotate variables when you declare them. The syntax is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"variable_name: Type = value\n"})}),"\n",(0,r.jsx)(n.h3,{id:"basic-examples",children:"Basic Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="variables.trb"',children:'# String variable\nmessage: String = "Hello, world!"\n\n# Integer variable\ncount: Integer = 42\n\n# Float variable\nprice: Float = 19.99\n\n# Boolean variable\nis_active: Bool = true\n'})}),"\n",(0,r.jsx)(n.h3,{id:"why-annotate-variables",children:"Why Annotate Variables?"}),"\n",(0,r.jsx)(n.p,{children:"Type annotations on variables serve several purposes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Documentation"}),": They make it clear what type of data a variable should hold"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Detection"}),": T-Ruby will catch type mismatches at transpile time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IDE Support"}),": Editors can provide better autocomplete and hints"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="error_example.trb"',children:'# This will cause a type error\nage: Integer = "twenty-five"  # Error: String assigned to Integer variable\n\n# This is correct\nage: Integer = 25\n'})}),"\n",(0,r.jsx)(n.h2,{id:"method-parameter-annotations",children:"Method Parameter Annotations"}),"\n",(0,r.jsx)(n.p,{children:"Method parameters should be annotated to specify what types of arguments the method accepts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="parameters.trb"',children:"def calculate_total(price: Float, quantity: Integer): Float\n  price * quantity\nend\n\n# Calling the method\ntotal = calculate_total(9.99, 3)  # Returns 29.97\n"})}),"\n",(0,r.jsx)(n.h3,{id:"multiple-parameters",children:"Multiple Parameters"}),"\n",(0,r.jsx)(n.p,{children:"When a method has multiple parameters, annotate each one:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="multiple_params.trb"',children:'def create_user(name: String, age: Integer, email: String)\n  {\n    name: name,\n    age: age,\n    email: email\n  }\nend\n\nuser = create_user("Alice", 30, "alice@example.com")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"optional-parameters-with-defaults",children:"Optional Parameters with Defaults"}),"\n",(0,r.jsx)(n.p,{children:"You can combine type annotations with default values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="defaults.trb"',children:'def greet(name: String, greeting: String = "Hello")\n  "#{greeting}, #{name}!"\nend\n\nputs greet("Alice")              # "Hello, Alice!"\nputs greet("Bob", "Hi")          # "Hi, Bob!"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"return-type-annotations",children:"Return Type Annotations"}),"\n",(0,r.jsx)(n.p,{children:"Return type annotations specify what type a method will return. They come after the parameter list, before the method body:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="return_types.trb"',children:'# Returns a String\ndef get_name(): String\n  "Alice"\nend\n\n# Returns an Integer\ndef get_age(): Integer\n  25\nend\n\n# Returns a Boolean\ndef is_adult?(age: Integer): Bool\n  age >= 18\nend\n\n# Returns nil (useful for side-effect methods)\ndef log_message(msg: String): nil\n  puts msg\n  nil\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"why-return-types-matter",children:"Why Return Types Matter"}),"\n",(0,r.jsx)(n.p,{children:"Return type annotations help prevent errors by ensuring methods always return the expected type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="return_safety.trb"',children:"def divide(a: Integer, b: Integer): Float\n  return 0.0 if b == 0  # Safe default\n  a.to_f / b\nend\n\n# T-Ruby knows this returns a Float\nresult: Float = divide(10, 3)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"complete-method-example",children:"Complete Method Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's a comprehensive example showing all annotation types together:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="complete_example.trb"',children:"# A method with parameter and return type annotations\ndef calculate_discount(\n  original_price: Float,\n  discount_percent: Integer,\n  is_member: Bool = false\n): Float\n  discount = original_price * (discount_percent / 100.0)\n\n  # Members get an extra 5% off\n  if is_member\n    discount += original_price * 0.05\n  end\n\n  original_price - discount\nend\n\n# Using the method\nregular_price: Float = calculate_discount(100.0, 10)\n# Returns 90.0\n\nmember_price: Float = calculate_discount(100.0, 10, true)\n# Returns 85.0\n"})}),"\n",(0,r.jsx)(n.p,{children:"This transpiles to clean Ruby:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="complete_example.rb"',children:"def calculate_discount(\n  original_price,\n  discount_percent,\n  is_member = false\n)\n  discount = original_price * (discount_percent / 100.0)\n\n  if is_member\n    discount += original_price * 0.05\n  end\n\n  original_price - discount\nend\n\nregular_price = calculate_discount(100.0, 10)\nmember_price = calculate_discount(100.0, 10, true)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"block-parameter-annotations",children:"Block Parameter Annotations"}),"\n",(0,r.jsx)(n.p,{children:"You can also annotate block parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="blocks.trb"',children:"def process_numbers(numbers: Array<Integer>)\n  numbers.map do |n: Integer|\n    n * 2\n  end\nend\n\nresult = process_numbers([1, 2, 3])\n# Returns [2, 4, 6]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"instance-variables",children:"Instance Variables"}),"\n",(0,r.jsx)(n.p,{children:"Instance variables in classes can be annotated as well:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="instance_vars.trb"',children:'class Person\n  def initialize(name: String, age: Integer)\n    @name: String = name\n    @age: Integer = age\n  end\n\n  def introduce(): String\n    "I\'m #{@name} and I\'m #{@age} years old"\n  end\nend\n\nperson = Person.new("Alice", 30)\nputs person.introduce()\n# Output: "I\'m Alice and I\'m 30 years old"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,r.jsx)(n.h3,{id:"dont-over-annotate",children:"Don't Over-Annotate"}),"\n",(0,r.jsx)(n.p,{children:"You don't need to annotate every single variable. T-Ruby has type inference (covered in the next chapter). Annotate when it adds clarity:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="over_annotation.trb"',children:"# Too much annotation\nx: Integer = 5\ny: Integer = 10\nsum: Integer = x + y\n\n# Better - let inference work\nx = 5\ny = 10\nsum: Integer = x + y  # Only annotate the result if needed\n"})}),"\n",(0,r.jsx)(n.h3,{id:"be-consistent-with-return-types",children:"Be Consistent with Return Types"}),"\n",(0,r.jsx)(n.p,{children:"If a method can return different types based on conditions, use a union type (covered later):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="inconsistent_return.trb"',children:'# This will cause an error - inconsistent returns\ndef get_value(flag: Bool): String\n  if flag\n    return "yes"\n  else\n    return 42  # Error: Integer doesn\'t match String return type\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"remember-nil-values",children:"Remember Nil Values"}),"\n",(0,r.jsxs)(n.p,{children:["If a method might return ",(0,r.jsx)(n.code,{children:"nil"}),", include it in the return type:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="nil_returns.trb"',children:'# Correct - includes nil possibility\ndef find_user(id: Integer): String | nil\n  return nil if id < 0\n  "User #{id}"\nend\n\n# This might be nil!\nuser = find_user(-1)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always annotate method parameters and return types"})," - These are your public contracts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Annotate variables when the type isn't obvious"})," - Help readers understand your code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use type inference for local variables"})," - Reduce clutter when the type is clear"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Be explicit in public APIs"})," - Library and module interfaces should be fully annotated"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Think of annotations as documentation"})," - They should make code easier to understand"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Type annotations in T-Ruby use the colon syntax to specify types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Variables: ",(0,r.jsx)(n.code,{children:'name: String = "Alice"'})]}),"\n",(0,r.jsxs)(n.li,{children:["Parameters: ",(0,r.jsx)(n.code,{children:"def greet(person: String)"})]}),"\n",(0,r.jsxs)(n.li,{children:["Return types: ",(0,r.jsx)(n.code,{children:"def get_age(): Integer"})]}),"\n",(0,r.jsxs)(n.li,{children:["Instance variables: ",(0,r.jsx)(n.code,{children:"@name: String = name"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Annotations provide safety, documentation, and better tooling support, and they're completely removed during transpilation to produce clean Ruby code."}),"\n",(0,r.jsx)(n.p,{children:"In the next chapter, you'll learn about the basic types available in T-Ruby."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8885:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var a=t(9378);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);