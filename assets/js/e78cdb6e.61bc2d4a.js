"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[3125],{4950:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"learn/advanced/type-aliases","title":"Type Aliases","description":"Creating custom type names","source":"@site/docs/learn/advanced/type-aliases.md","sourceDirName":"learn/advanced","slug":"/learn/advanced/type-aliases","permalink":"/docs/learn/advanced/type-aliases","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/advanced/type-aliases.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Type Aliases","description":"Creating custom type names"},"sidebar":"docsSidebar","previous":{"title":"Built-in Generics","permalink":"/docs/learn/generics/built-in-generics"},"next":{"title":"Intersection Types","permalink":"/docs/learn/advanced/intersection-types"}}');var r=s(2714),i=s(8885);const a={sidebar_position:1,title:"Type Aliases",description:"Creating custom type names"},l="Type Aliases",o={},d=[{value:"Why Type Aliases?",id:"why-type-aliases",level:2},{value:"Without Type Aliases",id:"without-type-aliases",level:3},{value:"With Type Aliases",id:"with-type-aliases",level:3},{value:"Basic Type Aliases",id:"basic-type-aliases",level:2},{value:"Simple Aliases",id:"simple-aliases",level:3},{value:"Union Type Aliases",id:"union-type-aliases",level:3},{value:"Collection Aliases",id:"collection-aliases",level:3},{value:"Generic Type Aliases",id:"generic-type-aliases",level:2},{value:"Basic Generic Aliases",id:"basic-generic-aliases",level:3},{value:"Complex Generic Aliases",id:"complex-generic-aliases",level:3},{value:"Partially Applied Generic Aliases",id:"partially-applied-generic-aliases",level:3},{value:"Practical Type Aliases",id:"practical-type-aliases",level:2},{value:"Domain-Specific Types",id:"domain-specific-types",level:3},{value:"Status and State Types",id:"status-and-state-types",level:3},{value:"JSON and API Types",id:"json-and-api-types",level:3},{value:"Function Types",id:"function-types",level:3},{value:"Type Alias Composition",id:"type-alias-composition",level:2},{value:"Recursive Type Aliases",id:"recursive-type-aliases",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Descriptive Names",id:"1-use-descriptive-names",level:3},{value:"2. Group Related Aliases",id:"2-group-related-aliases",level:3},{value:"3. Use Aliases for Complex Types",id:"3-use-aliases-for-complex-types",level:3},{value:"4. Don&#39;t Over-Alias Simple Types",id:"4-dont-over-alias-simple-types",level:3},{value:"Type Aliases vs Classes",id:"type-aliases-vs-classes",level:2},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Optional Types",id:"optional-types",level:3},{value:"Result Types",id:"result-types",level:3},{value:"Builder Types",id:"builder-types",level:3},{value:"Documentation with Type Aliases",id:"documentation-with-type-aliases",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{DocsBadge:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s,{}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"type-aliases",children:"Type Aliases"})}),"\n",(0,r.jsx)(n.p,{children:"Type aliases allow you to create custom names for types, making your code more readable and maintainable. Think of them as nicknames for types\u2014they don't create new types, but they make complex types easier to work with and understand."}),"\n",(0,r.jsx)(n.h2,{id:"why-type-aliases",children:"Why Type Aliases?"}),"\n",(0,r.jsx)(n.p,{children:"Type aliases serve several important purposes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improve readability"})," - Replace complex type expressions with meaningful names"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reduce repetition"})," - Define once, use everywhere"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Document intent"})," - Names can convey what the type represents"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplify refactoring"})," - Change the type in one place"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"without-type-aliases",children:"Without Type Aliases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Complex types repeated everywhere\ndef find_user(id: Integer): Hash<Symbol, String | Integer | Bool> | nil\n  # ...\nend\n\ndef update_user(id: Integer, data: Hash<Symbol, String | Integer | Bool>): Bool\n  # ...\nend\n\ndef create_user(data: Hash<Symbol, String | Integer | Bool>): Integer\n  # ...\nend\n\n# Hard to understand what this represents\nusers: Array<Hash<Symbol, String | Integer | Bool>> = []\n"})}),"\n",(0,r.jsx)(n.h3,{id:"with-type-aliases",children:"With Type Aliases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Define once\ntype UserData = Hash<Symbol, String | Integer | Bool>\n\n# Use everywhere - much clearer!\ndef find_user(id: Integer): UserData | nil\n  # ...\nend\n\ndef update_user(id: Integer, data: UserData): Bool\n  # ...\nend\n\ndef create_user(data: UserData): Integer\n  # ...\nend\n\n# Clear what this represents\nusers: Array<UserData> = []\n"})}),"\n",(0,r.jsx)(n.h2,{id:"basic-type-aliases",children:"Basic Type Aliases"}),"\n",(0,r.jsx)(n.p,{children:"The syntax for creating a type alias is simple:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"type AliasName = ExistingType\n"})}),"\n",(0,r.jsx)(n.h3,{id:"simple-aliases",children:"Simple Aliases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# Alias for a primitive type\ntype UserId = Integer\ntype EmailAddress = String\ntype Price = Float\n\n# Using the aliases\nuser_id: UserId = 123\nemail: EmailAddress = "alice@example.com"\nproduct_price: Price = 29.99\n\n# Functions using aliases\ndef send_email(to: EmailAddress, subject: String, body: String): Bool\n  # ...\nend\n\ndef calculate_discount(original: Price, percentage: Float): Price\n  original * (1.0 - percentage / 100.0)\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"union-type-aliases",children:"Union Type Aliases"}),"\n",(0,r.jsx)(n.p,{children:"Union types benefit greatly from aliases:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Before: Repeated union types\ndef process(value: String | Integer | Float): String\n  # ...\nend\n\ndef format(value: String | Integer | Float): String\n  # ...\nend\n\n# After: Clear alias\ntype Primitive = String | Integer | Float\n\ndef process(value: Primitive): String\n  # ...\nend\n\ndef format(value: Primitive): String\n  # ...\nend\n\n# More examples\ntype ID = Integer | String\ntype JSONValue = String | Integer | Float | Bool | nil\ntype Result = :success | :error | :pending\n"})}),"\n",(0,r.jsx)(n.h3,{id:"collection-aliases",children:"Collection Aliases"}),"\n",(0,r.jsx)(n.p,{children:"Make complex collection types more readable:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# Array aliases\ntype StringList = Array<String>\ntype NumberList = Array<Integer>\ntype UserList = Array<User>\n\n# Hash aliases\ntype StringMap = Hash<String, String>\ntype Configuration = Hash<Symbol, String | Integer>\ntype Cache = Hash<String, Any>\n\n# Nested collections\ntype Matrix = Array<Array<Integer>>\ntype TagMap = Hash<String, Array<String>>\ntype UsersByAge = Hash<Integer, Array<User>>\n\n# Using collection aliases\nusers: UserList = []\nconfig: Configuration = {\n  port: 3000,\n  host: "localhost",\n  debug: true\n}\n\ntags: TagMap = {\n  "ruby" => ["language", "dynamic"],\n  "rails" => ["framework", "web"]\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"generic-type-aliases",children:"Generic Type Aliases"}),"\n",(0,r.jsx)(n.p,{children:"Type aliases can themselves be generic, accepting type parameters:"}),"\n",(0,r.jsx)(n.h3,{id:"basic-generic-aliases",children:"Basic Generic Aliases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# A generic Result type\ntype Result<T> = T | nil\n\n# Usage\nuser_result: Result<User> = find_user(123)\ncount_result: Result<Integer> = count_records()\n\n# A generic callback type\ntype Callback<T> = Proc<T, void>\n\n# Usage\non_user_load: Callback<User> = ->(user: User): void { puts user.name }\non_count: Callback<Integer> = ->(count: Integer): void { puts count }\n\n# A generic pair type\ntype Pair<A, B> = Array<A | B>  # Simplified for example\n\n# Usage\nname_age: Pair<String, Integer> = ["Alice", 30]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"complex-generic-aliases",children:"Complex Generic Aliases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# A generic collection with metadata\ntype Collection<T> = Hash<Symbol, T | Integer | String>\n\n# Usage\nuser_collection: Collection<User> = {\n  data: User.new("Alice"),\n  count: 1,\n  status: "active"\n}\n\n# A generic transformation function type\ntype Transformer<T, U> = Proc<T, U>\n\n# Usage\nto_string: Transformer<Integer, String> = ->(n: Integer): String { n.to_s }\nto_length: Transformer<String, Integer> = ->(s: String): Integer { s.length }\n\n# A generic validator type\ntype Validator<T> = Proc<T, Bool>\n\n# Usage\npositive_validator: Validator<Integer> = ->(n: Integer): Bool { n > 0 }\nemail_validator: Validator<String> = ->(s: String): Bool { s.include?("@") }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"partially-applied-generic-aliases",children:"Partially Applied Generic Aliases"}),"\n",(0,r.jsx)(n.p,{children:"You can create aliases that fix some type parameters while leaving others open:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# Base generic type\ntype Response<T, E> = { success: Bool, data: T | nil, error: E | nil }\n\n# Partially applied - fix error type\ntype APIResponse<T> = Response<T, String>\n\n# Usage\nuser_response: APIResponse<User> = {\n  success: true,\n  data: User.new("Alice"),\n  error: nil\n}\n\nproduct_response: APIResponse<Product> = {\n  success: false,\n  data: nil,\n  error: "Product not found"\n}\n\n# Another example\ntype StringMap<V> = Hash<String, V>\n\n# Usage\nstring_to_int: StringMap<Integer> = { "one" => 1, "two" => 2 }\nstring_to_user: StringMap<User> = { "admin" => User.new("Admin") }\n'})}),"\n",(0,r.jsx)(n.h2,{id:"practical-type-aliases",children:"Practical Type Aliases"}),"\n",(0,r.jsx)(n.h3,{id:"domain-specific-types",children:"Domain-Specific Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# E-commerce domain\ntype ProductId = Integer\ntype OrderId = String\ntype CustomerId = Integer\ntype Price = Float\ntype Quantity = Integer\n\ntype Product = Hash<Symbol, ProductId | String | Price>\ntype OrderItem = Hash<Symbol, ProductId | Quantity | Price>\ntype Order = Hash<Symbol, OrderId | CustomerId | Array<OrderItem> | String>\n\n# Using domain types\ndef create_order(customer_id: CustomerId, items: Array<OrderItem>): Order\n  {\n    id: generate_order_id(),\n    customer_id: customer_id,\n    items: items,\n    status: "pending"\n  }\nend\n\ndef calculate_total(items: Array<OrderItem>): Price\n  items.reduce(0.0) { |sum, item| sum + item[:price] * item[:quantity] }\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"status-and-state-types",children:"Status and State Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Application states\ntype Status = :pending | :processing | :completed | :failed\ntype UserRole = :admin | :editor | :viewer\ntype Environment = :development | :staging | :production\n\n# HTTP-related types\ntype HTTPMethod = :get | :post | :put | :patch | :delete\ntype HTTPStatus = Integer  # Could be more specific: 200 | 404 | 500 etc.\ntype Headers = Hash<String, String>\n\n# Using state types\nclass Request\n  @method: HTTPMethod\n  @path: String\n  @headers: Headers\n  @status: Status\n\n  def initialize(method: HTTPMethod, path: String): void\n    @method = method\n    @path = path\n    @headers = {}\n    @status = :pending\n  end\n\n  def add_header(key: String, value: String): void\n    @headers[key] = value\n  end\n\n  def status: Status\n    @status\n  end\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"json-and-api-types",children:"JSON and API Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# JSON types\ntype JSONPrimitive = String | Integer | Float | Bool | nil\ntype JSONArray = Array<JSONValue>\ntype JSONObject = Hash<String, JSONValue>\ntype JSONValue = JSONPrimitive | JSONArray | JSONObject\n\n# API response types\ntype APIError = Hash<Symbol, String | Integer>\ntype APISuccess<T> = Hash<Symbol, Bool | T>\ntype APIResult<T> = APISuccess<T> | APIError\n\n# Using JSON types\ndef parse_config(json: String): JSONObject\n  # Parse JSON string to object\n  JSON.parse(json)\nend\n\ndef api_call<T>(endpoint: String): APIResult<T>\n  begin\n    data = fetch(endpoint)\n    { success: true, data: data }\n  rescue => e\n    { success: false, error: e.message, code: 500 }\n  end\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"function-types",children:"Function Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# Common function signatures\ntype Predicate<T> = Proc<T, Bool>\ntype Mapper<T, U> = Proc<T, U>\ntype Consumer<T> = Proc<T, void>\ntype Supplier<T> = Proc<T>\ntype Comparator<T> = Proc<T, T, Integer>\n\n# Using function types\ndef filter<T>(array: Array<T>, predicate: Predicate<T>): Array<T>\n  array.select { |item| predicate.call(item) }\nend\n\ndef map<T, U>(array: Array<T>, mapper: Mapper<T, U>): Array<U>\n  array.map { |item| mapper.call(item) }\nend\n\ndef for_each<T>(array: Array<T>, consumer: Consumer<T>): void\n  array.each { |item| consumer.call(item) }\nend\n\n# Usage\nnumbers = [1, 2, 3, 4, 5]\nis_even: Predicate<Integer> = ->(n: Integer): Bool { n.even? }\nevens = filter(numbers, is_even)  # [2, 4]\n\nto_string: Mapper<Integer, String> = ->(n: Integer): String { n.to_s }\nstrings = map(numbers, to_string)  # ["1", "2", "3", "4", "5"]\n\nprint_it: Consumer<Integer> = ->(n: Integer): void { puts n }\nfor_each(numbers, print_it)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-alias-composition",children:"Type Alias Composition"}),"\n",(0,r.jsx)(n.p,{children:"You can build complex type aliases from simpler ones:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Base types\ntype UserId = Integer\ntype Username = String\ntype Email = String\ntype Timestamp = Integer\n\n# Composed types\ntype UserIdentifier = UserId | Username | Email\ntype UserMetadata = Hash<Symbol, String | Timestamp>\ntype UserData = Hash<Symbol, UserIdentifier | String | Timestamp>\n\n# Full user type composed from parts\ntype User = {\n  id: UserId,\n  username: Username,\n  email: Email,\n  metadata: UserMetadata\n}\n\n# Another example: Building up complexity\ntype Coordinate = Float\ntype Point = Array<Coordinate>  # [x, y]\ntype Line = Array<Point>        # [point1, point2]\ntype Polygon = Array<Point>     # [point1, point2, point3, ...]\ntype Shape = Point | Line | Polygon\ntype DrawingLayer = Array<Shape>\ntype Drawing = Hash<String, DrawingLayer>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"recursive-type-aliases",children:"Recursive Type Aliases"}),"\n",(0,r.jsx)(n.admonition,{title:"Coming Soon",type:"caution",children:(0,r.jsx)(n.p,{children:"This feature is planned for a future release."})}),"\n",(0,r.jsx)(n.p,{children:"In the future, T-Ruby will support recursive type aliases for tree structures and linked lists:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Tree structure\ntype TreeNode<T> = {\n  value: T,\n  children: Array<TreeNode<T>>\n}\n\n# Linked list\ntype ListNode<T> = {\n  value: T,\n  next: ListNode<T> | nil\n}\n\n# JSON (fully recursive)\ntype JSONValue =\n  | String\n  | Integer\n  | Float\n  | Bool\n  | nil\n  | Array<JSONValue>\n  | Hash<String, JSONValue>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-use-descriptive-names",children:"1. Use Descriptive Names"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Good: Clear, descriptive names\ntype EmailAddress = String\ntype ProductPrice = Float\ntype UserRole = :admin | :editor | :viewer\n\n# Less good: Unclear abbreviations\ntype EA = String\ntype PP = Float\ntype UR = :admin | :editor | :viewer\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-group-related-aliases",children:"2. Group Related Aliases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Good: Organized by domain\n# User-related types\ntype UserId = Integer\ntype Username = String\ntype UserEmail = String\ntype UserData = Hash<Symbol, String | Integer>\n\n# Product-related types\ntype ProductId = Integer\ntype ProductName = String\ntype ProductPrice = Float\ntype ProductData = Hash<Symbol, String | Integer | Float>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-use-aliases-for-complex-types",children:"3. Use Aliases for Complex Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Good: Alias for complex type used multiple times\ntype QueryResult = Hash<Symbol, Array<Hash<String, String | Integer>> | Integer>\n\ndef execute_query(sql: String): QueryResult\n  # ...\nend\n\ndef cache_result(key: String, result: QueryResult): void\n  # ...\nend\n\n# Less good: Repeating complex type\ndef execute_query(sql: String): Hash<Symbol, Array<Hash<String, String | Integer>> | Integer>\n  # ...\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-dont-over-alias-simple-types",children:"4. Don't Over-Alias Simple Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Unnecessary: String is already clear\ntype S = String\ntype N = Integer\n\n# Good: Only alias when it adds meaning\ntype EmailAddress = String  # Adds semantic meaning\ntype UserId = Integer       # Clarifies purpose\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-aliases-vs-classes",children:"Type Aliases vs Classes"}),"\n",(0,r.jsx)(n.p,{children:"Type aliases don't create new types\u2014they're just alternative names. This is different from classes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Type alias - just a name\ntype UserId = Integer\n\n# Both are the same type\nid1: UserId = 123\nid2: Integer = 456\nid1 = id2  # OK - they're the same type\n\n# Class - creates a new type\nclass UserIdClass\n  @value: Integer\n\n  def initialize(value: Integer): void\n    @value = value\n  end\nend\n\n# These are different types\nuser_id: UserIdClass = UserIdClass.new(123)\nint_id: Integer = 456\n# user_id = int_id  # Error: Different types!\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# Use type aliases when:\n# - You want semantic clarity but same underlying behavior\n# - You want to simplify complex type expressions\ntype EmailAddress = String\ntype JSONData = Hash<String, Any>\n\n# Use classes when:\n# - You need distinct types with different behavior\n# - You want encapsulation and methods\n# - You need runtime type checking\nclass Email\n  @address: String\n\n  def initialize(address: String): void\n    raise "Invalid email" unless address.include?("@")\n    @address = address\n  end\n\n  def domain: String\n    @address.split("@").last\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"optional-types",children:"Optional Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# Optional/nullable type aliases\ntype Optional<T> = T | nil\ntype Nullable<T> = T | nil\n\n# Usage\nuser: Optional<User> = find_user(123)\nname: Nullable<String> = user&.name\n"})}),"\n",(0,r.jsx)(n.h3,{id:"result-types",children:"Result Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# Result type for operations that can fail\ntype Result<T, E> = { success: Bool, value: T | nil, error: E | nil }\ntype SimpleResult<T> = T | Error\n\n# Usage\ndef divide(a: Float, b: Float): Result<Float, String>\n  if b == 0\n    { success: false, value: nil, error: "Division by zero" }\n  else\n    { success: true, value: a / b, error: nil }\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"builder-types",children:"Builder Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:'# Configuration builders\ntype Config = Hash<Symbol, String | Integer | Bool>\ntype ConfigBuilder = Proc<Config, Config>\n\n# Usage\ndef configure(&block: ConfigBuilder): Config\n  config = {\n    port: 3000,\n    host: "localhost",\n    debug: false\n  }\n  block.call(config)\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"documentation-with-type-aliases",children:"Documentation with Type Aliases"}),"\n",(0,r.jsx)(n.p,{children:"Type aliases serve as inline documentation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",children:"# The alias name documents what the type represents\ntype PositiveInteger = Integer  # Should be > 0\ntype NonEmptyString = String    # Should not be empty\ntype Percentage = Float         # Should be 0.0 to 100.0\n\ndef calculate_discount(price: Float, discount: Percentage): Float\n  price * (1.0 - discount / 100.0)\nend\n\ndef repeat(text: NonEmptyString, times: PositiveInteger): String\n  text * times\nend\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"Now that you understand type aliases, explore:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/learn/advanced/intersection-types",children:"Intersection Types"})," for combining multiple types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/learn/everyday-types/union-types",children:"Union Types"})," for either-or type relationships"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/learn/advanced/utility-types",children:"Utility Types"})," for advanced type transformations"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8885:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var t=s(9378);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);