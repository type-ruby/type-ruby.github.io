"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[4848],{1446:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"learn/advanced/utility-types","title":"Utility Types","description":"Built-in utility types for common transformations","source":"@site/docs/learn/advanced/utility-types.md","sourceDirName":"learn/advanced","slug":"/learn/advanced/utility-types","permalink":"/docs/learn/advanced/utility-types","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/advanced/utility-types.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Utility Types","description":"Built-in utility types for common transformations"},"sidebar":"docsSidebar","previous":{"title":"Mapped Types","permalink":"/docs/learn/advanced/mapped-types"},"next":{"title":"Commands","permalink":"/docs/cli/commands"}}');var i=t(2714),a=t(8885);const s={sidebar_position:5,title:"Utility Types",description:"Built-in utility types for common transformations"},l="Utility Types",d={},o=[{value:"Property Modifiers",id:"property-modifiers",level:2},{value:"Partial&lt;T&gt;",id:"partialt",level:3},{value:"Required&lt;T&gt;",id:"requiredt",level:3},{value:"Readonly&lt;T&gt;",id:"readonlyt",level:3},{value:"Property Selection",id:"property-selection",level:2},{value:"Pick&lt;T, K&gt;",id:"pickt-k",level:3},{value:"Omit&lt;T, K&gt;",id:"omitt-k",level:3},{value:"Union and Intersection Operations",id:"union-and-intersection-operations",level:2},{value:"Exclude&lt;T, U&gt;",id:"excludet-u",level:3},{value:"Extract&lt;T, U&gt;",id:"extractt-u",level:3},{value:"NonNullable&lt;T&gt;",id:"nonnullablet",level:3},{value:"Function Types",id:"function-types",level:2},{value:"ReturnType&lt;T&gt;",id:"returntypet",level:3},{value:"Parameters&lt;T&gt;",id:"parameterst",level:3},{value:"Record Types",id:"record-types",level:2},{value:"Record&lt;K, V&gt;",id:"recordk-v",level:3},{value:"Array and Tuple Utilities",id:"array-and-tuple-utilities",level:2},{value:"ArrayElement&lt;T&gt;",id:"arrayelementt",level:3},{value:"ReadonlyArray&lt;T&gt;",id:"readonlyarrayt",level:3},{value:"Practical Utility Types",id:"practical-utility-types",level:2},{value:"DeepPartial&lt;T&gt;",id:"deeppartialt",level:3},{value:"DeepReadonly&lt;T&gt;",id:"deepreadonlyt",level:3},{value:"Mutable&lt;T&gt;",id:"mutablet",level:3},{value:"Composition Utilities",id:"composition-utilities",level:2},{value:"Merge&lt;T, U&gt;",id:"merget-u",level:3},{value:"Intersection&lt;T, U&gt;",id:"intersectiont-u",level:3},{value:"Difference&lt;T, U&gt;",id:"differencet-u",level:3},{value:"Conditional Utilities",id:"conditional-utilities",level:2},{value:"If&lt;Condition, Then, Else&gt;",id:"ifcondition-then-else",level:3},{value:"Nullable&lt;T&gt;",id:"nullablet",level:3},{value:"Promisify&lt;T&gt;",id:"promisifyt",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"API Response Types",id:"api-response-types",level:3},{value:"Form State Management",id:"form-state-management",level:3},{value:"Repository Pattern",id:"repository-pattern",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Compose Utilities",id:"1-compose-utilities",level:3},{value:"2. Create Domain-Specific Utilities",id:"2-create-domain-specific-utilities",level:3},{value:"3. Document Complex Utilities",id:"3-document-complex-utilities",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{DocsBadge:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t,{}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"utility-types",children:"Utility Types"})}),"\n",(0,i.jsx)(n.admonition,{title:"Coming Soon",type:"caution",children:(0,i.jsx)(n.p,{children:"This feature is planned for a future release."})}),"\n",(0,i.jsx)(n.p,{children:"Utility types are pre-built generic types that perform common type transformations. They're like a standard library for types, providing ready-to-use solutions for everyday type manipulation tasks. Understanding these utilities will make your T-Ruby code more concise and expressive."}),"\n",(0,i.jsx)(n.h2,{id:"property-modifiers",children:"Property Modifiers"}),"\n",(0,i.jsx)(n.h3,{id:"partialt",children:"Partial<T>"}),"\n",(0,i.jsx)(n.p,{children:"Makes all properties of a type optional:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Partial<T> = {\n  [K in keyof T]?: T[K]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String,\n  age: Integer\n}\n\ntype PartialUser = Partial<User>\n# {\n#   id?: Integer,\n#   name?: String,\n#   email?: String,\n#   age?: Integer\n# }\n\n# Usage - update functions often use Partial\ndef update_user(id: Integer, updates: Partial<User>): User\n  user = find_user(id)\n  # Apply only the provided updates\n  user.name = updates[:name] if updates[:name]\n  user.email = updates[:email] if updates[:email]\n  user.age = updates[:age] if updates[:age]\n  user\nend\n\n# Can provide any subset of properties\nupdate_user(1, { name: "Alice" })\nupdate_user(1, { name: "Bob", email: "bob@example.com" })\nupdate_user(1, {})  # Valid, no updates\n'})}),"\n",(0,i.jsx)(n.h3,{id:"requiredt",children:"Required<T>"}),"\n",(0,i.jsx)(n.p,{children:"Makes all properties required (removes optionality):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type Required<T> = {\n  [K in keyof T]-?: T[K]\n}\n\ntype UserUpdate = {\n  id?: Integer,\n  name?: String,\n  email?: String\n}\n\ntype RequiredUserUpdate = Required<UserUpdate>\n# {\n#   id: Integer,\n#   name: String,\n#   email: String\n# }\n\n# Usage - ensure all fields are present\ndef create_user(data: Required<UserUpdate>): User\n  # All fields guaranteed to be present\n  User.new(data[:id], data[:name], data[:email])\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"readonlyt",children:"Readonly<T>"}),"\n",(0,i.jsx)(n.p,{children:"Makes all properties readonly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Readonly<T> = {\n  readonly [K in keyof T]: T[K]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\ntype ReadonlyUser = Readonly<User>\n\n# Usage - prevent modifications\ndef display_user(user: ReadonlyUser): void\n  puts "User: #{user.name}"\n  # user.name = "Changed"  # Error: Cannot modify readonly property\nend\n\n# Common pattern: freeze configuration\ntype Config = Readonly<{\n  api_url: String,\n  timeout: Integer,\n  max_retries: Integer\n}>\n\nconfig: Config = {\n  api_url: "https://api.example.com",\n  timeout: 30,\n  max_retries: 3\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"property-selection",children:"Property Selection"}),"\n",(0,i.jsx)(n.h3,{id:"pickt-k",children:"Pick<T, K>"}),"\n",(0,i.jsx)(n.p,{children:"Creates a type by picking specific properties from another type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Pick<T, K extends keyof T> = {\n  [P in K]: T[P]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String,\n  password: String,\n  created_at: Time,\n  updated_at: Time\n}\n\n# Pick only public fields\ntype PublicUser = Pick<User, "id" | "name" | "email">\n# {\n#   id: Integer,\n#   name: String,\n#   email: String\n# }\n\n# Pick authentication fields\ntype AuthUser = Pick<User, "id" | "email" | "password">\n# {\n#   id: Integer,\n#   email: String,\n#   password: String\n# }\n\n# Usage\ndef get_public_user(user: User): PublicUser\n  {\n    id: user.id,\n    name: user.name,\n    email: user.email\n  }\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"omitt-k",children:"Omit<T, K>"}),"\n",(0,i.jsx)(n.p,{children:"Creates a type by omitting specific properties from another type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Omit<T, K extends keyof T> = {\n  [P in Exclude<keyof T, K>]: T[P]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String,\n  password: String,\n  created_at: Time,\n  updated_at: Time\n}\n\n# Omit sensitive data\ntype SafeUser = Omit<User, "password">\n# {\n#   id: Integer,\n#   name: String,\n#   email: String,\n#   created_at: Time,\n#   updated_at: Time\n# }\n\n# Omit generated fields for creation\ntype UserInput = Omit<User, "id" | "created_at" | "updated_at">\n# {\n#   name: String,\n#   email: String,\n#   password: String\n# }\n\n# Usage\ndef create_user(input: UserInput): User\n  User.new(\n    id: generate_id(),\n    name: input[:name],\n    email: input[:email],\n    password: hash_password(input[:password]),\n    created_at: Time.now,\n    updated_at: Time.now\n  )\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"union-and-intersection-operations",children:"Union and Intersection Operations"}),"\n",(0,i.jsx)(n.h3,{id:"excludet-u",children:"Exclude<T, U>"}),"\n",(0,i.jsx)(n.p,{children:"Excludes types from a union:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Exclude<T, U> = T extends U ? never : T\n\ntype AllTypes = String | Integer | Float | Boolean\ntype NumericOnly = Exclude<AllTypes, String | Boolean>\n# Integer | Float\n\ntype Status = "pending" | "approved" | "rejected" | "cancelled"\ntype ActiveStatus = Exclude<Status, "cancelled">\n# "pending" | "approved" | "rejected"\n\n# Usage\ndef process_active_order(status: ActiveStatus): void\n  case status\n  when "pending"\n    puts "Processing pending order"\n  when "approved"\n    puts "Shipping approved order"\n  when "rejected"\n    puts "Handling rejected order"\n  # "cancelled" is not possible here\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"extractt-u",children:"Extract<T, U>"}),"\n",(0,i.jsx)(n.p,{children:"Extracts types from a union:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Extract<T, U> = T extends U ? T : never\n\ntype AllTypes = String | Integer | Float | Boolean\ntype NumericOnly = Extract<AllTypes, Integer | Float>\n# Integer | Float\n\ntype Status = "pending" | "approved" | "rejected" | "cancelled"\ntype FinalStatus = Extract<Status, "approved" | "rejected" | "cancelled">\n# "approved" | "rejected" | "cancelled"\n\n# Usage\ndef finalize_order(status: FinalStatus): void\n  # Only final statuses allowed\n  puts "Order is in final state: #{status}"\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"nonnullablet",children:"NonNullable<T>"}),"\n",(0,i.jsxs)(n.p,{children:["Removes ",(0,i.jsx)(n.code,{children:"nil"})," from a type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type NonNullable<T> = T extends nil ? never : T\n\ntype MaybeString = String | nil\ntype DefiniteString = NonNullable<MaybeString>\n# String\n\ntype MixedTypes = String | Integer | nil | Float | nil\ntype WithoutNil = NonNullable<MixedTypes>\n# String | Integer | Float\n\n# Usage\ndef process_value<T>(value: T | nil): NonNullable<T>\n  raise "Value cannot be nil" if value.nil?\n  value  # Type narrowed to T (without nil)\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"function-types",children:"Function Types"}),"\n",(0,i.jsx)(n.h3,{id:"returntypet",children:"ReturnType<T>"}),"\n",(0,i.jsx)(n.p,{children:"Extracts the return type of a function type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type ReturnType<T> = T extends Proc<any, infer R> ? R : never\n\ntype GetUserFn = Proc<Integer, User>\ntype UserType = ReturnType<GetUserFn>\n# User\n\ntype CalculateFn = Proc<Integer, Integer, Float>\ntype ResultType = ReturnType<CalculateFn>\n# Float\n\n# Usage - infer return type from function\ndef wrap_function<F>(fn: F): Proc<any, ReturnType<F>>\n  ->(args: any): ReturnType<F> {\n    result = fn.call(args)\n    puts "Function returned: #{result}"\n    result\n  }\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"parameterst",children:"Parameters<T>"}),"\n",(0,i.jsx)(n.p,{children:"Extracts parameter types from a function type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Parameters<T> = T extends Proc<infer P, any> ? P : never\n\ntype GetUserFn = Proc<Integer, User>\ntype GetUserParams = Parameters<GetUserFn>\n# Integer\n\ntype CreateUserFn = Proc<String, String, Integer, User>\ntype CreateUserParams = Parameters<CreateUserFn>\n# [String, String, Integer]\n\n# Usage\ndef call_with_logging<F>(fn: F, ...args: Parameters<F>): ReturnType<F>\n  puts "Calling function with args: #{args}"\n  result = fn.call(*args)\n  puts "Function returned: #{result}"\n  result\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"record-types",children:"Record Types"}),"\n",(0,i.jsx)(n.h3,{id:"recordk-v",children:"Record<K, V>"}),"\n",(0,i.jsx)(n.p,{children:"Creates a type with keys of type K and values of type V:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Record<K extends String | Symbol | Integer, V> = {\n  [P in K]: V\n}\n\n# String keys, Integer values\ntype StringToInt = Record<String, Integer>\n# { [key: String]: Integer }\n\n# Specific string literal keys\ntype StatusMap = Record<"pending" | "approved" | "rejected", Boolean>\n# {\n#   pending: Boolean,\n#   approved: Boolean,\n#   rejected: Boolean\n# }\n\n# Usage examples\nstatus_flags: StatusMap = {\n  pending: true,\n  approved: false,\n  rejected: false\n}\n\n# User ID to User mapping\nuser_cache: Record<Integer, User> = {\n  1 => User.new(1, "Alice"),\n  2 => User.new(2, "Bob")\n}\n\n# Configuration by environment\nconfigs: Record<"development" | "staging" | "production", Config> = {\n  development: dev_config,\n  staging: staging_config,\n  production: prod_config\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"array-and-tuple-utilities",children:"Array and Tuple Utilities"}),"\n",(0,i.jsx)(n.h3,{id:"arrayelementt",children:"ArrayElement<T>"}),"\n",(0,i.jsx)(n.p,{children:"Extracts the element type from an array:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type ArrayElement<T> = T extends Array<infer E> ? E : never\n\ntype StringArray = Array<String>\ntype StringElement = ArrayElement<StringArray>\n# String\n\ntype UserArray = Array<User>\ntype UserElement = ArrayElement<UserArray>\n# User\n\n# Usage\ndef first_element<T>(arr: Array<T>): ArrayElement<Array<T>> | nil\n  arr.first\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"readonlyarrayt",children:"ReadonlyArray<T>"}),"\n",(0,i.jsx)(n.p,{children:"An array whose elements cannot be modified:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type ReadonlyArray<T> = readonly Array<T>\n\n# Usage\ndef process_items(items: ReadonlyArray<String>): void\n  items.each { |item| puts item }\n  # items.push("new")  # Error: Cannot modify readonly array\n  # items[0] = "changed"  # Error: Cannot modify readonly array\nend\n\n# Useful for constants\nALLOWED_STATUSES: ReadonlyArray<String> = ["pending", "approved", "rejected"]\n'})}),"\n",(0,i.jsx)(n.h2,{id:"practical-utility-types",children:"Practical Utility Types"}),"\n",(0,i.jsx)(n.h3,{id:"deeppartialt",children:"DeepPartial<T>"}),"\n",(0,i.jsx)(n.p,{children:"Makes all properties and nested properties optional:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends Hash<any, any>\n    ? DeepPartial<T[K]>\n    : T[K]\n}\n\ntype User = {\n  id: Integer,\n  profile: {\n    name: String,\n    email: String,\n    settings: {\n      theme: String,\n      notifications: Boolean\n    }\n  }\n}\n\ntype DeepPartialUser = DeepPartial<User>\n# All properties at all levels are optional\n\n# Usage - deep updates\ndef deep_update_user(id: Integer, updates: DeepPartial<User>): User\n  user = find_user(id)\n  # Can update any nested property\n  user.profile.name = updates[:profile][:name] if updates[:profile]&.[](:name)\n  user.profile.settings.theme = updates[:profile][:settings][:theme] if updates[:profile][:settings]&.[](:theme)\n  user\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"deepreadonlyt",children:"DeepReadonly<T>"}),"\n",(0,i.jsx)(n.p,{children:"Makes all properties and nested properties readonly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends Hash<any, any>\n    ? DeepReadonly<T[K]>\n    : T[K]\n}\n\ntype Config = {\n  app: {\n    name: String,\n    version: String,\n    features: {\n      auth: Boolean,\n      api: Boolean\n    }\n  }\n}\n\ntype ImmutableConfig = DeepReadonly<Config>\n# All nested properties are readonly\n\nconfig: ImmutableConfig = load_config()\n# config.app.name = "New"  # Error: readonly\n# config.app.features.auth = false  # Error: readonly\n'})}),"\n",(0,i.jsx)(n.h3,{id:"mutablet",children:"Mutable<T>"}),"\n",(0,i.jsx)(n.p,{children:"Removes readonly modifiers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type Mutable<T> = {\n  -readonly [K in keyof T]: T[K]\n}\n\ntype ReadonlyUser = {\n  readonly id: Integer,\n  readonly name: String\n}\n\ntype MutableUser = Mutable<ReadonlyUser>\n# {\n#   id: Integer,\n#   name: String\n# }\n\n# Usage - create mutable copy\ndef clone_user(user: ReadonlyUser): MutableUser\n  {\n    id: user.id,\n    name: user.name\n  }\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"composition-utilities",children:"Composition Utilities"}),"\n",(0,i.jsx)(n.h3,{id:"merget-u",children:"Merge<T, U>"}),"\n",(0,i.jsx)(n.p,{children:"Merges two types, with U's properties overriding T's:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type Merge<T, U> = Omit<T, keyof U> & U\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\ntype UserUpdate = {\n  email: String | nil,  # Allow null\n  updated_at: Time      # New property\n}\n\ntype MergedUser = Merge<User, UserUpdate>\n# {\n#   id: Integer,\n#   name: String,\n#   email: String | nil,    # Overridden\n#   updated_at: Time        # Added\n# }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"intersectiont-u",children:"Intersection<T, U>"}),"\n",(0,i.jsx)(n.p,{children:"Gets properties that exist in both types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type Intersection<T, U> = Pick<T, Extract<keyof T, keyof U>>\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\ntype Person = {\n  name: String,\n  email: String,\n  age: Integer\n}\n\ntype Common = Intersection<User, Person>\n# {\n#   name: String,\n#   email: String\n# }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"differencet-u",children:"Difference<T, U>"}),"\n",(0,i.jsx)(n.p,{children:"Gets properties that exist in T but not in U:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type Difference<T, U> = Omit<T, keyof U>\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String,\n  password: String\n}\n\ntype PublicFields = {\n  id: Integer,\n  name: String\n}\n\ntype PrivateFields = Difference<User, PublicFields>\n# {\n#   email: String,\n#   password: String\n# }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conditional-utilities",children:"Conditional Utilities"}),"\n",(0,i.jsx)(n.h3,{id:"ifcondition-then-else",children:"If<Condition, Then, Else>"}),"\n",(0,i.jsx)(n.p,{children:"Type-level if-else:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type If<Condition extends Boolean, Then, Else> =\n  Condition extends true ? Then : Else\n\n# Usage\ntype IsProduction<Env> = If<\n  Env extends "production",\n  { debug: false, logging: :error },\n  { debug: true, logging: :debug }\n>\n\ntype ProdConfig = IsProduction<"production">\n# { debug: false, logging: :error }\n\ntype DevConfig = IsProduction<"development">\n# { debug: true, logging: :debug }\n'})}),"\n",(0,i.jsx)(n.h3,{id:"nullablet",children:"Nullable<T>"}),"\n",(0,i.jsx)(n.p,{children:"Makes a type nullable:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type Nullable<T> = T | nil\n\ntype User = { id: Integer, name: String }\ntype MaybeUser = Nullable<User>\n# User | nil\n\n# Usage in functions\ndef find_user(id: Integer): Nullable<User>\n  # May return nil if not found\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"promisifyt",children:"Promisify<T>"}),"\n",(0,i.jsx)(n.p,{children:"Wraps return types in promises (for async operations):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type Promisify<T> = {\n  [K in keyof T]: T[K] extends Proc<infer Args, infer R>\n    ? Proc<Args, Promise<R>>\n    : T[K]\n}\n\ntype UserService = {\n  find: Proc<Integer, User>,\n  create: Proc<String, String, User>,\n  delete: Proc<Integer, Boolean>\n}\n\ntype AsyncUserService = Promisify<UserService>\n# {\n#   find: Proc<Integer, Promise<User>>,\n#   create: Proc<String, String, Promise<User>>,\n#   delete: Proc<Integer, Promise<Boolean>>\n# }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,i.jsx)(n.h3,{id:"api-response-types",children:"API Response Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type APIResponse<T> = {\n  success: true,\n  data: T\n} | {\n  success: false,\n  error: String,\n  code: Integer\n}\n\n# Usage\ndef fetch_user(id: Integer): APIResponse<User>\n  begin\n    user = find_user(id)\n    { success: true, data: user }\n  rescue => e\n    { success: false, error: e.message, code: 500 }\n  end\nend\n\n# Handle response\nresponse = fetch_user(1)\nif response[:success]\n  user = response[:data]  # Type is User\n  puts user.name\nelse\n  error = response[:error]  # Type is String\n  puts "Error: #{error}"\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"form-state-management",children:"Form State Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"type FormState<T> = {\n  values: T,\n  errors: Partial<Record<keyof T, String>>,\n  touched: Partial<Record<keyof T, Boolean>>,\n  dirty: Boolean,\n  valid: Boolean\n}\n\ntype LoginForm = {\n  username: String,\n  password: String\n}\n\ntype LoginFormState = FormState<LoginForm>\n# {\n#   values: { username: String, password: String },\n#   errors: { username?: String, password?: String },\n#   touched: { username?: Boolean, password?: Boolean },\n#   dirty: Boolean,\n#   valid: Boolean\n# }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"repository-pattern",children:"Repository Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Repository<T> = {\n  find: Proc<Integer, Nullable<T>>,\n  find_all: Proc<Array<T>>,\n  create: Proc<Omit<T, "id">, T>,\n  update: Proc<Integer, Partial<T>, Nullable<T>>,\n  delete: Proc<Integer, Boolean>\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\n# Automatically typed repository\nuser_repository: Repository<User> = create_repository(User)\n\n# Usage with proper types\nnew_user = user_repository.create({ name: "Alice", email: "alice@example.com" })\nupdated = user_repository.update(1, { name: "Alice Smith" })\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-compose-utilities",children:"1. Compose Utilities"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Good: Build complex types from utilities\ntype SafeUserUpdate = Partial<Omit<Required<User>, "id" | "created_at">>\n\n# Less good: Custom mapped type when utilities exist\ntype SafeUserUpdate = {\n  [K in Exclude<keyof User, "id" | "created_at">]?: User[K]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-create-domain-specific-utilities",children:"2. Create Domain-Specific Utilities"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"# Good: Custom utilities for your domain\ntype Entity<T> = T & { id: Integer }\ntype Timestamped<T> = T & { created_at: Time, updated_at: Time }\ntype SoftDeletable<T> = T & { deleted_at: Nullable<Time> }\n\ntype FullEntity<T> = Entity<Timestamped<SoftDeletable<T>>>\n\n# Usage\ntype User = FullEntity<{ name: String, email: String }>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-document-complex-utilities",children:"3. Document Complex Utilities"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"# Good: Clear documentation\n# Creates a type-safe form state for any model\n# Includes validation errors and touched state tracking\ntype FormState<T> = {\n  values: T,\n  errors: Partial<Record<keyof T, String>>,\n  touched: Partial<Record<keyof T, Boolean>>,\n  submitting: Boolean\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you understand utility types, you can:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Apply them in ",(0,i.jsx)(n.a,{href:"/docs/learn/advanced/type-aliases",children:"Type Aliases"})," to create domain-specific types"]}),"\n",(0,i.jsxs)(n.li,{children:["Combine them with ",(0,i.jsx)(n.a,{href:"/docs/learn/generics/generic-functions-classes",children:"Generics"})," for flexible, reusable code"]}),"\n",(0,i.jsxs)(n.li,{children:["Use them with ",(0,i.jsx)(n.a,{href:"/docs/learn/advanced/mapped-types",children:"Mapped Types"})," to create custom transformations"]}),"\n",(0,i.jsxs)(n.li,{children:["Leverage them in ",(0,i.jsx)(n.a,{href:"/docs/learn/advanced/conditional-types",children:"Conditional Types"})," for advanced type logic"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8885:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var r=t(9378);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);