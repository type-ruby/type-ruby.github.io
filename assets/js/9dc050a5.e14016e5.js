"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[1672],{7868:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"learn/generics/generic-functions-classes","title":"Generic Functions & Classes","description":"Creating reusable code with generics","source":"@site/docs/learn/generics/generic-functions-classes.md","sourceDirName":"learn/generics","slug":"/learn/generics/generic-functions-classes","permalink":"/docs/learn/generics/generic-functions-classes","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/generics/generic-functions-classes.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Generic Functions & Classes","description":"Creating reusable code with generics"},"sidebar":"docsSidebar","previous":{"title":"Duck Typing","permalink":"/docs/learn/interfaces/duck-typing"},"next":{"title":"Constraints","permalink":"/docs/learn/generics/constraints"}}');var s=r(2714),t=r(8885);const a={sidebar_position:1,title:"Generic Functions & Classes",description:"Creating reusable code with generics"},l="Generic Functions & Classes",c={},o=[{value:"Why Generics?",id:"why-generics",level:2},{value:"The Problem: Without Generics",id:"the-problem-without-generics",level:3},{value:"The Solution: With Generics",id:"the-solution-with-generics",level:3},{value:"Generic Functions",id:"generic-functions",level:2},{value:"Basic Generic Function",id:"basic-generic-function",level:3},{value:"Multiple Type Parameters",id:"multiple-type-parameters",level:3},{value:"Generic Functions with Arrays",id:"generic-functions-with-arrays",level:3},{value:"Generic Functions with Return Type Transformation",id:"generic-functions-with-return-type-transformation",level:3},{value:"Generic Classes",id:"generic-classes",level:2},{value:"Basic Generic Class",id:"basic-generic-class",level:3},{value:"Generic Class with Type Inference",id:"generic-class-with-type-inference",level:3},{value:"Generic Stack Example",id:"generic-stack-example",level:3},{value:"Generic Class with Multiple Type Parameters",id:"generic-class-with-multiple-type-parameters",level:3},{value:"Generic Collection Class",id:"generic-collection-class",level:3},{value:"Generic Methods in Non-Generic Classes",id:"generic-methods-in-non-generic-classes",level:2},{value:"Nested Generics",id:"nested-generics",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Descriptive Type Parameter Names",id:"1-use-descriptive-type-parameter-names",level:3},{value:"2. Keep Generic Functions Simple",id:"2-keep-generic-functions-simple",level:3},{value:"3. Use Type Inference When Possible",id:"3-use-type-inference-when-possible",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Option/Maybe Type",id:"optionmaybe-type",level:3},{value:"Result Type",id:"result-type",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components},{DocsBadge:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r,{}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"generic-functions--classes",children:"Generic Functions & Classes"})}),"\n",(0,s.jsx)(n.p,{children:'Generics are one of the most powerful features in T-Ruby, allowing you to write code that works with multiple types while maintaining type safety. Think of generics as "type variables"\u2014placeholders that get filled in with concrete types when your code is used.'}),"\n",(0,s.jsx)(n.h2,{id:"why-generics",children:"Why Generics?"}),"\n",(0,s.jsxs)(n.p,{children:["Without generics, you'd need to write the same function multiple times for different types, or lose type safety by using ",(0,s.jsx)(n.code,{children:"Any"}),". Generics let you write code once and reuse it with different types."]}),"\n",(0,s.jsx)(n.h3,{id:"the-problem-without-generics",children:"The Problem: Without Generics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Without generics, you need separate functions for each type\ndef first_string(arr: Array<String>): String | nil\n  arr[0]\nend\n\ndef first_integer(arr: Array<Integer>): Integer | nil\n  arr[0]\nend\n\ndef first_user(arr: Array<User>): User | nil\n  arr[0]\nend\n\n# Or you lose type safety\ndef first(arr: Array<Any>): Any\n  arr[0]  # Return type is Any - no type safety!\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-solution-with-generics",children:"The Solution: With Generics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# One function that works for all types\ndef first<T>(arr: Array<T>): T | nil\n  arr[0]\nend\n\n# TypeScript-style inference works automatically\nnames = ["Alice", "Bob", "Charlie"]\nresult = first(names)  # result is String | nil\n\nnumbers = [1, 2, 3]\nvalue = first(numbers)  # value is Integer | nil\n'})}),"\n",(0,s.jsx)(n.h2,{id:"generic-functions",children:"Generic Functions"}),"\n",(0,s.jsxs)(n.p,{children:["Generic functions use type parameters in angle brackets (",(0,s.jsx)(n.code,{children:"<T>"}),") to represent types that will be determined when the function is called."]}),"\n",(0,s.jsx)(n.h3,{id:"basic-generic-function",children:"Basic Generic Function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# A simple generic function\ndef identity<T>(value: T): T\n  value\nend\n\n# Works with any type\nstr = identity("hello")      # String\nnum = identity(42)           # Integer\narr = identity([1, 2, 3])    # Array<Integer>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-type-parameters",children:"Multiple Type Parameters"}),"\n",(0,s.jsx)(n.p,{children:"You can use multiple type parameters when needed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# A function with two type parameters\ndef pair<K, V>(key: K, value: V): Hash<K, V>\n  { key => value }\nend\n\n# Type inference works for both parameters\nresult = pair("name", "Alice")     # Hash<String, String>\ndata = pair(:id, 123)              # Hash<Symbol, Integer>\nmixed = pair("count", 42)          # Hash<String, Integer>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-functions-with-arrays",children:"Generic Functions with Arrays"}),"\n",(0,s.jsx)(n.p,{children:"A common use case is working with arrays of any type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Get the last element of an array\ndef last<T>(arr: Array<T>): T | nil\n  arr[-1]\nend\n\n# Reverse an array\ndef reverse<T>(arr: Array<T>): Array<T>\n  arr.reverse\nend\n\n# Filter an array with a predicate\ndef filter<T>(arr: Array<T>, &block: Proc<T, Bool>): Array<T>\n  arr.select { |item| block.call(item) }\nend\n\n# Usage\nnumbers = [1, 2, 3, 4, 5]\nevens = filter(numbers) { |n| n.even? }  # Array<Integer>\n\nwords = ["hello", "world", "foo", "bar"]\nlong_words = filter(words) { |w| w.length > 3 }  # Array<String>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-functions-with-return-type-transformation",children:"Generic Functions with Return Type Transformation"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes the return type differs from the input type, but is still generic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Map function that transforms type T to type U\ndef map<T, U>(arr: Array<T>, &block: Proc<T, U>): Array<U>\n  arr.map { |item| block.call(item) }\nend\n\n# Transform integers to strings\nnumbers = [1, 2, 3]\nstrings = map(numbers) { |n| n.to_s }  # Array<String>\n\n# Transform strings to their lengths\nwords = ["hello", "world"]\nlengths = map(words) { |w| w.length }  # Array<Integer>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"generic-classes",children:"Generic Classes"}),"\n",(0,s.jsx)(n.p,{children:"Generic classes allow you to create data structures that work with any type while maintaining type safety throughout the class."}),"\n",(0,s.jsx)(n.h3,{id:"basic-generic-class",children:"Basic Generic Class"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# A simple generic container\nclass Box<T>\n  @value: T\n\n  def initialize(value: T): void\n    @value = value\n  end\n\n  def get: T\n    @value\n  end\n\n  def set(value: T): void\n    @value = value\n  end\nend\n\n# Create boxes with different types\nstring_box = Box<String>.new("hello")\nputs string_box.get  # "hello"\n\nnumber_box = Box<Integer>.new(42)\nputs number_box.get  # 42\n\n# Type safety is enforced\nstring_box.set("world")  # OK\nstring_box.set(123)      # Error: Type mismatch\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-class-with-type-inference",children:"Generic Class with Type Inference"}),"\n",(0,s.jsx)(n.p,{children:"T-Ruby can often infer the type parameter from the constructor:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'class Container<T>\n  @item: T\n\n  def initialize(item: T): void\n    @item = item\n  end\n\n  def item: T\n    @item\n  end\n\n  def update(new_item: T): void\n    @item = new_item\n  end\nend\n\n# Type inference from constructor argument\ncontainer1 = Container.new("hello")  # Container<String>\ncontainer2 = Container.new(42)       # Container<Integer>\n\n# Or explicitly specify the type\ncontainer3 = Container<Bool>.new(true)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-stack-example",children:"Generic Stack Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's a practical example of a generic stack data structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'class Stack<T>\n  @items: Array<T>\n\n  def initialize: void\n    @items = []\n  end\n\n  def push(item: T): void\n    @items.push(item)\n  end\n\n  def pop: T | nil\n    @items.pop\n  end\n\n  def peek: T | nil\n    @items.last\n  end\n\n  def empty?: Bool\n    @items.empty?\n  end\n\n  def size: Integer\n    @items.length\n  end\n\n  def to_a: Array<T>\n    @items.dup\n  end\nend\n\n# Usage with strings\nstring_stack = Stack<String>.new\nstring_stack.push("first")\nstring_stack.push("second")\nstring_stack.push("third")\nputs string_stack.pop  # "third"\nputs string_stack.size # 2\n\n# Usage with integers\nint_stack = Stack<Integer>.new\nint_stack.push(1)\nint_stack.push(2)\nint_stack.push(3)\nputs int_stack.peek  # 3 (doesn\'t remove)\nputs int_stack.size  # 3\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-class-with-multiple-type-parameters",children:"Generic Class with Multiple Type Parameters"}),"\n",(0,s.jsx)(n.p,{children:"Generic classes can have multiple type parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'class Pair<K, V>\n  @key: K\n  @value: V\n\n  def initialize(key: K, value: V): void\n    @key = key\n    @value = value\n  end\n\n  def key: K\n    @key\n  end\n\n  def value: V\n    @value\n  end\n\n  def swap: Pair<V, K>\n    Pair.new(@value, @key)\n  end\n\n  def to_s: String\n    "#{@key} => #{@value}"\n  end\nend\n\n# Create pairs with different type combinations\nname_age = Pair.new("Alice", 30)     # Pair<String, Integer>\nid_name = Pair.new(123, "Bob")       # Pair<Integer, String>\ncoords = Pair.new(10.5, 20.3)        # Pair<Float, Float>\n\n# Swap creates a new pair with types reversed\nswapped = name_age.swap              # Pair<Integer, String>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-collection-class",children:"Generic Collection Class"}),"\n",(0,s.jsx)(n.p,{children:"A more complex example showing a custom collection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"class Collection<T>\n  @items: Array<T>\n\n  def initialize(items: Array<T> = []): void\n    @items = items.dup\n  end\n\n  def add(item: T): void\n    @items.push(item)\n  end\n\n  def remove(item: T): Bool\n    if index = @items.index(item)\n      @items.delete_at(index)\n      true\n    else\n      false\n    end\n  end\n\n  def contains?(item: T): Bool\n    @items.include?(item)\n  end\n\n  def first: T | nil\n    @items.first\n  end\n\n  def last: T | nil\n    @items.last\n  end\n\n  def map<U>(&block: Proc<T, U>): Collection<U>\n    Collection<U>.new(@items.map { |item| block.call(item) })\n  end\n\n  def filter(&block: Proc<T, Bool>): Collection<T>\n    Collection.new(@items.select { |item| block.call(item) })\n  end\n\n  def each(&block: Proc<T, void>): void\n    @items.each { |item| block.call(item) }\n  end\n\n  def to_a: Array<T>\n    @items.dup\n  end\n\n  def size: Integer\n    @items.length\n  end\nend\n\n# Usage\nnumbers = Collection<Integer>.new([1, 2, 3, 4, 5])\nnumbers.add(6)\n\n# Map transforms the collection to a new type\nstrings = numbers.map { |n| n.to_s }  # Collection<String>\n\n# Filter maintains the same type\nevens = numbers.filter { |n| n.even? }  # Collection<Integer>\n\n# Iterate over items\nnumbers.each { |n| puts n }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"generic-methods-in-non-generic-classes",children:"Generic Methods in Non-Generic Classes"}),"\n",(0,s.jsx)(n.p,{children:"You can have generic methods in classes that aren't themselves generic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'class Utils\n  # Generic method in a non-generic class\n  def self.wrap<T>(value: T): Array<T>\n    [value]\n  end\n\n  def self.duplicate<T>(value: T, times: Integer): Array<T>\n    Array.new(times, value)\n  end\n\n  def self.zip<T, U>(arr1: Array<T>, arr2: Array<U>): Array<Pair<T, U>>\n    arr1.zip(arr2).map { |t, u| Pair.new(t, u) }\n  end\nend\n\n# Usage\nwrapped = Utils.wrap(42)                    # Array<Integer>\nduplicates = Utils.duplicate("hello", 3)    # Array<String>\nzipped = Utils.zip([1, 2], ["a", "b"])      # Array<Pair<Integer, String>>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"nested-generics",children:"Nested Generics"}),"\n",(0,s.jsx)(n.p,{children:"Generics can be nested to create complex type structures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# A cache that stores arrays of values for each key\nclass Cache<K, V>\n  @store: Hash<K, Array<V>>\n\n  def initialize: void\n    @store = {}\n  end\n\n  def add(key: K, value: V): void\n    @store[key] ||= []\n    @store[key].push(value)\n  end\n\n  def get(key: K): Array<V>\n    @store[key] || []\n  end\n\n  def has_key?(key: K): Bool\n    @store.key?(key)\n  end\nend\n\n# Usage\nuser_tags = Cache<Integer, String>.new  # Cache<Integer, String>\nuser_tags.add(1, "ruby")\nuser_tags.add(1, "programming")\nuser_tags.add(2, "design")\n\ntags = user_tags.get(1)  # Array<String> = ["ruby", "programming"]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-descriptive-type-parameter-names",children:"1. Use Descriptive Type Parameter Names"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Good: Descriptive names for domain-specific types\nclass Repository<Entity, Id>\n  def find(id: Id): Entity | nil\n    # ...\n  end\nend\n\n# OK: Standard conventions for generic collections\nclass List<T>\n  # ...\nend\n\n# Avoid: Non-descriptive single letters for complex scenarios\nclass Processor<A, B, C, D>  # Too cryptic\n  # ...\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-keep-generic-functions-simple",children:"2. Keep Generic Functions Simple"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Good: Simple, focused generic function\ndef head<T>(arr: Array<T>): T | nil\n  arr.first\nend\n\n# Less good: Too many responsibilities\ndef process<T>(arr: Array<T>, flag: Bool, count: Integer): Array<T> | Hash<Integer, T>\n  # Too complex, hard to understand the generic behavior\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-use-type-inference-when-possible",children:"3. Use Type Inference When Possible"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Let T-Ruby infer types from arguments\ncontainer = Container.new("hello")  # Container<String> inferred\n\n# Only specify types when necessary\ncontainer = Container<String | Integer>.new("hello")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"optionmaybe-type",children:"Option/Maybe Type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'class Option<T>\n  @value: T | nil\n\n  def initialize(value: T | nil): void\n    @value = value\n  end\n\n  def is_some?: Bool\n    !@value.nil?\n  end\n\n  def is_none?: Bool\n    @value.nil?\n  end\n\n  def unwrap: T\n    raise "Called unwrap on None" if @value.nil?\n    @value\n  end\n\n  def unwrap_or(default: T): T\n    @value || default\n  end\n\n  def map<U>(&block: Proc<T, U>): Option<U>\n    if @value\n      Option.new(block.call(@value))\n    else\n      Option<U>.new(nil)\n    end\n  end\nend\n\n# Usage\nsome = Option.new(42)\nnone = Option<Integer>.new(nil)\n\nputs some.unwrap_or(0)  # 42\nputs none.unwrap_or(0)  # 0\n\nresult = some.map { |n| n * 2 }  # Option<Integer> with value 84\n'})}),"\n",(0,s.jsx)(n.h3,{id:"result-type",children:"Result Type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'class Result<T, E>\n  @value: T | nil\n  @error: E | nil\n\n  def self.ok(value: T): Result<T, E>\n    result = Result<T, E>.new\n    result.instance_variable_set(:@value, value)\n    result\n  end\n\n  def self.err(error: E): Result<T, E>\n    result = Result<T, E>.new\n    result.instance_variable_set(:@error, error)\n    result\n  end\n\n  def ok?: Bool\n    !@value.nil?\n  end\n\n  def err?: Bool\n    !@error.nil?\n  end\n\n  def unwrap: T\n    raise "Called unwrap on Err: #{@error}" if @error\n    @value\n  end\n\n  def unwrap_err: E\n    raise "Called unwrap_err on Ok" if @value\n    @error\n  end\nend\n\n# Usage\ndef divide(a: Integer, b: Integer): Result<Float, String>\n  if b == 0\n    Result.err("Division by zero")\n  else\n    Result.ok(a.to_f / b)\n  end\nend\n\nresult = divide(10, 2)\nputs result.unwrap if result.ok?  # 5.0\n\nresult = divide(10, 0)\nputs result.unwrap_err if result.err?  # "Division by zero"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Now that you understand generic functions and classes, you can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Learn about ",(0,s.jsx)(n.a,{href:"/docs/learn/generics/constraints",children:"Constraints"})," to limit which types can be used with generics"]}),"\n",(0,s.jsxs)(n.li,{children:["Explore ",(0,s.jsx)(n.a,{href:"/docs/learn/generics/built-in-generics",children:"Built-in Generics"})," like ",(0,s.jsx)(n.code,{children:"Array<T>"})," and ",(0,s.jsx)(n.code,{children:"Hash<K, V>"})]}),"\n",(0,s.jsxs)(n.li,{children:["See how generics work with ",(0,s.jsx)(n.a,{href:"/docs/learn/interfaces/defining-interfaces",children:"Interfaces"})]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8885:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(9378);const s={},t=i.createContext(s);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);