"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[6903],{6145(e,n,t){t.d(n,{R:()=>a,x:()=>d});var i=t(7140);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},9607(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"learn/generics/constraints","title":"Constraints","description":"Constraining generic type parameters","source":"@site/docs/learn/generics/constraints.md","sourceDirName":"learn/generics","slug":"/learn/generics/constraints","permalink":"/docs/learn/generics/constraints","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/generics/constraints.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Constraints","description":"Constraining generic type parameters"},"sidebar":"docsSidebar","previous":{"title":"Generic Functions & Classes","permalink":"/docs/learn/generics/generic-functions-classes"},"next":{"title":"Built-in Generics","permalink":"/docs/learn/generics/built-in-generics"}}');var s=t(5656),r=t(6145);const a={sidebar_position:2,title:"Constraints",description:"Constraining generic type parameters"},d="Constraints",o={},l=[{value:"Why Constraints?",id:"why-constraints",level:2},{value:"The Problem: Unconstrained Generics",id:"the-problem-unconstrained-generics",level:3},{value:"The Solution: With Constraints",id:"the-solution-with-constraints",level:3},{value:"Basic Constraint Syntax",id:"basic-constraint-syntax",level:2},{value:"Interface Constraints",id:"interface-constraints",level:2},{value:"Defining an Interface for Constraints",id:"defining-an-interface-for-constraints",level:3},{value:"Common Interface Constraints",id:"common-interface-constraints",level:3},{value:"Class Constraints",id:"class-constraints",level:2},{value:"Working with Class Hierarchies",id:"working-with-class-hierarchies",level:3},{value:"Multiple Constraints",id:"multiple-constraints",level:2},{value:"Union Type Constraints",id:"union-type-constraints",level:2},{value:"Practical Union Constraint Example",id:"practical-union-constraint-example",level:3},{value:"Constrained Generic Classes",id:"constrained-generic-classes",level:2},{value:"Generic Class with Multiple Constrained Parameters",id:"generic-class-with-multiple-constrained-parameters",level:3},{value:"Constraints with Default Types",id:"constraints-with-default-types",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Sortable Collection",id:"sortable-collection",level:3},{value:"Repository Pattern with Constraints",id:"repository-pattern-with-constraints",level:3},{value:"Builder Pattern with Constraints",id:"builder-pattern-with-constraints",level:3},{value:"Type Inference with Constraints",id:"type-inference-with-constraints",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use the Least Restrictive Constraint",id:"1-use-the-least-restrictive-constraint",level:3},{value:"2. Create Small, Focused Interfaces for Constraints",id:"2-create-small-focused-interfaces-for-constraints",level:3},{value:"3. Document Constraint Requirements",id:"3-document-constraint-requirements",level:3},{value:"Common Constraint Patterns",id:"common-constraint-patterns",level:2},{value:"Identity Constraint",id:"identity-constraint",level:3},{value:"Validation Constraint",id:"validation-constraint",level:3},{value:"Conversion Constraint",id:"conversion-constraint",level:3},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{DocsBadge:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t,{}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"constraints",children:"Constraints"})}),"\n",(0,s.jsx)(n.p,{children:"While generics allow you to write code that works with any type, sometimes you need to ensure that the types used have certain properties or capabilities. Constraints let you restrict generic type parameters to types that meet specific requirements, giving you access to their methods and properties while maintaining type safety."}),"\n",(0,s.jsx)(n.h2,{id:"why-constraints",children:"Why Constraints?"}),"\n",(0,s.jsx)(n.p,{children:"Without constraints, generic code can only perform operations that work on all types. Constraints allow you to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Access specific methods or properties on generic types"}),"\n",(0,s.jsx)(n.li,{children:"Ensure types implement certain interfaces"}),"\n",(0,s.jsx)(n.li,{children:"Require types to extend specific classes"}),"\n",(0,s.jsx)(n.li,{children:"Combine multiple requirements"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-problem-unconstrained-generics",children:"The Problem: Unconstrained Generics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Without constraints, you can't use type-specific methods\ndef print_length<T>(value: T): void\n  puts value.length  # Error: T might not have a length method\nend\n\n# Without constraints, you can't rely on specific behavior\ndef compare<T>(a: T, b: T): Integer\n  a <=> b  # Error: T might not be comparable\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-solution-with-constraints",children:"The Solution: With Constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Constrain T to types that have a length method\ndef print_length<T: Lengthable>(value: T): void\n  puts value.length  # OK: T is guaranteed to have length\nend\n\n# Constrain T to comparable types\ndef compare<T: Comparable>(a: T, b: T): Integer\n  a <=> b  # OK: T is guaranteed to support <=>\nend\n"})}),"\n",(0,s.jsx)(n.h2,{id:"basic-constraint-syntax",children:"Basic Constraint Syntax"}),"\n",(0,s.jsxs)(n.p,{children:["Constraints are specified using a colon (",(0,s.jsx)(n.code,{children:":"}),") after the type parameter:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Single constraint\ndef process<T: Interface>(value: T): void\n  # T must implement Interface\nend\n\n# Multiple type parameters with constraints\ndef merge<K: Hashable, V: Serializable>(key: K, value: V): Hash<K, V>\n  # K must be Hashable, V must be Serializable\nend\n"})}),"\n",(0,s.jsx)(n.h2,{id:"interface-constraints",children:"Interface Constraints"}),"\n",(0,s.jsx)(n.p,{children:"The most common constraint is requiring a type to implement an interface."}),"\n",(0,s.jsx)(n.h3,{id:"defining-an-interface-for-constraints",children:"Defining an Interface for Constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Define an interface\ninterface Printable\n  def to_s: String\nend\n\n# Constrain T to types that implement Printable\ndef print_items<T: Printable>(items: T[]): void\n  items.each do |item|\n    puts item.to_s  # Safe: T is guaranteed to have to_s\n  end\nend\n\n# Usage\nclass User\n  implements Printable\n\n  @name: String\n\n  def initialize(name: String): void\n    @name = name\n  end\n\n  def to_s: String\n    "User: #{@name}"\n  end\nend\n\nusers = [User.new("Alice"), User.new("Bob")]\nprint_items(users)  # OK: User implements Printable\n'})}),"\n",(0,s.jsx)(n.h3,{id:"common-interface-constraints",children:"Common Interface Constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Comparable interface\ninterface Comparable\n  def <=>(other: self): Integer\nend\n\ndef max<T: Comparable>(a: T, b: T): T\n  a <=> b > 0 ? a : b\nend\n\n# Numeric interface\ninterface Numeric\n  def +(other: self): self\n  def -(other: self): self\n  def *(other: self): self\n  def /(other: self): self\nend\n\ndef average<T: Numeric>(numbers: T[]): T\n  sum = numbers.reduce { |acc, n| acc + n }\n  sum / numbers.length\nend\n\n# Enumerable interface\ninterface Enumerable<T>\n  def each(&block: Proc<T, void>): void\n  def map<U>(&block: Proc<T, U>): U[]\nend\n\ndef count_items<T, C: Enumerable<T>>(collection: C): Integer\n  counter = 0\n  collection.each { |_| counter += 1 }\n  counter\nend\n"})}),"\n",(0,s.jsx)(n.h2,{id:"class-constraints",children:"Class Constraints"}),"\n",(0,s.jsx)(n.p,{children:"You can constrain a type parameter to be a specific class or a subclass of it."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Constrain to a specific class\nclass Animal\n  @name: String\n\n  def initialize(name: String): void\n    @name = name\n  end\n\n  def speak: String\n    "Some sound"\n  end\nend\n\nclass Dog < Animal\n  def speak: String\n    "Woof!"\n  end\nend\n\nclass Cat < Animal\n  def speak: String\n    "Meow!"\n  end\nend\n\n# T must be Animal or a subclass of Animal\ndef make_speak<T: Animal>(animal: T): void\n  puts animal.speak  # Safe: Animal has speak method\nend\n\n# Usage\ndog = Dog.new("Buddy")\ncat = Cat.new("Whiskers")\n\nmake_speak(dog)  # OK: Dog is an Animal\nmake_speak(cat)  # OK: Cat is an Animal\nmake_speak("string")  # Error: String is not an Animal\n'})}),"\n",(0,s.jsx)(n.h3,{id:"working-with-class-hierarchies",children:"Working with Class Hierarchies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'class Vehicle\n  @brand: String\n\n  def initialize(brand: String): void\n    @brand = brand\n  end\n\n  def brand: String\n    @brand\n  end\nend\n\nclass Car < Vehicle\n  @doors: Integer\n\n  def initialize(brand: String, doors: Integer): void\n    super(brand)\n    @doors = doors\n  end\n\n  def doors: Integer\n    @doors\n  end\nend\n\n# Repository that works with any Vehicle subclass\nclass Repository<T: Vehicle>\n  @items: T[]\n\n  def initialize: void\n    @items = []\n  end\n\n  def add(item: T): void\n    @items.push(item)\n  end\n\n  def find_by_brand(brand: String): T | nil\n    @items.find { |item| item.brand == brand }\n  end\n\n  def all: T[]\n    @items.dup\n  end\nend\n\n# Usage\ncar_repo = Repository<Car>.new\ncar_repo.add(Car.new("Toyota", 4))\ncar_repo.add(Car.new("Honda", 2))\n\nfound = car_repo.find_by_brand("Toyota")  # Car | nil\n'})}),"\n",(0,s.jsx)(n.h2,{id:"multiple-constraints",children:"Multiple Constraints"}),"\n",(0,s.jsx)(n.admonition,{title:"Coming Soon",type:"caution",children:(0,s.jsx)(n.p,{children:"This feature is planned for a future release."})}),"\n",(0,s.jsxs)(n.p,{children:["In the future, T-Ruby will support multiple constraints using the ",(0,s.jsx)(n.code,{children:"&"})," operator:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Type must implement both interfaces\ndef process<T: Printable & Comparable>(value: T): void\n  puts value.to_s\n  # Can use methods from both interfaces\nend\n\n# Type must extend class and implement interface\ndef save<T: Entity & Serializable>(entity: T): void\n  # Can use methods from Entity class and Serializable interface\nend\n"})}),"\n",(0,s.jsx)(n.h2,{id:"union-type-constraints",children:"Union Type Constraints"}),"\n",(0,s.jsx)(n.p,{children:"You can constrain a type to be one of several specific types using union types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# T must be either String or Integer\ndef format<T: String | Integer>(value: T): String\n  case value\n  when String\n    "String: #{value}"\n  when Integer\n    "Number: #{value}"\n  end\nend\n\nformat("hello")  # OK\nformat(42)       # OK\nformat(3.14)     # Error: Float is not String | Integer\n'})}),"\n",(0,s.jsx)(n.h3,{id:"practical-union-constraint-example",children:"Practical Union Constraint Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# A flexible ID type\ntype StringOrInt = String | Integer\n\ndef find_user<T: StringOrInt>(id: T): User | nil\n  case id\n  when String\n    User.find_by_username(id)\n  when Integer\n    User.find_by_id(id)\n  end\nend\n\n# Both work\nuser1 = find_user(123)        # Find by integer ID\nuser2 = find_user("alice")    # Find by username string\n'})}),"\n",(0,s.jsx)(n.h2,{id:"constrained-generic-classes",children:"Constrained Generic Classes"}),"\n",(0,s.jsx)(n.p,{children:"Generic classes can have constrained type parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Queue that only works with comparable items\nclass PriorityQueue<T: Comparable>\n  @items: T[]\n\n  def initialize: void\n    @items = []\n  end\n\n  def enqueue(item: T): void\n    @items.push(item)\n    @items.sort! { |a, b| b <=> a }  # Highest priority first\n  end\n\n  def dequeue: T | nil\n    @items.shift\n  end\n\n  def peek: T | nil\n    @items.first\n  end\nend\n\n# Works with any comparable type\nclass Task\n  implements Comparable\n\n  @priority: Integer\n  @name: String\n\n  def initialize(name: String, priority: Integer): void\n    @name = name\n    @priority = priority\n  end\n\n  def <=>(other: Task): Integer\n    @priority <=> other.priority\n  end\nend\n\nqueue = PriorityQueue<Task>.new\nqueue.enqueue(Task.new("Low priority", 1))\nqueue.enqueue(Task.new("High priority", 10))\nqueue.enqueue(Task.new("Medium priority", 5))\n\n# Dequeues in priority order: High -> Medium -> Low\n'})}),"\n",(0,s.jsx)(n.h3,{id:"generic-class-with-multiple-constrained-parameters",children:"Generic Class with Multiple Constrained Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Map that requires hashable keys and serializable values\ninterface Hashable\n  def hash: Integer\n  def ==(other: self): Boolean\nend\n\ninterface Serializable\n  def to_json: String\n  def self.from_json(json: String): self\nend\n\nclass SerializableMap<K: Hashable, V: Serializable>\n  @data: Hash<K, V>\n\n  def initialize: void\n    @data = {}\n  end\n\n  def set(key: K, value: V): void\n    @data[key] = value\n  end\n\n  def get(key: K): V | nil\n    @data[key]\n  end\n\n  def to_json: String\n    pairs = @data.map { |k, v| "#{k.hash}: #{v.to_json}" }\n    "{ #{pairs.join(\', \')} }"\n  end\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"constraints-with-default-types",children:"Constraints with Default Types"}),"\n",(0,s.jsx)(n.p,{children:"You can provide default types for generic parameters with constraints:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Default to String if not specified\nclass Cache<K: Hashable = String, V = Any>\n  @data: Hash<K, V>\n\n  def initialize: void\n    @data = {}\n  end\n\n  def set(key: K, value: V): void\n    @data[key] = value\n  end\n\n  def get(key: K): V | nil\n    @data[key]\n  end\nend\n\n# Uses default: Cache<String, Any>\ncache1 = Cache.new\ncache1.set("key", "value")\n\n# Explicit types\ncache2 = Cache<Integer, User>.new\ncache2.set(1, User.new("Alice"))\n'})}),"\n",(0,s.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,s.jsx)(n.h3,{id:"sortable-collection",children:"Sortable Collection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"interface Comparable\n  def <=>(other: self): Integer\nend\n\nclass SortedList<T: Comparable>\n  @items: T[]\n\n  def initialize: void\n    @items = []\n  end\n\n  def add(item: T): void\n    @items.push(item)\n    @items.sort! { |a, b| a <=> b }\n  end\n\n  def remove(item: T): Boolean\n    if index = @items.index(item)\n      @items.delete_at(index)\n      true\n    else\n      false\n    end\n  end\n\n  def first: T | nil\n    @items.first\n  end\n\n  def last: T | nil\n    @items.last\n  end\n\n  def to_a: T[]\n    @items.dup\n  end\nend\n\n# Usage with integers (naturally comparable)\nnumbers = SortedList<Integer>.new\nnumbers.add(5)\nnumbers.add(2)\nnumbers.add(8)\nnumbers.add(1)\nputs numbers.to_a  # [1, 2, 5, 8] - always sorted\n"})}),"\n",(0,s.jsx)(n.h3,{id:"repository-pattern-with-constraints",children:"Repository Pattern with Constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'# Base entity class\nclass Entity\n  @id: Integer\n\n  def initialize(id: Integer): void\n    @id = id\n  end\n\n  def id: Integer\n    @id\n  end\nend\n\n# Generic repository constrained to Entity subclasses\nclass Repository<T: Entity>\n  @items: Hash<Integer, T>\n\n  def initialize: void\n    @items = {}\n  end\n\n  def save(entity: T): void\n    @items[entity.id] = entity\n  end\n\n  def find(id: Integer): T | nil\n    @items[id]\n  end\n\n  def all: T[]\n    @items.values\n  end\n\n  def delete(id: Integer): Boolean\n    !!@items.delete(id)\n  end\nend\n\n# Domain models\nclass User < Entity\n  @name: String\n  @email: String\n\n  def initialize(id: Integer, name: String, email: String): void\n    super(id)\n    @name = name\n    @email = email\n  end\n\n  def name: String\n    @name\n  end\nend\n\nclass Product < Entity\n  @title: String\n  @price: Float\n\n  def initialize(id: Integer, title: String, price: Float): void\n    super(id)\n    @title = title\n    @price = price\n  end\n\n  def title: String\n    @title\n  end\nend\n\n# Usage\nuser_repo = Repository<User>.new\nuser_repo.save(User.new(1, "Alice", "alice@example.com"))\nuser_repo.save(User.new(2, "Bob", "bob@example.com"))\n\nproduct_repo = Repository<Product>.new\nproduct_repo.save(Product.new(1, "Laptop", 999.99))\n\nfound_user = user_repo.find(1)  # User | nil\nall_products = product_repo.all  # Array<Product>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"builder-pattern-with-constraints",children:"Builder Pattern with Constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'interface Buildable\n  def build: self\nend\n\nclass Builder<T: Buildable>\n  @instance: T\n\n  def initialize(instance: T): void\n    @instance = instance\n  end\n\n  def build: T\n    @instance.build\n  end\nend\n\nclass QueryBuilder\n  implements Buildable\n\n  @table: String\n  @conditions: String[]\n\n  def initialize(table: String): void\n    @table = table\n    @conditions = []\n  end\n\n  def where(condition: String): self\n    @conditions.push(condition)\n    self\n  end\n\n  def build: self\n    # In real implementation, would create SQL query\n    self\n  end\n\n  def to_sql: String\n    sql = "SELECT * FROM #{@table}"\n    unless @conditions.empty?\n      sql += " WHERE #{@conditions.join(\' AND \')}"\n    end\n    sql\n  end\nend\n\n# Usage\nquery = Builder.new(QueryBuilder.new("users"))\n  .build\n  .where("age > 18")\n  .where("active = true")\n\nputs query.to_sql\n# SELECT * FROM users WHERE age > 18 AND active = true\n'})}),"\n",(0,s.jsx)(n.h2,{id:"type-inference-with-constraints",children:"Type Inference with Constraints"}),"\n",(0,s.jsx)(n.p,{children:"T-Ruby can infer constrained types from usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:'def sort_and_first<T: Comparable>(items: T[]): T | nil\n  sorted = items.sort { |a, b| a <=> b }\n  sorted.first\nend\n\n# Type inferred as Integer (which is Comparable)\nnumbers = [3, 1, 4, 1, 5]\nfirst = sort_and_first(numbers)  # Integer | nil\n\n# Type inferred as String (which is Comparable)\nwords = ["zebra", "apple", "mango"]\nfirst_word = sort_and_first(words)  # String | nil\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-use-the-least-restrictive-constraint",children:"1. Use the Least Restrictive Constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Good: Only requires what's needed\ndef print_all<T: Printable>(items: T[]): void\n  items.each { |item| puts item.to_s }\nend\n\n# Less good: Too restrictive\ndef print_all<T: User>(items: T[]): void\n  items.each { |item| puts item.to_s }\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-create-small-focused-interfaces-for-constraints",children:"2. Create Small, Focused Interfaces for Constraints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Good: Small, focused interfaces\ninterface Identifiable\n  def id: Integer\nend\n\ninterface Timestamped\n  def created_at: Time\n  def updated_at: Time\nend\n\ndef find_by_id<T: Identifiable>(items: T[], id: Integer): T | nil\n  items.find { |item| item.id == id }\nend\n\n# Less good: Large, monolithic interface\ninterface Model\n  def id: Integer\n  def save: void\n  def delete: void\n  def created_at: Time\n  def updated_at: Time\n  # Too many methods - hard to implement\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-document-constraint-requirements",children:"3. Document Constraint Requirements"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"# Good: Clear documentation\n# Processes items that can be converted to strings\n# @param items [T[]] Array of printable items\n# @return [void]\ndef log_items<T: Printable>(items: T[]): void\n  items.each { |item| puts item.to_s }\nend\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-constraint-patterns",children:"Common Constraint Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"identity-constraint",children:"Identity Constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"interface Identifiable\n  def id: Integer | String\nend\n\ndef find_duplicates<T: Identifiable>(items: T[]): T[]\n  seen = {}\n  duplicates = []\n\n  items.each do |item|\n    if seen[item.id]\n      duplicates.push(item)\n    else\n      seen[item.id] = true\n    end\n  end\n\n  duplicates\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"validation-constraint",children:"Validation Constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"interface Validatable\n  def valid?: Boolean\n  def errors: String[]\nend\n\ndef save_if_valid<T: Validatable>(item: T): Boolean\n  if item.valid?\n    # Save logic here\n    true\n  else\n    puts \"Validation errors: #{item.errors.join(', ')}\"\n    false\n  end\nend\n"})}),"\n",(0,s.jsx)(n.h3,{id:"conversion-constraint",children:"Conversion Constraint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-trb",children:"interface Convertible<T>\n  def convert: T\nend\n\ndef batch_convert<S: Convertible<T>, T>(items: S[]): T[]\n  items.map { |item| item.convert }\nend\n"})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Now that you understand constraints, explore:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/learn/generics/built-in-generics",children:"Built-in Generics"})," to see how constraints work with ",(0,s.jsx)(n.code,{children:"T[]"}),", ",(0,s.jsx)(n.code,{children:"Hash<K, V>"}),", and other built-in types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/learn/interfaces/defining-interfaces",children:"Interfaces"})," to create interfaces for use as constraints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/learn/advanced/type-aliases",children:"Advanced Types"})," for more complex type patterns"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);