"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[4155],{4710:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});var r=i(6863),t=i(2714),s=i(8885);const l={slug:"typescript-style-type-inference",title:"Building TypeScript-Style Type Inference for T-Ruby",authors:["yhk1038"],tags:["technical","type-inference","compiler"]},d=void 0,c={authorsImageUrls:[void 0]},a=[{value:"The Problem",id:"the-problem",level:2},{value:"Inspiration: TypeScript&#39;s Approach",id:"inspiration-typescripts-approach",level:2},{value:"How TypeScript Does It",id:"how-typescript-does-it",level:3},{value:"Our Simplified Approach",id:"our-simplified-approach",level:3},{value:"Architecture",id:"architecture",level:2},{value:"The Core Components",id:"the-core-components",level:3},{value:"1. BodyParser - Parsing Method Bodies",id:"1-bodyparser---parsing-method-bodies",level:4},{value:"2. TypeEnv - Scope Chain Management",id:"2-typeenv---scope-chain-management",level:4},{value:"3. ASTTypeInferrer - The Type Inference Engine",id:"3-asttypeinferrer---the-type-inference-engine",level:4},{value:"Handling Ruby&#39;s Implicit Returns",id:"handling-rubys-implicit-returns",level:3},{value:"Special Case: <code>initialize</code> Method",id:"special-case-initialize-method",level:3},{value:"Built-in Method Type Knowledge",id:"built-in-method-type-knowledge",level:3},{value:"Results",id:"results",level:2},{value:"Testing",id:"testing",level:2},{value:"Challenges &amp; Solutions",id:"challenges--solutions",level:2},{value:"Future Work",id:"future-work",level:2},{value:"Conclusion",id:"conclusion",level:2}];function o(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"How we implemented TypeScript-inspired static type inference for T-Ruby, enabling automatic type detection without explicit annotations."}),"\n",(0,t.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,t.jsx)(n.p,{children:"When writing T-Ruby code, developers had to explicitly annotate every return type:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'def greet(name: String): String\n  "Hello, #{name}!"\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Without the ",(0,t.jsx)(n.code,{children:": String"})," return type, the generated RBS would show ",(0,t.jsx)(n.code,{children:"untyped"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rbs",children:"def greet: (name: String) -> untyped\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This was frustrating. The return type is obviously ",(0,t.jsx)(n.code,{children:"String"})," - why can't T-Ruby figure it out?"]}),"\n",(0,t.jsx)(n.h2,{id:"inspiration-typescripts-approach",children:"Inspiration: TypeScript's Approach"}),"\n",(0,t.jsx)(n.p,{children:"TypeScript handles this elegantly. You can write:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function greet(name: string) {\n  return `Hello, ${name}!`;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And TypeScript infers the return type as ",(0,t.jsx)(n.code,{children:"string"}),". We wanted the same experience for T-Ruby."]}),"\n",(0,t.jsx)(n.h3,{id:"how-typescript-does-it",children:"How TypeScript Does It"}),"\n",(0,t.jsx)(n.p,{children:"TypeScript's type inference is built on two key components:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Binder"}),": Builds a Control Flow Graph (CFG) during parsing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Checker"}),": Lazily evaluates types when needed, using flow analysis"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The magic happens in ",(0,t.jsx)(n.code,{children:"getFlowTypeOfReference"})," - a 1200+ line function that determines a symbol's type at any point in the code by walking backwards through flow nodes."]}),"\n",(0,t.jsx)(n.h3,{id:"our-simplified-approach",children:"Our Simplified Approach"}),"\n",(0,t.jsx)(n.p,{children:"Ruby's control flow is simpler than JavaScript's. We don't need the full complexity of TypeScript's flow graph. Instead, we implemented:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Linear data flow analysis"})," - Ruby's straightforward execution model"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Separation of concerns"})," - IR Builder (Binder role) + ASTTypeInferrer (Checker role)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lazy evaluation"})," - Types computed only when generating RBS"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[Binder Stage - IR Builder]\nSource (.trb) \u2192 Parser \u2192 IR Tree (with method bodies)\n\n[Checker Stage - Type Inferrer]\nIR Node traversal \u2192 Type determination \u2192 Caching\n\n[Output Stage]\nInferred types \u2192 RBS generation\n"})}),"\n",(0,t.jsx)(n.h3,{id:"the-core-components",children:"The Core Components"}),"\n",(0,t.jsx)(n.h4,{id:"1-bodyparser---parsing-method-bodies",children:"1. BodyParser - Parsing Method Bodies"}),"\n",(0,t.jsxs)(n.p,{children:["The first challenge was that our parser didn't analyze method bodies - it only extracted signatures. We built ",(0,t.jsx)(n.code,{children:"BodyParser"})," to convert T-Ruby method bodies into IR nodes:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class BodyParser\n  def parse(lines, start_line, end_line)\n    statements = []\n    # Parse each line into IR nodes\n    # Handle: literals, variables, operators, method calls, conditionals\n    IR::Block.new(statements: statements)\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"Supported constructs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Literals: ",(0,t.jsx)(n.code,{children:'"hello"'}),", ",(0,t.jsx)(n.code,{children:"42"}),", ",(0,t.jsx)(n.code,{children:"true"}),", ",(0,t.jsx)(n.code,{children:":symbol"})]}),"\n",(0,t.jsxs)(n.li,{children:["Variables: ",(0,t.jsx)(n.code,{children:"name"}),", ",(0,t.jsx)(n.code,{children:"@instance_var"}),", ",(0,t.jsx)(n.code,{children:"@@class_var"})]}),"\n",(0,t.jsxs)(n.li,{children:["Operators: ",(0,t.jsx)(n.code,{children:"a + b"}),", ",(0,t.jsx)(n.code,{children:"x == y"}),", ",(0,t.jsx)(n.code,{children:"!flag"})]}),"\n",(0,t.jsxs)(n.li,{children:["Method calls: ",(0,t.jsx)(n.code,{children:"str.upcase"}),", ",(0,t.jsx)(n.code,{children:"array.map { |x| x * 2 }"})]}),"\n",(0,t.jsxs)(n.li,{children:["Conditionals: ",(0,t.jsx)(n.code,{children:"if"}),"/",(0,t.jsx)(n.code,{children:"unless"}),"/",(0,t.jsx)(n.code,{children:"elsif"}),"/",(0,t.jsx)(n.code,{children:"else"})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-typeenv---scope-chain-management",children:"2. TypeEnv - Scope Chain Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class TypeEnv\n  def initialize(parent = nil)\n    @parent = parent\n    @bindings = {}       # Local variables\n    @instance_vars = {}  # Instance variables\n  end\n\n  def lookup(name)\n    @bindings[name] || @instance_vars[name] || @parent&.lookup(name)\n  end\n\n  def child_scope\n    TypeEnv.new(self)\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"This enables proper scoping - a method's local variables don't leak into other methods, but instance variables are shared across the class."}),"\n",(0,t.jsx)(n.h4,{id:"3-asttypeinferrer---the-type-inference-engine",children:"3. ASTTypeInferrer - The Type Inference Engine"}),"\n",(0,t.jsx)(n.p,{children:"The heart of the system:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class ASTTypeInferrer\n  LITERAL_TYPE_MAP = {\n    string: "String",\n    integer: "Integer",\n    float: "Float",\n    boolean: "bool",\n    symbol: "Symbol",\n    nil: "nil"\n  }.freeze\n\n  def infer_expression(node, env)\n    # Check cache first (lazy evaluation)\n    return @type_cache[node.object_id] if @type_cache[node.object_id]\n\n    type = case node\n    when IR::Literal\n      LITERAL_TYPE_MAP[node.literal_type]\n    when IR::VariableRef\n      env.lookup(node.name)\n    when IR::BinaryOp\n      infer_binary_op(node, env)\n    when IR::MethodCall\n      infer_method_call(node, env)\n    # ... more cases\n    end\n\n    @type_cache[node.object_id] = type\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"handling-rubys-implicit-returns",children:"Handling Ruby's Implicit Returns"}),"\n",(0,t.jsx)(n.p,{children:"Ruby's last expression is the implicit return value. This is crucial for type inference:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'def status\n  if active?\n    "running"\n  else\n    "stopped"\n  end\nend\n# Implicit return: String (from both branches)\n'})}),"\n",(0,t.jsx)(n.p,{children:"We handle this by:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Collecting all explicit ",(0,t.jsx)(n.code,{children:"return"})," types"]}),"\n",(0,t.jsx)(n.li,{children:"Finding the last expression (implicit return)"}),"\n",(0,t.jsx)(n.li,{children:"Unifying all return types"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"def infer_method_return_type(method_node, env)\n  # Collect explicit returns\n  return_types, terminated = collect_return_types(method_node.body, env)\n\n  # Add implicit return (unless method always returns explicitly)\n  unless terminated\n    implicit_return = infer_implicit_return(method_node.body, env)\n    return_types << implicit_return if implicit_return\n  end\n\n  unify_types(return_types)\nend\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"special-case-initialize-method",children:["Special Case: ",(0,t.jsx)(n.code,{children:"initialize"})," Method"]}),"\n",(0,t.jsxs)(n.p,{children:["Ruby's ",(0,t.jsx)(n.code,{children:"initialize"})," is a constructor. Its return value is ignored - ",(0,t.jsx)(n.code,{children:"Class.new"})," returns the instance. Following RBS conventions, we always infer ",(0,t.jsx)(n.code,{children:"void"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class User\n  def initialize(name: String)\n    @name = name\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"Generates:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rbs",children:"class User\n  def initialize: (name: String) -> void\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"built-in-method-type-knowledge",children:"Built-in Method Type Knowledge"}),"\n",(0,t.jsx)(n.p,{children:"We maintain a table of common Ruby method return types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'BUILTIN_METHOD_TYPES = {\n  %w[String upcase] => "String",\n  %w[String downcase] => "String",\n  %w[String length] => "Integer",\n  %w[String to_i] => "Integer",\n  %w[Array first] => "untyped",  # Element type\n  %w[Array length] => "Integer",\n  %w[Integer to_s] => "String",\n  # ... 200+ methods\n}.freeze\n'})}),"\n",(0,t.jsx)(n.h2,{id:"results",children:"Results"}),"\n",(0,t.jsx)(n.p,{children:"Now this T-Ruby code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class Greeter\n  def initialize(name: String)\n    @name = name\n  end\n\n  def greet\n    "Hello, #{@name}!"\n  end\n\n  def shout\n    @name.upcase\n  end\nend\n'})}),"\n",(0,t.jsx)(n.p,{children:"Automatically generates correct RBS:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rbs",children:"class Greeter\n  @name: String\n\n  def initialize: (name: String) -> void\n  def greet: () -> String\n  def shout: () -> String\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"No explicit return types needed!"}),"\n",(0,t.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,t.jsx)(n.p,{children:"We built comprehensive tests:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unit tests"}),": Literal inference, operator types, method call types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"E2E tests"}),": Full compilation with RBS validation"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'it "infers String from string literal" do\n  create_trb_file("src/test.trb", <<~TRB)\n    class Test\n      def message\n        "hello world"\n      end\n    end\n  TRB\n\n  rbs_content = compile_and_get_rbs("src/test.trb")\n  expect(rbs_content).to include("def message: () -> String")\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"challenges--solutions",children:"Challenges & Solutions"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Challenge"}),(0,t.jsx)(n.th,{children:"Solution"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Method bodies not parsed"}),(0,t.jsx)(n.td,{children:"Built custom BodyParser for T-Ruby syntax"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Implicit returns"}),(0,t.jsx)(n.td,{children:"Analyze last expression in blocks"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Recursive methods"}),(0,t.jsx)(n.td,{children:"2-pass analysis (signatures first, then bodies)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Complex expressions"}),(0,t.jsx)(n.td,{children:"Gradual expansion: literals \u2192 variables \u2192 operators \u2192 method calls"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Union types"}),(0,t.jsx)(n.td,{children:"Collect all return paths and unify"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"future-work",children:"Future Work"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generic inference"}),": ",(0,t.jsx)(n.code,{children:"[1, 2, 3]"})," \u2192 ",(0,t.jsx)(n.code,{children:"Array[Integer]"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Block/lambda types"}),": Infer block parameter and return types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type narrowing"}),": Smarter types after ",(0,t.jsx)(n.code,{children:"if x.is_a?(String)"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cross-method inference"}),": Use inferred types from other methods"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"By studying TypeScript's approach and adapting it for Ruby's simpler semantics, we built a practical type inference system. The key insights:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parse method bodies"})," - You can't infer types without seeing the code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lazy evaluation with caching"})," - Don't compute until needed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle Ruby idioms"})," - Implicit returns, ",(0,t.jsx)(n.code,{children:"initialize"}),", etc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Start simple"})," - Literals first, then build up complexity"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Type inference makes T-Ruby feel more natural. Write Ruby code, get type safety - no annotations required."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"The type inference system is available in T-Ruby. Try it out and let us know what you think!"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},6863:e=>{e.exports=JSON.parse('{"permalink":"/blog/typescript-style-type-inference","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/blog/2025-12-24-type-inference/index.md","source":"@site/blog/2025-12-24-type-inference/index.md","title":"Building TypeScript-Style Type Inference for T-Ruby","description":"How we implemented TypeScript-inspired static type inference for T-Ruby, enabling automatic type detection without explicit annotations.","date":"2025-12-24T00:00:00.000Z","tags":[{"inline":true,"label":"technical","permalink":"/blog/tags/technical"},{"inline":true,"label":"type-inference","permalink":"/blog/tags/type-inference"},{"inline":true,"label":"compiler","permalink":"/blog/tags/compiler"}],"readingTime":4.73,"hasTruncateMarker":true,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"typescript-style-type-inference","title":"Building TypeScript-Style Type Inference for T-Ruby","authors":["yhk1038"],"tags":["technical","type-inference","compiler"]},"unlisted":false,"prevItem":{"title":"Handling Keyword Arguments in T-Ruby","permalink":"/blog/keyword-arguments-type-definitions"},"nextItem":{"title":"Welcome to the T-Ruby Blog","permalink":"/blog/welcome"}}')},8885:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var r=i(9378);const t={},s=r.createContext(t);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);