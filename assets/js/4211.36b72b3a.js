"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[4211],{4211(e,n,r){r.d(n,{loadTRubyCompiler:()=>u});let o=null,s=null,t=null,a=null;const i=new Map;let l=0;const c=`\n// Web Worker for T-Ruby WASM compilation\n// This runs in a separate thread, isolated from browser extensions\n\n// Use @ruby/wasm-wasi package directly for DefaultRubyVM\nconst RUBY_WASM_CDN = 'https://cdn.jsdelivr.net/npm/@ruby/wasm-wasi@2.7.1/dist/browser/+esm';\n// Use Ruby 3.4 WASM binary (more stable)\nconst RUBY_WASM_BINARY = 'https://cdn.jsdelivr.net/npm/@ruby/3.4-wasm-wasi@2.7.1/dist/ruby+stdlib.wasm';\n\n// T-Ruby library CDN base URL\nconst T_RUBY_LIB_BASE = 'https://cdn.jsdelivr.net/npm/@t-ruby/wasm@0.0.8/dist/lib/';\n\n// T-Ruby library files in dependency order\nconst T_RUBY_FILES = ${JSON.stringify(["t_ruby/version.rb","t_ruby/config.rb","t_ruby/ir.rb","t_ruby/parser_combinator.rb","t_ruby/smt_solver.rb","t_ruby/type_alias_registry.rb","t_ruby/parser.rb","t_ruby/union_type_parser.rb","t_ruby/generic_type_parser.rb","t_ruby/intersection_type_parser.rb","t_ruby/type_erasure.rb","t_ruby/error_handler.rb","t_ruby/rbs_generator.rb","t_ruby/declaration_generator.rb","t_ruby/compiler.rb","t_ruby/constraint_checker.rb","t_ruby/type_inferencer.rb","t_ruby/runtime_validator.rb","t_ruby/type_checker.rb"])};\n\nconst BOOTSTRAP_CODE = \`\nrequire "json"\n\n# Define TRuby module if not already defined\nmodule TRuby\nend unless defined?(TRuby)\n\n$trb_compiler = nil\n\ndef get_compiler\n  $trb_compiler ||= TRuby::Compiler.new(nil, use_ir: true, optimize: false)\nend\n\ndef __trb_compile__(code)\n  compiler = get_compiler\n\n  begin\n    result = compiler.compile_string(code)\n\n    {\n      success: result[:errors].empty?,\n      ruby: result[:ruby] || "",\n      rbs: result[:rbs] || "",\n      errors: result[:errors] || []\n    }.to_json\n  rescue TRuby::ParseError => e\n    {\n      success: false,\n      ruby: "",\n      rbs: "",\n      errors: [e.message]\n    }.to_json\n  rescue StandardError => e\n    {\n      success: false,\n      ruby: "",\n      rbs: "",\n      errors: ["Compilation error: " + e.message + " at " + e.backtrace.first.to_s]\n    }.to_json\n  end\nend\n\ndef __trb_health_check__\n  {\n    loaded: defined?(TRuby) == "constant",\n    version: defined?(TRuby::VERSION) ? TRuby::VERSION : "unknown",\n    ruby_version: RUBY_VERSION\n  }.to_json\nend\n\`;\n\nlet vm = null;\nlet isReady = false;\n\n// Send message to main thread\nfunction sendToMain(type, data, requestId) {\n  self.postMessage({ type, data, requestId });\n}\n\n// Fetch T-Ruby library file\nasync function fetchTRubyFile(filename) {\n  const url = T_RUBY_LIB_BASE + filename;\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error('Failed to fetch ' + filename + ': ' + response.status);\n  }\n  return await response.text();\n}\n\n// Initialize Ruby VM with T-Ruby library\nasync function initialize() {\n  try {\n    console.log('[WASM Worker] Step 1: Loading Ruby WASM module...');\n    sendToMain('progress', { message: 'Loading Ruby runtime...', progress: 5 });\n\n    const { DefaultRubyVM } = await import(RUBY_WASM_CDN);\n    console.log('[WASM Worker] Step 1 complete');\n\n    console.log('[WASM Worker] Step 2: Fetching WASM binary...');\n    sendToMain('progress', { message: 'Downloading Ruby WASM binary...', progress: 15 });\n\n    const response = await fetch(RUBY_WASM_BINARY);\n    const wasmModule = await WebAssembly.compileStreaming(response);\n    console.log('[WASM Worker] Step 2 complete');\n\n    console.log('[WASM Worker] Step 3: Initializing Ruby VM...');\n    sendToMain('progress', { message: 'Initializing Ruby VM...', progress: 30 });\n\n    const result = await DefaultRubyVM(wasmModule);\n    vm = result.vm;\n    console.log('[WASM Worker] Step 3 complete');\n\n    console.log('[WASM Worker] Step 4: Loading T-Ruby library files...');\n    sendToMain('progress', { message: 'Loading T-Ruby compiler...', progress: 40 });\n\n    // Load each T-Ruby library file\n    const totalFiles = T_RUBY_FILES.length;\n    for (let i = 0; i < totalFiles; i++) {\n      const filename = T_RUBY_FILES[i];\n      const progress = 40 + Math.floor((i / totalFiles) * 50);\n      sendToMain('progress', { message: 'Loading ' + filename + '...', progress });\n\n      try {\n        const code = await fetchTRubyFile(filename);\n        // Remove frozen_string_literal comment and require_relative statements\n        // since we're loading files directly\n        const processedCode = code\n          .replace(/# frozen_string_literal: true\\n?/g, '')\n          .replace(/require_relative\\s+["'][^"']+["']\\n?/g, '')\n          .replace(/require\\s+["']fileutils["']\\n?/g, '');\n\n        console.log('[WASM Worker] Loading:', filename);\n        vm.eval(processedCode);\n      } catch (err) {\n        console.error('[WASM Worker] Error loading ' + filename + ':', err);\n        throw err;\n      }\n    }\n    console.log('[WASM Worker] Step 4 complete');\n\n    console.log('[WASM Worker] Step 5: Running bootstrap code...');\n    sendToMain('progress', { message: 'Initializing compiler...', progress: 95 });\n\n    vm.eval(BOOTSTRAP_CODE);\n    console.log('[WASM Worker] Step 5 complete');\n\n    // Health check\n    const healthResult = vm.eval('__trb_health_check__');\n    console.log('[WASM Worker] Health check:', healthResult.toString());\n\n    isReady = true;\n    sendToMain('ready', { health: JSON.parse(healthResult.toString()) });\n\n  } catch (error) {\n    console.error('[WASM Worker] Init error:', error);\n    sendToMain('error', { message: error.message });\n  }\n}\n\n// Compile code\nfunction compile(code, requestId) {\n  if (!isReady || !vm) {\n    sendToMain('compile-result', {\n      success: false,\n      ruby: '',\n      rbs: '',\n      errors: ['Compiler not ready']\n    }, requestId);\n    return;\n  }\n\n  try {\n    console.log('[WASM Worker] Compiling:', code.substring(0, 50) + '...');\n    // Use Base64 encoding to safely pass code with any special characters\n    const base64Code = btoa(unescape(encodeURIComponent(code)));\n    const decodeAndCompile = 'require "base64"; __trb_compile__(Base64.decode64("' + base64Code + '").force_encoding("UTF-8"))';\n    const resultJson = vm.eval(decodeAndCompile);\n    const result = JSON.parse(resultJson.toString());\n    console.log('[WASM Worker] Compile result:', result);\n    sendToMain('compile-result', result, requestId);\n  } catch (error) {\n    console.error('[WASM Worker] Compile error:', error);\n    sendToMain('compile-result', {\n      success: false,\n      ruby: '',\n      rbs: '',\n      errors: [error.message]\n    }, requestId);\n  }\n}\n\n// Listen for messages from main thread\nself.addEventListener('message', (event) => {\n  const { type, data, requestId } = event.data || {};\n\n  switch (type) {\n    case 'init':\n      initialize();\n      break;\n    case 'compile':\n      compile(data.code, requestId);\n      break;\n  }\n});\n\n// Signal that worker is loaded\nsendToMain('loaded', {});\n`;async function u(e){if(o)return e?.({state:"ready",message:"Compiler ready"}),o;if(s)return s;s=async function(e){return new Promise((n,r)=>{console.log("[T-Ruby] Creating Web Worker for WASM execution..."),e?.({state:"loading",message:"Initializing compiler worker...",progress:0});const s=new Blob([c],{type:"application/javascript"}),u=URL.createObjectURL(s),d=new Worker(u,{type:"module"});URL.revokeObjectURL(u),d.onmessage=o=>{const{type:s,data:c,requestId:u}=o.data||{};switch(console.log("[T-Ruby] Received message from worker:",s,c),s){case"loaded":console.log("[T-Ruby] Worker loaded, sending init command..."),d.postMessage({type:"init"});break;case"progress":e?.({state:"loading",message:c.message,progress:c.progress});break;case"ready":console.log("[T-Ruby] Worker ready, health:",c.health),a=c.health,e?.({state:"ready",message:"Compiler ready",progress:100});const o={compile:async e=>new Promise((n,r)=>{const o=`req_${++l}_${Date.now()}`;i.set(o,{resolve:n,reject:r}),console.log("[T-Ruby] Sending compile request:",o),d.postMessage({type:"compile",data:{code:e},requestId:o}),setTimeout(()=>{i.has(o)&&(i.delete(o),r(new Error("Compile timeout")))},3e4)}),healthCheck:()=>a||{loaded:!1,version:"unknown",ruby_version:"unknown"},getVersion:()=>({t_ruby:a?.version||"unknown",ruby:a?.ruby_version||"unknown"})};t=d,n(o);break;case"compile-result":console.log("[T-Ruby] Compile result received for:",u);const s=i.get(u);s&&(i.delete(u),s.resolve(c));break;case"error":console.error("[T-Ruby] Worker error:",c.message),e?.({state:"error",message:c.message}),d.terminate(),r(new Error(c.message))}},d.onerror=e=>{console.error("[T-Ruby] Worker error:",e),r(new Error("Failed to initialize WASM worker"))};const b=setTimeout(()=>{o||(console.error("[T-Ruby] Worker initialization timeout"),d.terminate(),r(new Error("WASM worker initialization timeout")))},12e4),p=n;n=e=>{clearTimeout(b),p(e)}})}(e);try{return o=await s,o}catch(n){throw s=null,n}}}}]);