"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[627],{1203:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"reference/type-operators","title":"Type Operators","description":"Type operators and modifiers","source":"@site/docs/reference/type-operators.md","sourceDirName":"reference","slug":"/reference/type-operators","permalink":"/docs/reference/type-operators","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/reference/type-operators.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Type Operators","description":"Type operators and modifiers"},"sidebar":"docsSidebar","previous":{"title":"Built-in Types","permalink":"/docs/reference/built-in-types"},"next":{"title":"Standard Library Types","permalink":"/docs/reference/stdlib-types"}}');var a=r(2714),s=r(8885);const t={sidebar_position:3,title:"Type Operators",description:"Type operators and modifiers"},l="Type Operators",d={},o=[{value:"Union Operator (<code>|</code>)",id:"union-operator-",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Examples",id:"examples",level:3},{value:"Usage Patterns",id:"usage-patterns",level:3},{value:"Type Narrowing",id:"type-narrowing",level:3},{value:"Optional Operator (<code>?</code>)",id:"optional-operator-",level:2},{value:"Syntax",id:"syntax-1",level:3},{value:"Examples",id:"examples-1",level:3},{value:"Safe Navigation",id:"safe-navigation",level:3},{value:"Intersection Operator (<code>&amp;</code>)",id:"intersection-operator-",level:2},{value:"Syntax",id:"syntax-2",level:3},{value:"Examples",id:"examples-2",level:3},{value:"Multiple Constraints",id:"multiple-constraints",level:3},{value:"Generic Type Parameters (<code>&lt;T&gt;</code>)",id:"generic-type-parameters-t",level:2},{value:"Function Generics",id:"function-generics",level:3},{value:"Class Generics",id:"class-generics",level:3},{value:"Nested Generics",id:"nested-generics",level:3},{value:"Array Type Operator",id:"array-type-operator",level:2},{value:"Syntax",id:"syntax-3",level:3},{value:"Examples",id:"examples-3",level:3},{value:"Hash Type Operator",id:"hash-type-operator",level:2},{value:"Syntax",id:"syntax-4",level:3},{value:"Examples",id:"examples-4",level:3},{value:"Proc Type Operator",id:"proc-type-operator",level:2},{value:"Syntax",id:"syntax-5",level:3},{value:"Examples",id:"examples-5",level:3},{value:"Type Assertion Operator (<code>as</code>)",id:"type-assertion-operator-as",level:2},{value:"Syntax",id:"syntax-6",level:3},{value:"Examples",id:"examples-6",level:3},{value:"Warning",id:"warning",level:3},{value:"Type Guard Operator (<code>is</code>)",id:"type-guard-operator-is",level:2},{value:"Syntax",id:"syntax-7",level:3},{value:"Examples",id:"examples-7",level:3},{value:"Literal Type Operators",id:"literal-type-operators",level:2},{value:"String Literals",id:"string-literals",level:3},{value:"Number Literals",id:"number-literals",level:3},{value:"Symbol Literals",id:"symbol-literals",level:3},{value:"Boolean Literals",id:"boolean-literals",level:3},{value:"Tuple Types <em>(Planned)</em>",id:"tuple-types-planned",level:2},{value:"Readonly Modifier <em>(Planned)</em>",id:"readonly-modifier-planned",level:2},{value:"Keyof Operator <em>(Planned)</em>",id:"keyof-operator-planned",level:2},{value:"Typeof Operator <em>(Planned)</em>",id:"typeof-operator-planned",level:2},{value:"Operator Precedence",id:"operator-precedence",level:2},{value:"Examples",id:"examples-8",level:3},{value:"Operator Reference Table",id:"operator-reference-table",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Prefer Union Over Any",id:"1-prefer-union-over-any",level:3},{value:"2. Use Optional Operator for Clarity",id:"2-use-optional-operator-for-clarity",level:3},{value:"3. Limit Union Complexity",id:"3-limit-union-complexity",level:3},{value:"4. Use Intersection for Multiple Interfaces",id:"4-use-intersection-for-multiple-interfaces",level:3},{value:"5. Avoid Excessive Type Assertions",id:"5-avoid-excessive-type-assertions",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Result Type with Union",id:"result-type-with-union",level:3},{value:"Optional Chaining",id:"optional-chaining",level:3},{value:"Type Narrowing with Guards",id:"type-narrowing-with-guards",level:3},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components},{DocsBadge:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r,{}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"type-operators",children:"Type Operators"})}),"\n",(0,a.jsx)(n.p,{children:"Type operators allow you to combine, modify, and transform types in T-Ruby. This reference covers all available type operators and their usage patterns."}),"\n",(0,a.jsxs)(n.h2,{id:"union-operator-",children:["Union Operator (",(0,a.jsx)(n.code,{children:"|"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"The union operator combines multiple types into one, indicating a value can be any of the specified types."}),"\n",(0,a.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"Type1 | Type2 | Type3\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Basic union\nid: String | Integer = "user-123"\nid: String | Integer = 456\n\n# Multiple types\nvalue: String | Integer | Float | Boolean = 3.14\n\n# With nil (optional type)\nname: String | nil = nil\nuser: User | nil = find_user(123)\n\n# In collections\nmixed: (String | Integer)[] = ["Alice", 1, "Bob", 2]\nconfig: Hash<Symbol, String | Integer | Boolean> = {\n  host: "localhost",\n  port: 3000,\n  debug: true\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"usage-patterns",children:"Usage Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Function return types\ndef find_user(id: Integer): User | nil\n  # Returns User or nil\nend\n\n# Function parameters\ndef format_id(value: String | Integer): String\n  if value.is_a?(String)\n    value.upcase\n  else\n    "ID-#{value}"\n  end\nend\n\n# Error handling\ndef divide(a: Float, b: Float): Float | String\n  return "Error: Division by zero" if b == 0\n  a / b\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"type-narrowing",children:"Type Narrowing"}),"\n",(0,a.jsx)(n.p,{children:"Use type guards to narrow union types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"def process(value: String | Integer): String\n  if value.is_a?(String)\n    # T-Ruby knows value is String here\n    value.upcase\n  else\n    # T-Ruby knows value is Integer here\n    value.to_s\n  end\nend\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"optional-operator-",children:["Optional Operator (",(0,a.jsx)(n.code,{children:"?"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["Shorthand for union with ",(0,a.jsx)(n.code,{children:"nil"}),". ",(0,a.jsx)(n.code,{children:"T?"})," is equivalent to ",(0,a.jsx)(n.code,{children:"T | nil"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"syntax-1",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"Type?\n# Equivalent to: Type | nil\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-1",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# These are equivalent\nname1: String | nil = nil\nname2: String? = nil\n\n# Optional parameters\ndef greet(name: String?): String\n  if name\n    "Hello, #{name}!"\n  else\n    "Hello, stranger!"\n  end\nend\n\n# Optional instance variables\nclass User\n  @email: String?\n  @phone: String | nil\n\n  def initialize: void\n    @email = nil\n    @phone = nil\n  end\nend\n\n# In collections\nusers: User?[] = [User.new, nil, User.new]\ncache: Hash<String, Integer?> = { "count" => 42, "missing" => nil }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"safe-navigation",children:"Safe Navigation"}),"\n",(0,a.jsxs)(n.p,{children:["Use the safe navigation operator (",(0,a.jsx)(n.code,{children:"&."}),") with optional types:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'def get_email_domain(user: User?): String?\n  user&.email&.split("@")&.last\nend\n'})}),"\n",(0,a.jsxs)(n.h2,{id:"intersection-operator-",children:["Intersection Operator (",(0,a.jsx)(n.code,{children:"&"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"The intersection operator combines multiple types, requiring a value to satisfy all types simultaneously."}),"\n",(0,a.jsx)(n.h3,{id:"syntax-2",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"Type1 & Type2 & Type3\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-2",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Interface intersection\ninterface Printable\n  def to_s: String\nend\n\ninterface Comparable\n  def <=>(other: self): Integer\nend\n\n# Type must implement both interfaces\ntype Serializable = Printable & Comparable\n\nclass User\n  implements Printable & Comparable\n\n  @name: String\n  @id: Integer\n\n  def initialize(name: String, id: Integer): void\n    @name = name\n    @id = id\n  end\n\n  def to_s: String\n    "User(#{@id}: #{@name})"\n  end\n\n  def <=>(other: User): Integer\n    @id <=> other.id\n  end\nend\n\n# Function accepting intersection type\ndef serialize(obj: Printable & Comparable): String\n  obj.to_s\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"multiple-constraints",children:"Multiple Constraints"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# Generic with multiple constraints\ndef sort_and_print<T>(items: T[]): void\n  where T: Printable & Comparable\n\n  sorted = items.sort\n  sorted.each { |item| puts item.to_s }\nend\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"generic-type-parameters-t",children:["Generic Type Parameters (",(0,a.jsx)(n.code,{children:"<T>"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"Angle brackets denote generic type parameters."}),"\n",(0,a.jsx)(n.h3,{id:"function-generics",children:"Function Generics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# Single type parameter\ndef first<T>(arr: T[]): T | nil\n  arr[0]\nend\n\n# Multiple type parameters\ndef pair<K, V>(key: K, value: V): Hash<K, V>\n  { key => value }\nend\n\n# Generic with constraints\ndef find<T>(items: T[], predicate: Proc<T, Boolean>): T | nil\n  items.find { |item| predicate.call(item) }\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"class-generics",children:"Class Generics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# Generic class\nclass Box<T>\n  @value: T\n\n  def initialize(value: T): void\n    @value = value\n  end\n\n  def get: T\n    @value\n  end\n\n  def set(value: T): void\n    @value = value\n  end\nend\n\n# Multiple type parameters\nclass Pair<K, V>\n  @key: K\n  @value: V\n\n  def initialize(key: K, value: V): void\n    @key = key\n    @value = value\n  end\n\n  def key: K\n    @key\n  end\n\n  def value: V\n    @value\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"nested-generics",children:"Nested Generics"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Nested generic types\ncache: Hash<String, Integer[]> = {\n  "fibonacci" => [1, 1, 2, 3, 5, 8]\n}\n\n# Complex nesting\ntype NestedData = Hash<String, Hash<Symbol, String | Integer>[]>\n\ndata: NestedData = {\n  "users" => [\n    { name: "Alice", age: 30 },\n    { name: "Bob", age: 25 }\n  ]\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"array-type-operator",children:"Array Type Operator"}),"\n",(0,a.jsxs)(n.p,{children:["Array types use shorthand syntax ",(0,a.jsx)(n.code,{children:"T[]"})," (preferred) or generic ",(0,a.jsx)(n.code,{children:"Array<T>"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"syntax-3",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"ElementType[]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-3",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Basic arrays\nstrings: String[] = ["a", "b", "c"]\nnumbers: Integer[] = [1, 2, 3]\n\n# Union element types\nmixed: (String | Integer)[] = ["Alice", 1, "Bob", 2]\n\n# Nested arrays\nmatrix: Float[][] = [\n  [1.0, 2.0],\n  [3.0, 4.0]\n]\n\n# Generic function returning array\ndef range<T>(start: T, count: Integer, &block: Proc<T, T>): T[]\n  result: T[] = [start]\n  current = start\n\n  (count - 1).times do\n    current = block.call(current)\n    result.push(current)\n  end\n\n  result\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"hash-type-operator",children:"Hash Type Operator"}),"\n",(0,a.jsx)(n.p,{children:"Hash types use angle brackets with two type parameters: key and value types."}),"\n",(0,a.jsx)(n.h3,{id:"syntax-4",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"Hash<KeyType, ValueType>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-4",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Basic hashes\nscores: Hash<String, Integer> = { "Alice" => 100 }\nconfig: Hash<Symbol, String> = { host: "localhost" }\n\n# Union value types\ndata: Hash<String, String | Integer | Boolean> = {\n  "name" => "Alice",\n  "age" => 30,\n  "active" => true\n}\n\n# Nested hashes\nusers: Hash<Integer, Hash<Symbol, String>> = {\n  1 => { name: "Alice", email: "alice@example.com" }\n}\n\n# Generic hash function\ndef group_by<T, K>(items: T[], &block: Proc<T, K>): Hash<K, T[]>\n  result: Hash<K, T[]> = {}\n\n  items.each do |item|\n    key = block.call(item)\n    result[key] ||= []\n    result[key].push(item)\n  end\n\n  result\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"proc-type-operator",children:"Proc Type Operator"}),"\n",(0,a.jsx)(n.p,{children:"Proc types specify callable objects with typed parameters and return values."}),"\n",(0,a.jsx)(n.h3,{id:"syntax-5",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",metastring:"{skip-verify}",children:"Proc<Param1Type, Param2Type, ..., ReturnType>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-5",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# No parameters\nsupplier: Proc<String> = ->: String { "Hello" }\n\n# Single parameter\ntransformer: Proc<Integer, String> = ->(n: Integer): String { n.to_s }\n\n# Multiple parameters\nadder: Proc<Integer, Integer, Integer> = ->(a: Integer, b: Integer): Integer {\n  a + b\n}\n\n# Void return\nlogger: Proc<String, void> = ->(msg: String): void { puts msg }\n\n# Generic proc parameter\ndef map<T, U>(arr: T[], fn: Proc<T, U>): U[]\n  arr.map { |item| fn.call(item) }\nend\n\n# Block parameter\ndef each_with_index<T>(items: T[], &block: Proc<T, Integer, void>): void\n  items.each_with_index { |item, index| block.call(item, index) }\nend\n'})}),"\n",(0,a.jsxs)(n.h2,{id:"type-assertion-operator-as",children:["Type Assertion Operator (",(0,a.jsx)(n.code,{children:"as"}),")"]}),"\n",(0,a.jsx)(n.p,{children:"Type assertions override type checking. Use with caution."}),"\n",(0,a.jsx)(n.h3,{id:"syntax-6",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"value as TargetType\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-6",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# Asserting type\nvalue = get_unknown_value() as String\n\n# Casting from Any\ndata: Any = fetch_data()\nuser = data as User\n\n# Narrowing union types\ndef process(value: String | Integer): String\n  if is_string?(value)\n    # Without assertion, T-Ruby may not narrow\n    str = value as String\n    str.upcase\n  else\n    value.to_s\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"warning",children:"Warning"}),"\n",(0,a.jsx)(n.p,{children:"Type assertions bypass type safety. Prefer type guards:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# \u274c Risky: Using type assertion\ndef bad_example(value: Any): String\n  (value as String).upcase\nend\n\n# \u2705 Better: Using type guard\ndef good_example(value: Any): String | nil\n  if value.is_a?(String)\n    value.upcase\n  else\n    nil\n  end\nend\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"type-guard-operator-is",children:["Type Guard Operator (",(0,a.jsx)(n.code,{children:"is"}),")"]}),"\n",(0,a.jsxs)(n.p,{children:["Type guards are predicates that narrow types. ",(0,a.jsx)(n.em,{children:"(Experimental feature)"})]}),"\n",(0,a.jsx)(n.h3,{id:"syntax-7",children:"Syntax"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"def function_name(param: Type): param is NarrowedType\n  # Type checking logic\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"examples-7",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# String guard\ndef is_string(value: Any): value is String\n  value.is_a?(String)\nend\n\n# Number guard\ndef is_number(value: Any): value is Integer | Float\n  value.is_a?(Integer) || value.is_a?(Float)\nend\n\n# Usage\nvalue = get_value()\nif is_string(value)\n  # value is String here\n  puts value.upcase\nend\n\n# Custom type guard\ndef is_user(value: Any): value is User\n  value.is_a?(User) && value.respond_to?(:name)\nend\n"})}),"\n",(0,a.jsx)(n.h2,{id:"literal-type-operators",children:"Literal Type Operators"}),"\n",(0,a.jsx)(n.p,{children:"Literal types represent specific values rather than general types."}),"\n",(0,a.jsx)(n.h3,{id:"string-literals",children:"String Literals"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'type Status = "pending" | "active" | "completed" | "failed"\n\nstatus: Status = "active"  # OK\n# status: Status = "unknown"  # Error\n\ndef set_status(s: Status): void\n  # Only accepts the four specific strings\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"number-literals",children:"Number Literals"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"type HTTPPort = 80 | 443 | 8080 | 3000\n\nport: HTTPPort = 443  # OK\n# port: HTTPPort = 9999  # Error\n\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6\n"})}),"\n",(0,a.jsx)(n.h3,{id:"symbol-literals",children:"Symbol Literals"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"type Role = :admin | :editor | :viewer\n\nrole: Role = :admin  # OK\n# role: Role = :guest  # Error\n\ntype HTTPMethod = :get | :post | :put | :patch | :delete\n"})}),"\n",(0,a.jsx)(n.h3,{id:"boolean-literals",children:"Boolean Literals"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"type AlwaysTrue = true\ntype AlwaysFalse = false\n\nflag: AlwaysTrue = true\n# flag: AlwaysTrue = false  # Error\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"tuple-types-planned",children:["Tuple Types ",(0,a.jsx)(n.em,{children:"(Planned)"})]}),"\n",(0,a.jsx)(n.p,{children:"Fixed-length arrays with specific types per position."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Tuple type (planned)\ntype Point = [Float, Float]\ntype RGB = [Integer, Integer, Integer]\n\npoint: Point = [10.5, 20.3]\ncolor: RGB = [255, 0, 128]\n\n# Tuple with labels (planned)\ntype Person = [name: String, age: Integer]\nperson: Person = ["Alice", 30]\n'})}),"\n",(0,a.jsxs)(n.h2,{id:"readonly-modifier-planned",children:["Readonly Modifier ",(0,a.jsx)(n.em,{children:"(Planned)"})]}),"\n",(0,a.jsx)(n.p,{children:"Makes types immutable."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# Readonly type (planned)\ntype ReadonlyArray<T> = readonly T[]\ntype ReadonlyHash<K, V> = readonly Hash<K, V>\n\n# Cannot modify\nnums: ReadonlyArray<Integer> = [1, 2, 3]\n# nums.push(4)  # Error: Cannot modify readonly array\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"keyof-operator-planned",children:["Keyof Operator ",(0,a.jsx)(n.em,{children:"(Planned)"})]}),"\n",(0,a.jsx)(n.p,{children:"Extracts keys from object types."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# Keyof operator (planned)\ninterface User\n  @name: String\n  @email: String\n  @age: Integer\nend\n\ntype UserKey = keyof User  # :name | :email | :age\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"typeof-operator-planned",children:["Typeof Operator ",(0,a.jsx)(n.em,{children:"(Planned)"})]}),"\n",(0,a.jsx)(n.p,{children:"Gets the type of a value."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# Typeof operator (planned)\nconfig = { host: "localhost", port: 3000 }\ntype Config = typeof config\n# Config = Hash<Symbol, String | Integer>\n'})}),"\n",(0,a.jsx)(n.h2,{id:"operator-precedence",children:"Operator Precedence"}),"\n",(0,a.jsx)(n.p,{children:"When combining operators, T-Ruby follows this precedence (highest to lowest):"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Generic parameters: ",(0,a.jsx)(n.code,{children:"<T>"})]}),"\n",(0,a.jsxs)(n.li,{children:["Array/Hash/Proc: ",(0,a.jsx)(n.code,{children:"T[]"}),", ",(0,a.jsx)(n.code,{children:"Hash<K,V>"}),", ",(0,a.jsx)(n.code,{children:"Proc<T,R>"})]}),"\n",(0,a.jsxs)(n.li,{children:["Intersection: ",(0,a.jsx)(n.code,{children:"&"})]}),"\n",(0,a.jsxs)(n.li,{children:["Union: ",(0,a.jsx)(n.code,{children:"|"})]}),"\n",(0,a.jsxs)(n.li,{children:["Optional: ",(0,a.jsx)(n.code,{children:"?"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"examples-8",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# Intersection has higher precedence than union\ntype A = String | Integer & Float\n# Equivalent to: String | (Integer & Float)\n\n# Use parentheses for clarity\ntype B = (String | Integer) & Comparable\n\n# Optional applies to entire type on left\ntype C = String | Integer?\n# Equivalent to: String | (Integer | nil)\n\n# Use parentheses to make Integer optional only\ntype D = String | (Integer?)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"operator-reference-table",children:"Operator Reference Table"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Operator"}),(0,a.jsx)(n.th,{children:"Name"}),(0,a.jsx)(n.th,{children:"Description"}),(0,a.jsx)(n.th,{children:"Example"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"|"})}),(0,a.jsx)(n.td,{children:"Union"}),(0,a.jsx)(n.td,{children:"Either/or types"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"String | Integer"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"&"})}),(0,a.jsx)(n.td,{children:"Intersection"}),(0,a.jsx)(n.td,{children:"Both types"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"Printable & Comparable"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"?"})}),(0,a.jsx)(n.td,{children:"Optional"}),(0,a.jsx)(n.td,{children:"Type or nil"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"String?"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"<T>"})}),(0,a.jsx)(n.td,{children:"Generic"}),(0,a.jsx)(n.td,{children:"Type parameter"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"T[]"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"as"})}),(0,a.jsx)(n.td,{children:"Type assertion"}),(0,a.jsx)(n.td,{children:"Force type"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"value as String"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"is"})}),(0,a.jsx)(n.td,{children:"Type guard"}),(0,a.jsx)(n.td,{children:"Type predicate"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"value is String"})})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"[]"})}),(0,a.jsx)(n.td,{children:"Tuple"}),(0,a.jsx)(n.td,{children:"Fixed array"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"[String, Integer]"})," (planned)"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"readonly"})}),(0,a.jsx)(n.td,{children:"Readonly"}),(0,a.jsx)(n.td,{children:"Immutable"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"readonly T[]"})," (planned)"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"keyof"})}),(0,a.jsx)(n.td,{children:"Key extraction"}),(0,a.jsx)(n.td,{children:"Object keys"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"keyof User"})," (planned)"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"typeof"})}),(0,a.jsx)(n.td,{children:"Type query"}),(0,a.jsx)(n.td,{children:"Get type"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"typeof value"})," (planned)"]})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-prefer-union-over-any",children:"1. Prefer Union Over Any"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# \u274c Too permissive\ndata: Any = get_data()\n\n# \u2705 Specific types\ndata: String | Integer | Hash<String, String> = get_data()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-use-optional-operator-for-clarity",children:"2. Use Optional Operator for Clarity"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# \u274c Verbose\nname: String | nil = nil\n\n# \u2705 Concise\nname: String? = nil\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-limit-union-complexity",children:"3. Limit Union Complexity"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# \u274c Too many options\nvalue: String | Integer | Float | Boolean | Symbol | nil | String[]\n\n# \u2705 Use type alias\ntype PrimitiveValue = String | Integer | Float | Boolean\ntype OptionalPrimitive = PrimitiveValue?\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-use-intersection-for-multiple-interfaces",children:"4. Use Intersection for Multiple Interfaces"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"# \u2705 Clear requirements\ndef process<T>(item: T): void\n  where T: Serializable & Comparable\n  # Item must implement both\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-avoid-excessive-type-assertions",children:"5. Avoid Excessive Type Assertions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'# \u274c Bypassing type safety\ndef risky(data: Any): String\n  (data as Hash<String, String>)["key"] as String\nend\n\n# \u2705 Use type guards\ndef safe(data: Any): String?\n  return nil unless data.is_a?(Hash)\n  value = data["key"]\n  value.is_a?(String) ? value : nil\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"result-type-with-union",children:"Result Type with Union"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'type Result<T, E> = { success: true, value: T } | { success: false, error: E }\n\ndef divide(a: Float, b: Float): Result<Float, String>\n  if b == 0\n    { success: false, error: "Division by zero" }\n  else\n    { success: true, value: a / b }\n  end\nend\n'})}),"\n",(0,a.jsx)(n.h3,{id:"optional-chaining",children:"Optional Chaining"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:"class User\n  @profile: Profile?\n\n  def avatar_url: String?\n    @profile&.avatar&.url\n  end\nend\n"})}),"\n",(0,a.jsx)(n.h3,{id:"type-narrowing-with-guards",children:"Type Narrowing with Guards"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-trb",children:'def process_value(value: String | Integer | nil): String\n  if value.nil?\n    "No value"\n  elsif value.is_a?(String)\n    value.upcase\n  else\n    value.to_s\n  end\nend\n'})}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/reference/built-in-types",children:"Built-in Types"})," - Complete type reference"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/learn/advanced/type-aliases",children:"Type Aliases"})," - Creating custom types"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/learn/generics/generic-functions-classes",children:"Generics"})," - Generic programming"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/learn/everyday-types/union-types",children:"Union Types"})," - Detailed union type guide"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8885:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var i=r(9378);const a={},s=i.createContext(a);function t(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);