"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[3527],{6145(e,n,r){r.d(n,{R:()=>i,x:()=>o});var s=r(7140);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},8588(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"learn/everyday-types/arrays-and-hashes","title":"Arrays and Hashes","description":"Working with Array and Hash types","source":"@site/docs/learn/everyday-types/arrays-and-hashes.md","sourceDirName":"learn/everyday-types","slug":"/learn/everyday-types/arrays-and-hashes","permalink":"/docs/learn/everyday-types/arrays-and-hashes","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/everyday-types/arrays-and-hashes.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Arrays and Hashes","description":"Working with Array and Hash types"},"sidebar":"docsSidebar","previous":{"title":"Primitives","permalink":"/docs/learn/everyday-types/primitives"},"next":{"title":"Union Types","permalink":"/docs/learn/everyday-types/union-types"}}');var t=r(5656),a=r(6145);const i={sidebar_position:2,title:"Arrays and Hashes",description:"Working with Array and Hash types"},o="Arrays and Hashes",l={},d=[{value:"Array Types",id:"array-types",level:2},{value:"Basic Array Syntax",id:"basic-array-syntax",level:3},{value:"Type Inference with Arrays",id:"type-inference-with-arrays",level:3},{value:"Array Operations",id:"array-operations",level:3},{value:"Accessing Array Elements",id:"accessing-array-elements",level:3},{value:"Iterating Over Arrays",id:"iterating-over-arrays",level:3},{value:"Array Transformation Methods",id:"array-transformation-methods",level:3},{value:"Nested Arrays",id:"nested-arrays",level:3},{value:"Hash Types",id:"hash-types",level:2},{value:"Basic Hash Syntax",id:"basic-hash-syntax",level:3},{value:"Type Inference with Hashes",id:"type-inference-with-hashes",level:3},{value:"Hash Operations",id:"hash-operations",level:3},{value:"Iterating Over Hashes",id:"iterating-over-hashes",level:3},{value:"Hash Transformation Methods",id:"hash-transformation-methods",level:3},{value:"Nested Hashes",id:"nested-hashes",level:3},{value:"Working with Union Types in Collections",id:"working-with-union-types-in-collections",level:2},{value:"Arrays with Union Types",id:"arrays-with-union-types",level:3},{value:"Hashes with Union Types",id:"hashes-with-union-types",level:3},{value:"Practical Example: Data Processing",id:"practical-example-data-processing",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Building Arrays Dynamically",id:"building-arrays-dynamically",level:3},{value:"Building Hashes Dynamically",id:"building-hashes-dynamically",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Empty Collections Need Type Annotations",id:"empty-collections-need-type-annotations",level:3},{value:"Mutating Collections",id:"mutating-collections",level:3},{value:"Hash Key Types Matter",id:"hash-key-types-matter",level:3},{value:"Summary",id:"summary",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{DocsBadge:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r,{}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"arrays-and-hashes",children:"Arrays and Hashes"})}),"\n",(0,t.jsx)(n.p,{children:"Arrays and hashes are the most commonly used collection types in T-Ruby. They allow you to store and organize multiple values in a structured way. This chapter will teach you how to use generic type parameters to create type-safe collections."}),"\n",(0,t.jsx)(n.h2,{id:"array-types",children:"Array Types"}),"\n",(0,t.jsxs)(n.p,{children:["Arrays in T-Ruby use shorthand syntax: ",(0,t.jsx)(n.code,{children:"T[]"}),", where ",(0,t.jsx)(n.code,{children:"T"})," is the type of elements in the array. You can also use the generic syntax ",(0,t.jsx)(n.code,{children:"Array<T>"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"basic-array-syntax",children:"Basic Array Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_basics.trb"',children:'# Array of integers\nnumbers: Integer[] = [1, 2, 3, 4, 5]\n\n# Array of strings\nnames: String[] = ["Alice", "Bob", "Charlie"]\n\n# Array of floats\nprices: Float[] = [9.99, 14.99, 19.99]\n\n# Empty array (type annotation required)\nitems: String[] = []\n'})}),"\n",(0,t.jsx)(n.h3,{id:"type-inference-with-arrays",children:"Type Inference with Arrays"}),"\n",(0,t.jsx)(n.p,{children:"When initializing with values, T-Ruby can infer the array type:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_inference.trb"',children:'# Type is inferred as Integer[]\nnumbers = [1, 2, 3, 4, 5]\n\n# Type is inferred as String[]\nnames = ["Alice", "Bob", "Charlie"]\n\n# For empty arrays, you must provide a type annotation\nitems: String[] = []\n'})}),"\n",(0,t.jsx)(n.h3,{id:"array-operations",children:"Array Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_operations.trb"',children:'def add_item(items: String[], item: String): String[]\n  items << item\n  items\nend\n\ndef get_first(items: String[]): String?\n  items.first\nend\n\ndef get_last(items: Integer[]): Integer?\n  items.last\nend\n\ndef array_length(items: String[]): Integer\n  items.length\nend\n\n# Usage\nlist: String[] = ["apple", "banana"]\nupdated = add_item(list, "cherry")  # ["apple", "banana", "cherry"]\n\nfirst: String? = get_first(list)  # "apple"\ncount: Integer = array_length(list)  # 3\n'})}),"\n",(0,t.jsx)(n.h3,{id:"accessing-array-elements",children:"Accessing Array Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_access.trb"',children:'def get_at_index(items: String[], index: Integer): String?\n  items[index]\nend\n\ndef get_slice(items: Integer[], start: Integer, length: Integer): Integer[]\n  items[start, length]\nend\n\ndef get_range(items: String[], range: Range): String[]\n  items[range]\nend\n\nfruits: String[] = ["apple", "banana", "cherry", "date"]\n\nitem: String? = get_at_index(fruits, 0)  # "apple"\nslice: Integer[] = get_slice([1, 2, 3, 4, 5], 1, 3)  # [2, 3, 4]\nsubset: String[] = get_range(fruits, 1..2)  # ["banana", "cherry"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"iterating-over-arrays",children:"Iterating Over Arrays"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_iteration.trb"',children:"def sum_numbers(numbers: Integer[]): Integer\n  total = 0\n  numbers.each do |n|\n    total += n\n  end\n  total\nend\n\ndef double_values(numbers: Integer[]): Integer[]\n  numbers.map { |n| n * 2 }\nend\n\ndef filter_positive(numbers: Integer[]): Integer[]\n  numbers.select { |n| n > 0 }\nend\n\ndef find_first_even(numbers: Integer[]): Integer?\n  numbers.find { |n| n % 2 == 0 }\nend\n\ntotal: Integer = sum_numbers([1, 2, 3, 4, 5])  # 15\ndoubled: Integer[] = double_values([1, 2, 3])  # [2, 4, 6]\npositive: Integer[] = filter_positive([-1, 2, -3, 4])  # [2, 4]\neven: Integer? = find_first_even([1, 3, 4, 5])  # 4\n"})}),"\n",(0,t.jsx)(n.h3,{id:"array-transformation-methods",children:"Array Transformation Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_transform.trb"',children:'def join_strings(items: String[], separator: String): String\n  items.join(separator)\nend\n\ndef reverse_array(items: Integer[]): Integer[]\n  items.reverse\nend\n\ndef sort_numbers(numbers: Integer[]): Integer[]\n  numbers.sort\nend\n\ndef unique_items(items: String[]): String[]\n  items.uniq\nend\n\njoined: String = join_strings(["a", "b", "c"], "-")  # "a-b-c"\nreversed: Integer[] = reverse_array([1, 2, 3])  # [3, 2, 1]\nsorted: Integer[] = sort_numbers([3, 1, 4, 2])  # [1, 2, 3, 4]\nunique: String[] = unique_items(["a", "b", "a", "c"])  # ["a", "b", "c"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nested-arrays",children:"Nested Arrays"}),"\n",(0,t.jsx)(n.p,{children:"Arrays can contain other arrays:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="nested_arrays.trb"',children:"# 2D array (array of arrays)\ndef create_grid(rows: Integer, cols: Integer): Integer[][]\n  grid: Integer[][] = []\n\n  rows.times do |r|\n    row: Integer[] = []\n    cols.times do |c|\n      row << (r * cols + c)\n    end\n    grid << row\n  end\n\n  grid\nend\n\ndef get_cell(grid: Integer[][], row: Integer, col: Integer): Integer?\n  return nil if grid[row].nil?\n  grid[row][col]\nend\n\nmatrix: Integer[][] = create_grid(3, 3)\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\nvalue = get_cell(matrix, 1, 1)  # 4\n"})}),"\n",(0,t.jsx)(n.h2,{id:"hash-types",children:"Hash Types"}),"\n",(0,t.jsxs)(n.p,{children:["Hashes in T-Ruby use generic type syntax: ",(0,t.jsx)(n.code,{children:"Hash<K, V>"}),", where ",(0,t.jsx)(n.code,{children:"K"})," is the key type and ",(0,t.jsx)(n.code,{children:"V"})," is the value type."]}),"\n",(0,t.jsx)(n.h3,{id:"basic-hash-syntax",children:"Basic Hash Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_basics.trb"',children:'# Hash with Symbol keys and String values\nuser: Hash<Symbol, String> = {\n  name: "Alice",\n  email: "alice@example.com"\n}\n\n# Hash with String keys and Integer values\nscores: Hash<String, Integer> = {\n  "math" => 95,\n  "science" => 88,\n  "english" => 92\n}\n\n# Hash with Integer keys and String values\nid_map: Hash<Integer, String> = {\n  1 => "Alice",\n  2 => "Bob",\n  3 => "Charlie"\n}\n\n# Empty hash (type annotation required)\nconfig: Hash<Symbol, String> = {}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"type-inference-with-hashes",children:"Type Inference with Hashes"}),"\n",(0,t.jsx)(n.p,{children:"T-Ruby can infer hash types from their contents:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_inference.trb"',children:'# Inferred as Hash<Symbol, String>\nuser = {\n  name: "Alice",\n  role: "admin"\n}\n\n# Inferred as Hash<String, Integer>\nscores = {\n  "alice" => 100,\n  "bob" => 95\n}\n\n# For empty hashes, you must provide a type annotation\nconfig: Hash<Symbol, String> = {}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"hash-operations",children:"Hash Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_operations.trb"',children:'def get_value(hash: Hash<Symbol, String>, key: Symbol): String | nil\n  hash[key]\nend\n\ndef set_value(hash: Hash<Symbol, Integer>, key: Symbol, value: Integer)\n  hash[key] = value\nend\n\ndef has_key(hash: Hash<String, Integer>, key: String): Boolean\n  hash.key?(key)\nend\n\ndef hash_size(hash: Hash<Symbol, String>): Integer\n  hash.size\nend\n\n# Usage\nconfig: Hash<Symbol, String> = { mode: "production", version: "1.0" }\n\nvalue: String | nil = get_value(config, :mode)  # "production"\nexists: Boolean = has_key({ "a" => 1 }, "a")  # true\ncount: Integer = hash_size(config)  # 2\n'})}),"\n",(0,t.jsx)(n.h3,{id:"iterating-over-hashes",children:"Iterating Over Hashes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_iteration.trb"',children:'def print_hash(hash: Hash<Symbol, String>)\n  hash.each do |key, value|\n    puts "#{key}: #{value}"\n  end\nend\n\ndef get_keys(hash: Hash<String, Integer>): String[]\n  hash.keys\nend\n\ndef get_values(hash: Hash<Symbol, Integer>): Integer[]\n  hash.values\nend\n\ndef transform_values(hash: Hash<Symbol, Integer>): Hash<Symbol, Integer>\n  hash.transform_values { |v| v * 2 }\nend\n\nscores: Hash<String, Integer> = { "alice" => 95, "bob" => 88 }\n\nkeys: String[] = get_keys(scores)  # ["alice", "bob"]\nvalues: Integer[] = get_values({ a: 1, b: 2 })  # [1, 2]\n\ndoubled: Hash<Symbol, Integer> = transform_values({ a: 5, b: 10 })\n# { a: 10, b: 20 }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"hash-transformation-methods",children:"Hash Transformation Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_transform.trb"',children:'def merge_hashes(\n  hash1: Hash<Symbol, String>,\n  hash2: Hash<Symbol, String>\n): Hash<Symbol, String>\n  hash1.merge(hash2)\nend\n\ndef select_entries(\n  hash: Hash<String, Integer>,\n  threshold: Integer\n): Hash<String, Integer>\n  hash.select { |k, v| v >= threshold }\nend\n\ndef invert_hash(hash: Hash<String, Integer>): Hash<Integer, String>\n  hash.invert\nend\n\nh1: Hash<Symbol, String> = { a: "1", b: "2" }\nh2: Hash<Symbol, String> = { b: "3", c: "4" }\n\nmerged: Hash<Symbol, String> = merge_hashes(h1, h2)\n# { a: "1", b: "3", c: "4" }\n\nscores: Hash<String, Integer> = { "alice" => 95, "bob" => 85, "charlie" => 90 }\nhigh_scores: Hash<String, Integer> = select_entries(scores, 90)\n# { "alice" => 95, "charlie" => 90 }\n\ninverted: Hash<Integer, String> = invert_hash({ "a" => 1, "b" => 2 })\n# { 1 => "a", 2 => "b" }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nested-hashes",children:"Nested Hashes"}),"\n",(0,t.jsx)(n.p,{children:"Hashes can contain other hashes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="nested_hashes.trb"',children:'# Hash containing hashes\ndef create_user(\n  name: String,\n  age: Integer,\n  email: String\n): Hash<Symbol, String | Integer | Hash<Symbol, String>>\n  {\n    name: name,\n    age: age,\n    contact: {\n      email: email,\n      phone: "555-0100"\n    }\n  }\nend\n\ndef get_nested_value(\n  data: Hash<Symbol, String | Hash<Symbol, String>>,\n  outer_key: Symbol,\n  inner_key: Symbol\n): String | nil\n  outer = data[outer_key]\n  if outer.is_a?(Hash)\n    outer[inner_key]\n  else\n    nil\n  end\nend\n\nuser = create_user("Alice", 30, "alice@example.com")\n# {\n#   name: "Alice",\n#   age: 30,\n#   contact: { email: "alice@example.com", phone: "555-0100" }\n# }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"working-with-union-types-in-collections",children:"Working with Union Types in Collections"}),"\n",(0,t.jsx)(n.p,{children:"Collections can hold multiple types using union types:"}),"\n",(0,t.jsx)(n.h3,{id:"arrays-with-union-types",children:"Arrays with Union Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_unions.trb"',children:'# Array that can contain strings or integers\ndef create_mixed_array(): (String | Integer)[]\n  ["alice", 42, "bob", 100]\nend\n\ndef sum_numbers_from_mixed(items: (String | Integer)[]): Integer\n  total = 0\n\n  items.each do |item|\n    if item.is_a?(Integer)\n      total += item\n    end\n  end\n\n  total\nend\n\nmixed: (String | Integer)[] = create_mixed_array()\nsum: Integer = sum_numbers_from_mixed(mixed)  # 142\n'})}),"\n",(0,t.jsx)(n.h3,{id:"hashes-with-union-types",children:"Hashes with Union Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_unions.trb"',children:'# Hash with mixed value types\ndef create_config(): Hash<Symbol, String | Integer | Boolean>\n  {\n    host: "localhost",\n    port: 3000,\n    ssl: true,\n    timeout: 30\n  }\nend\n\ndef get_config_value(\n  config: Hash<Symbol, String | Integer | Boolean>,\n  key: Symbol\n): String | Integer | Boolean | nil\n  config[key]\nend\n\ndef get_port(config: Hash<Symbol, String | Integer | Boolean>): Integer | nil\n  port = config[:port]\n  if port.is_a?(Integer)\n    port\n  else\n    nil\n  end\nend\n\nconfig = create_config()\nport: Integer | nil = get_port(config)  # 3000\n'})}),"\n",(0,t.jsx)(n.h2,{id:"practical-example-data-processing",children:"Practical Example: Data Processing"}),"\n",(0,t.jsx)(n.p,{children:"Here's a comprehensive example combining arrays and hashes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="data_processing.trb"',children:'class DataProcessor\n  def initialize()\n    @records: Hash<Symbol, String | Integer>[] = []\n  end\n\n  def add_record(name: String, age: Integer, score: Integer)\n    record: Hash<Symbol, String | Integer> = {\n      name: name,\n      age: age,\n      score: score\n    }\n    @records << record\n  end\n\n  def get_all_names(): String[]\n    names: String[] = []\n\n    @records.each do |record|\n      name = record[:name]\n      if name.is_a?(String)\n        names << name\n      end\n    end\n\n    names\n  end\n\n  def get_average_score(): Float\n    return 0.0 if @records.empty?\n\n    total = 0\n\n    @records.each do |record|\n      score = record[:score]\n      if score.is_a?(Integer)\n        total += score\n      end\n    end\n\n    total.to_f / @records.length\n  end\n\n  def get_top_scorers(threshold: Integer): String[]\n    top_scorers: String[] = []\n\n    @records.each do |record|\n      score = record[:score]\n      name = record[:name]\n\n      if score.is_a?(Integer) && name.is_a?(String) && score >= threshold\n        top_scorers << name\n      end\n    end\n\n    top_scorers\n  end\n\n  def group_by_age(): Hash<Integer, String[]>\n    groups: Hash<Integer, String[]> = {}\n\n    @records.each do |record|\n      age = record[:age]\n      name = record[:name]\n\n      if age.is_a?(Integer) && name.is_a?(String)\n        if groups[age].nil?\n          groups[age] = []\n        end\n        groups[age] << name\n      end\n    end\n\n    groups\n  end\n\n  def get_statistics(): Hash<Symbol, Float | Integer>\n    count = @records.length\n    avg = get_average_score()\n\n    max_score = 0\n    @records.each do |record|\n      score = record[:score]\n      if score.is_a?(Integer) && score > max_score\n        max_score = score\n      end\n    end\n\n    {\n      count: count,\n      average: avg,\n      max: max_score\n    }\n  end\nend\n\n# Usage\nprocessor = DataProcessor.new()\n\nprocessor.add_record("Alice", 25, 95)\nprocessor.add_record("Bob", 30, 88)\nprocessor.add_record("Charlie", 25, 92)\n\nnames: String[] = processor.get_all_names()\n# ["Alice", "Bob", "Charlie"]\n\navg: Float = processor.get_average_score()\n# 91.67\n\ntop: String[] = processor.get_top_scorers(90)\n# ["Alice", "Charlie"]\n\nby_age: Hash<Integer, String[]> = processor.group_by_age()\n# { 25 => ["Alice", "Charlie"], 30 => ["Bob"] }\n\nstats: Hash<Symbol, Float | Integer> = processor.get_statistics()\n# { count: 3, average: 91.67, max: 95 }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"building-arrays-dynamically",children:"Building Arrays Dynamically"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="array_building.trb"',children:'def build_range(start: Integer, stop: Integer): Integer[]\n  result: Integer[] = []\n\n  i = start\n  while i <= stop\n    result << i\n    i += 1\n  end\n\n  result\nend\n\ndef filter_and_transform(\n  numbers: Integer[],\n  threshold: Integer\n): String[]\n  result: String[] = []\n\n  numbers.each do |n|\n    if n > threshold\n      result << "High: #{n}"\n    end\n  end\n\n  result\nend\n\nrange: Integer[] = build_range(1, 5)  # [1, 2, 3, 4, 5]\nfiltered: String[] = filter_and_transform([10, 5, 20, 3], 8)\n# ["High: 10", "High: 20"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"building-hashes-dynamically",children:"Building Hashes Dynamically"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_building.trb"',children:'def count_occurrences(words: String[]): Hash<String, Integer>\n  counts: Hash<String, Integer> = {}\n\n  words.each do |word|\n    current = counts[word]\n    if current.nil?\n      counts[word] = 1\n    else\n      counts[word] = current + 1\n    end\n  end\n\n  counts\nend\n\ndef index_by_property(\n  items: Hash<Symbol, String>[],\n  key: Symbol\n): Hash<String, Hash<Symbol, String>>\n  index: Hash<String, Hash<Symbol, String>> = {}\n\n  items.each do |item|\n    key_value = item[key]\n    if key_value.is_a?(String)\n      index[key_value] = item\n    end\n  end\n\n  index\nend\n\nwords: String[] = ["apple", "banana", "apple", "cherry", "banana", "apple"]\ncounts: Hash<String, Integer> = count_occurrences(words)\n# { "apple" => 3, "banana" => 2, "cherry" => 1 }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,t.jsx)(n.h3,{id:"empty-collections-need-type-annotations",children:"Empty Collections Need Type Annotations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="empty_collections.trb"',children:"# This won't work - type cannot be inferred\n# items = []  # Error!\n\n# Always annotate empty collections\nitems: String[] = []\nconfig: Hash<Symbol, Integer> = {}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mutating-collections",children:"Mutating Collections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="mutation.trb"',children:'def add_item_wrong(items: String[]): String[]\n  # This mutates the original array\n  items << "new"\n  items\nend\n\ndef add_item_safe(items: String[]): String[]\n  # Create a copy first\n  new_items = items.dup\n  new_items << "new"\n  new_items\nend\n\noriginal: String[] = ["a", "b"]\nresult1 = add_item_wrong(original)\n# original is now ["a", "b", "new"]!\n\noriginal2: String[] = ["a", "b"]\nresult2 = add_item_safe(original2)\n# original2 is still ["a", "b"]\n'})}),"\n",(0,t.jsx)(n.h3,{id:"hash-key-types-matter",children:"Hash Key Types Matter"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",metastring:'title="hash_keys.trb"',children:'# Symbol keys and String keys are different!\ndef demonstrate_key_types()\n  hash: Hash<Symbol | String, Integer> = {}\n\n  hash[:name] = 1  # Symbol key\n  hash["name"] = 2  # String key\n\n  # These are different entries!\n  hash[:name]  # Returns 1\n  hash["name"]  # Returns 2\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Arrays and Hashes are essential collection types in T-Ruby:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Arrays"})," use ",(0,t.jsx)(n.code,{children:"T[]"})," syntax (shorthand) or ",(0,t.jsx)(n.code,{children:"Array<T>"})," for homogeneous collections"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hashes"})," use ",(0,t.jsx)(n.code,{children:"Hash<K, V>"})," syntax for key-value pairs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type inference"})," works for non-empty collections"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Empty collections"})," always require type annotations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Union types"})," allow mixed-type collections: ",(0,t.jsx)(n.code,{children:"(String | Integer)[]"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nested arrays"})," use multiple brackets: ",(0,t.jsx)(n.code,{children:"Integer[][]"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nested structures"})," combine arrays and hashes for complex data"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Understanding these collection types is crucial for organizing data in T-Ruby applications. In the next chapter, you'll learn about union types in more detail."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}}}]);