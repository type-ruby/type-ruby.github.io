"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[9721],{5172(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>o});var r=t(9185),i=t(5656),s=t(6145);const d={slug:"keyword-arguments-type-definitions",title:"Handling Keyword Arguments in T-Ruby",authors:["yhk1038"],tags:["tutorial","syntax","keyword-arguments"]},l=void 0,a={authorsImageUrls:[void 0]},o=[{value:"The Problem: Syntax Collision",id:"the-problem-syntax-collision",level:2},{value:"The Solution: A Simple Rule",id:"the-solution-a-simple-rule",level:2},{value:"Pattern 1: Keyword Arguments with <code>{ }</code>",id:"pattern-1-keyword-arguments-with--",level:2},{value:"Key Points",id:"key-points",level:3},{value:"Pattern 2: Hash Literal with Variable Name",id:"pattern-2-hash-literal-with-variable-name",level:2},{value:"Pattern 3: Double Splat with <code>**</code>",id:"pattern-3-double-splat-with-",level:2},{value:"Mixing Positional and Keyword Arguments",id:"mixing-positional-and-keyword-arguments",level:2},{value:"Using Interfaces",id:"using-interfaces",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Quick Reference",id:"quick-reference",level:2},{value:"Design History",id:"design-history",level:2},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["When we first released T-Ruby, one of the most frequently asked questions was: ",(0,i.jsx)(n.strong,{children:'"How do I define keyword arguments?"'})," \u2014 this was ",(0,i.jsx)(n.a,{href:"https://github.com/aspect-build/t-ruby/issues/19",children:"Issue #19"})," - and it turned out to be one of the most important design decisions for the language."]}),"\n",(0,i.jsx)(n.h2,{id:"the-problem-syntax-collision",children:"The Problem: Syntax Collision"}),"\n",(0,i.jsxs)(n.p,{children:["In T-Ruby, type annotations use the colon syntax: ",(0,i.jsx)(n.code,{children:"name: Type"}),". But Ruby's keyword arguments also use a colon: ",(0,i.jsx)(n.code,{children:"name: value"}),". This creates a fundamental conflict."]}),"\n",(0,i.jsx)(n.p,{children:"Consider this T-Ruby code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"def foo(x: String, y: Integer = 10)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Is ",(0,i.jsx)(n.code,{children:"x"})," a keyword argument or a positional argument with a type annotation? In early T-Ruby, this was always treated as a ",(0,i.jsx)(n.strong,{children:"positional argument"})," - you'd call it as ",(0,i.jsx)(n.code,{children:'foo("hi", 20)'}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["But what if you wanted actual keyword arguments that you call as ",(0,i.jsx)(n.code,{children:'foo(x: "hi", y: 20)'}),"?"]}),"\n",(0,i.jsx)(n.h2,{id:"the-solution-a-simple-rule",children:"The Solution: A Simple Rule"}),"\n",(0,i.jsxs)(n.p,{children:["T-Ruby solves this with one elegant rule: ",(0,i.jsx)(n.strong,{children:"the presence of a variable name determines the meaning"}),"."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Syntax"}),(0,i.jsx)(n.th,{children:"Meaning"}),(0,i.jsx)(n.th,{children:"Compiles To"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ name: String }"})}),(0,i.jsx)(n.td,{children:"Keyword argument (destructuring)"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"def foo(name:)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"config: { host: String }"})}),(0,i.jsx)(n.td,{children:"Hash literal parameter"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"def foo(config)"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"**opts: Type"})}),(0,i.jsx)(n.td,{children:"Double splat for forwarding"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"def foo(**opts)"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Let's explore each pattern."}),"\n",(0,i.jsxs)(n.h2,{id:"pattern-1-keyword-arguments-with--",children:["Pattern 1: Keyword Arguments with ",(0,i.jsx)(n.code,{children:"{ }"})]}),"\n",(0,i.jsxs)(n.p,{children:["When you use curly braces ",(0,i.jsx)(n.strong,{children:"without a variable name"}),", T-Ruby treats it as keyword argument destructuring:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# T-Ruby\ndef greet({ name: String, prefix: String = "Hello" }): String\n  "#{prefix}, #{name}!"\nend\n\n# How to call it\ngreet(name: "Alice")\ngreet(name: "Bob", prefix: "Hi")\n'})}),"\n",(0,i.jsx)(n.p,{children:"This compiles to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Ruby\ndef greet(name:, prefix: "Hello")\n  "#{prefix}, #{name}!"\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"And generates this RBS signature:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rbs",children:"def greet: (name: String, ?prefix: String) -> String\n"})}),"\n",(0,i.jsx)(n.h3,{id:"key-points",children:"Key Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Wrap keyword arguments in ",(0,i.jsx)(n.code,{children:"{ }"})]}),"\n",(0,i.jsxs)(n.li,{children:["Each argument has a type: ",(0,i.jsx)(n.code,{children:"name: String"})]}),"\n",(0,i.jsxs)(n.li,{children:["Default values work naturally: ",(0,i.jsx)(n.code,{children:'prefix: String = "Hello"'})]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"?"})," in RBS indicates optional parameters"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"pattern-2-hash-literal-with-variable-name",children:"Pattern 2: Hash Literal with Variable Name"}),"\n",(0,i.jsx)(n.p,{children:"When you add a variable name before the braces, T-Ruby treats it as a Hash parameter:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# T-Ruby\ndef process(config: { host: String, port: Integer }): String\n  "#{config[:host]}:#{config[:port]}"\nend\n\n# How to call it\nprocess(config: { host: "localhost", port: 8080 })\n'})}),"\n",(0,i.jsx)(n.p,{children:"This compiles to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Ruby\ndef process(config)\n  "#{config[:host]}:#{config[:port]}"\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"Use this pattern when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You want to pass an entire Hash object"}),"\n",(0,i.jsxs)(n.li,{children:["You need to access values with ",(0,i.jsx)(n.code,{children:"config[:key]"})," syntax"]}),"\n",(0,i.jsx)(n.li,{children:"The Hash might be stored or passed to other methods"}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"pattern-3-double-splat-with-",children:["Pattern 3: Double Splat with ",(0,i.jsx)(n.code,{children:"**"})]}),"\n",(0,i.jsx)(n.p,{children:"For collecting arbitrary keyword arguments or forwarding them to other methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# T-Ruby\ndef with_transaction(**config: DbConfig): String\n  conn = connect_db(**config)\n  "BEGIN; #{conn}; COMMIT;"\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"This compiles to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Ruby\ndef with_transaction(**config)\n  conn = connect_db(**config)\n  "BEGIN; #{conn}; COMMIT;"\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"**"})," is preserved because Ruby's ",(0,i.jsx)(n.code,{children:"opts: Type"})," compiles to ",(0,i.jsx)(n.code,{children:"def foo(opts:)"})," (a single keyword argument named ",(0,i.jsx)(n.code,{children:"opts"}),"), not ",(0,i.jsx)(n.code,{children:"def foo(**opts)"})," (collecting all keyword arguments)."]}),"\n",(0,i.jsx)(n.h2,{id:"mixing-positional-and-keyword-arguments",children:"Mixing Positional and Keyword Arguments"}),"\n",(0,i.jsx)(n.p,{children:"You can combine positional arguments with keyword arguments:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# T-Ruby\ndef mixed(id: Integer, { name: String, age: Integer = 0 }): String\n  "#{id}: #{name} (#{age})"\nend\n\n# How to call it\nmixed(1, name: "Alice")\nmixed(2, name: "Bob", age: 30)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Compiles to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Ruby\ndef mixed(id, name:, age: 0)\n  "#{id}: #{name} (#{age})"\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"using-interfaces",children:"Using Interfaces"}),"\n",(0,i.jsx)(n.p,{children:"For complex configurations, define an interface and reference it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Define the interface\ninterface ConnectionOptions\n  host: String\n  port?: Integer\n  timeout?: Integer\nend\n\n# Destructuring with interface reference - specify field names with defaults\ndef connect({ host:, port: 8080, timeout: 30 }: ConnectionOptions): String\n  "#{host}:#{port}"\nend\n\n# How to call it\nconnect(host: "localhost")\nconnect(host: "localhost", port: 3000)\n\n# Double splat - for forwarding keyword arguments\ndef forward(**opts: ConnectionOptions): String\n  connect(**opts)\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"Note that when using interface references, you must explicitly list the field names in the destructuring pattern. Default values are specified in the function definition, not in the interface."}),"\n",(0,i.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a real-world example combining multiple patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# T-Ruby\nclass ApiClient\n  def initialize({ base_url: String, timeout: Integer = 30 })\n    @base_url = base_url\n    @timeout = timeout\n  end\n\n  def get({ path: String }): String\n    "#{@base_url}#{path}"\n  end\n\n  def post(path: String, { body: String, headers: Hash = {} }): String\n    "POST #{@base_url}#{path}"\n  end\nend\n\n# Usage\nclient = ApiClient.new(base_url: "https://api.example.com")\nclient.get(path: "/users")\nclient.post("/users", body: "{}", headers: { "Content-Type" => "application/json" })\n'})}),"\n",(0,i.jsx)(n.p,{children:"This compiles to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Ruby\nclass ApiClient\n  def initialize(base_url:, timeout: 30)\n    @base_url = base_url\n    @timeout = timeout\n  end\n\n  def get(path:)\n    "#{@base_url}#{path}"\n  end\n\n  def post(path, body:, headers: {})\n    "POST #{@base_url}#{path}"\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"What You Want"}),(0,i.jsx)(n.th,{children:"T-Ruby Syntax"}),(0,i.jsx)(n.th,{children:"Ruby Output"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Required keyword arg"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ name: String }"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"name:"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Optional keyword arg"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'{ name: String = "default" }'})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'name: "default"'})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Multiple keyword args"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ a: String, b: Integer }"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"a:, b:"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Hash parameter"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"opts: { a: String }"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"opts"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Double splat"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"**opts: Type"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"**opts"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Mixed"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"id: Integer, { name: String }"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"id, name:"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"design-history",children:"Design History"}),"\n",(0,i.jsxs)(n.p,{children:["When we first announced T-Ruby, the initial syntax used ",(0,i.jsx)(n.code,{children:"**{}"})," for keyword arguments:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# Initial design (rejected)\ndef greet(**{ name: String, prefix: String = "Hello" }): String\n'})}),"\n",(0,i.jsx)(n.p,{children:"Community feedback pointed out this was too complex. We explored several alternatives:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Alternative"}),(0,i.jsx)(n.th,{children:"Example"}),(0,i.jsx)(n.th,{children:"Result"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semicolon"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"; name: String"})}),(0,i.jsx)(n.td,{children:"Rejected (worse readability)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Double colon"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"name:: String"})}),(0,i.jsxs)(n.td,{children:["Rejected (",(0,i.jsx)(n.code,{children:"::"})," conflicts with Ruby constants)"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"named"})," keyword"]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"named name: String"})}),(0,i.jsx)(n.td,{children:"Considered"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Braces only"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"{ name: String }"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Adopted"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"The final design uses a simple rule: the presence of a variable name determines the meaning. This creates a clean, intuitive syntax that doesn't require new keywords."}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"T-Ruby's keyword argument syntax is designed to be intuitive:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Wrap in ",(0,i.jsx)(n.code,{children:"{ }"})]})," for keyword arguments"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Add a variable name"})," for Hash parameters"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"**"})]})," for double splat forwarding"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This simple rule eliminates the confusion between type annotations and Ruby keyword syntax, giving you the best of both worlds: TypeScript-style type safety with Ruby's expressive keyword arguments."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Keyword argument support is available in T-Ruby v0.0.41 and later. Try it out and let us know what you think!"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},6145(e,n,t){t.d(n,{R:()=>d,x:()=>l});var r=t(7140);const i={},s=r.createContext(i);function d(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(s.Provider,{value:n},e.children)}},9185(e){e.exports=JSON.parse('{"permalink":"/blog/keyword-arguments-type-definitions","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/blog/2025-12-29-keyword-arguments/index.md","source":"@site/blog/2025-12-29-keyword-arguments/index.md","title":"Handling Keyword Arguments in T-Ruby","description":"When we first released T-Ruby, one of the most frequently asked questions was: \\"How do I define keyword arguments?\\" \u2014 this was Issue #19 - and it turned out to be one of the most important design decisions for the language.","date":"2025-12-29T00:00:00.000Z","tags":[{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"},{"inline":true,"label":"syntax","permalink":"/blog/tags/syntax"},{"inline":true,"label":"keyword-arguments","permalink":"/blog/tags/keyword-arguments"}],"readingTime":4.74,"hasTruncateMarker":true,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"keyword-arguments-type-definitions","title":"Handling Keyword Arguments in T-Ruby","authors":["yhk1038"],"tags":["tutorial","syntax","keyword-arguments"]},"unlisted":false,"nextItem":{"title":"Building TypeScript-Style Type Inference for T-Ruby","permalink":"/blog/typescript-style-type-inference"}}')}}]);