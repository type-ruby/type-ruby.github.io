"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[7356],{6549:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"learn/everyday-types/union-types","title":"Union Types","description":"Combining multiple types with union","source":"@site/docs/learn/everyday-types/union-types.md","sourceDirName":"learn/everyday-types","slug":"/learn/everyday-types/union-types","permalink":"/docs/learn/everyday-types/union-types","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/everyday-types/union-types.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Union Types","description":"Combining multiple types with union"},"sidebar":"docsSidebar","previous":{"title":"Arrays and Hashes","permalink":"/docs/learn/everyday-types/arrays-and-hashes"},"next":{"title":"Type Narrowing","permalink":"/docs/learn/everyday-types/type-narrowing"}}');var r=t(2714),s=t(8885);const l={sidebar_position:3,title:"Union Types",description:"Combining multiple types with union"},a="Union Types",o={},d=[{value:"What Are Union Types?",id:"what-are-union-types",level:2},{value:"Why Use Union Types?",id:"why-use-union-types",level:2},{value:"1. Optional Values",id:"1-optional-values",level:3},{value:"2. Multiple Valid Input Types",id:"2-multiple-valid-input-types",level:3},{value:"3. Different Return Types",id:"3-different-return-types",level:3},{value:"Working with Union Types",id:"working-with-union-types",level:2},{value:"Type Checking with <code>is_a?</code>",id:"type-checking-with-is_a",level:3},{value:"Checking for nil",id:"checking-for-nil",level:3},{value:"Multiple Type Checks",id:"multiple-type-checks",level:3},{value:"Union Types with Collections",id:"union-types-with-collections",level:2},{value:"Arrays with Union Element Types",id:"arrays-with-union-element-types",level:3},{value:"Hashes with Union Value Types",id:"hashes-with-union-value-types",level:3},{value:"Common Union Type Patterns",id:"common-union-type-patterns",level:2},{value:"Pattern 1: Success or Error",id:"pattern-1-success-or-error",level:3},{value:"Pattern 2: Default Values",id:"pattern-2-default-values",level:3},{value:"Pattern 3: Type Coercion",id:"pattern-3-type-coercion",level:3},{value:"Pattern 4: Polymorphic Functions",id:"pattern-4-polymorphic-functions",level:3},{value:"Nested Union Types",id:"nested-union-types",level:2},{value:"Unions in Unions",id:"unions-in-unions",level:3},{value:"Unions with Complex Types",id:"unions-with-complex-types",level:3},{value:"Practical Example: Configuration System",id:"practical-example-configuration-system",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Unions Simple",id:"1-keep-unions-simple",level:3},{value:"2. Use nil Unions for Optional Values",id:"2-use-nil-unions-for-optional-values",level:3},{value:"3. Check Types in Consistent Order",id:"3-check-types-in-consistent-order",level:3},{value:"4. Document Union Type Semantics",id:"4-document-union-type-semantics",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Forgetting Type Checks",id:"forgetting-type-checks",level:3},{value:"Assuming Type After Mutation",id:"assuming-type-after-mutation",level:3},{value:"Summary",id:"summary",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{DocsBadge:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t,{}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"union-types",children:"Union Types"})}),"\n",(0,r.jsx)(n.p,{children:"Union types allow a value to be one of several different types. They are essential for modeling data that can legitimately have multiple forms. This chapter will teach you how to use union types effectively in T-Ruby."}),"\n",(0,r.jsx)(n.h2,{id:"what-are-union-types",children:"What Are Union Types?"}),"\n",(0,r.jsxs)(n.p,{children:["A union type represents a value that can be one of several specified types. In T-Ruby, you create union types using the pipe (",(0,r.jsx)(n.code,{children:"|"}),") operator:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="union_basics.trb"',children:'# This variable can be either a String or nil\nname: String | nil = "Alice"\n\n# This can be a String or an Integer\nid: String | Integer = "user-123"\n\n# This can be one of three types\nvalue: String | Integer | Boolean = true\n'})}),"\n",(0,r.jsx)(n.h2,{id:"why-use-union-types",children:"Why Use Union Types?"}),"\n",(0,r.jsx)(n.p,{children:"Union types are useful in several scenarios:"}),"\n",(0,r.jsx)(n.h3,{id:"1-optional-values",children:"1. Optional Values"}),"\n",(0,r.jsxs)(n.p,{children:["The most common use is combining a type with ",(0,r.jsx)(n.code,{children:"nil"})," to represent optional values:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="optional_values.trb"',children:'def find_user(id: Integer): String | nil\n  return nil if id < 0\n  "User #{id}"\nend\n\n# The result might be nil\nuser: String | nil = find_user(1)  # "User 1"\nno_user: String | nil = find_user(-1)  # nil\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-multiple-valid-input-types",children:"2. Multiple Valid Input Types"}),"\n",(0,r.jsx)(n.p,{children:"When a function can accept different types of input:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="multiple_inputs.trb"',children:'def format_id(id: String | Integer): String\n  if id.is_a?(Integer)\n    "ID-#{id}"\n  else\n    id.upcase\n  end\nend\n\nformatted1: String = format_id(123)  # "ID-123"\nformatted2: String = format_id("abc")  # "ABC"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-different-return-types",children:"3. Different Return Types"}),"\n",(0,r.jsx)(n.p,{children:"When a function might return different types based on conditions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="different_returns.trb"',children:'def parse_value(input: String): String | Integer | Boolean\n  if input == "true" || input == "false"\n    input == "true"\n  elsif input.to_i.to_s == input\n    input.to_i\n  else\n    input\n  end\nend\n\nresult1 = parse_value("42")  # 42 (Integer)\nresult2 = parse_value("true")  # true (Boolean)\nresult3 = parse_value("hello")  # "hello" (String)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"working-with-union-types",children:"Working with Union Types"}),"\n",(0,r.jsxs)(n.h3,{id:"type-checking-with-is_a",children:["Type Checking with ",(0,r.jsx)(n.code,{children:"is_a?"})]}),"\n",(0,r.jsx)(n.p,{children:"To safely use a value with a union type, you need to check which type it actually is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="type_checking.trb"',children:'def process_value(value: String | Integer): String\n  if value.is_a?(String)\n    # Inside this block, T-Ruby knows value is a String\n    value.upcase\n  else\n    # Here, T-Ruby knows value must be an Integer\n    value.to_s\n  end\nend\n\nresult1: String = process_value("hello")  # "HELLO"\nresult2: String = process_value(42)  # "42"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"checking-for-nil",children:"Checking for nil"}),"\n",(0,r.jsxs)(n.p,{children:["When working with optional values, always check for ",(0,r.jsx)(n.code,{children:"nil"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="nil_checking.trb"',children:'def get_length(text: String | nil): Integer\n  if text.nil?\n    0\n  else\n    # Here, T-Ruby knows text is a String\n    text.length\n  end\nend\n\nlen1: Integer = get_length("hello")  # 5\nlen2: Integer = get_length(nil)  # 0\n\n# Alternative using the safe navigation operator\ndef get_length_safe(text: String | nil): Integer | nil\n  text&.length\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"multiple-type-checks",children:"Multiple Type Checks"}),"\n",(0,r.jsx)(n.p,{children:"When you have more than two types in a union:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="multiple_checks.trb"',children:'def describe_value(value: String | Integer | Boolean): String\n  if value.is_a?(String)\n    "Text: #{value}"\n  elsif value.is_a?(Integer)\n    "Number: #{value}"\n  elsif value.is_a?(Boolean)\n    "Boolean: #{value}"\n  else\n    "Unknown"\n  end\nend\n\ndesc1: String = describe_value("hello")  # "Text: hello"\ndesc2: String = describe_value(42)  # "Number: 42"\ndesc3: String = describe_value(true)  # "Boolean: true"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"union-types-with-collections",children:"Union Types with Collections"}),"\n",(0,r.jsx)(n.p,{children:"Union types are commonly used with arrays and hashes:"}),"\n",(0,r.jsx)(n.h3,{id:"arrays-with-union-element-types",children:"Arrays with Union Element Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="union_arrays.trb"',children:'# Array that can contain strings or integers\ndef create_mixed_list(): (String | Integer)[]\n  ["Alice", 1, "Bob", 2, "Charlie", 3]\nend\n\ndef sum_numbers(items: (String | Integer)[]): Integer\n  total = 0\n\n  items.each do |item|\n    if item.is_a?(Integer)\n      total += item\n    end\n  end\n\n  total\nend\n\ndef get_strings(items: (String | Integer)[]): String[]\n  result: String[] = []\n\n  items.each do |item|\n    if item.is_a?(String)\n      result << item\n    end\n  end\n\n  result\nend\n\nmixed: (String | Integer)[] = create_mixed_list()\nsum: Integer = sum_numbers(mixed)  # 6\nstrings: String[] = get_strings(mixed)  # ["Alice", "Bob", "Charlie"]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"hashes-with-union-value-types",children:"Hashes with Union Value Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="union_hashes.trb"',children:'# Hash with different value types\ndef create_config(): Hash<Symbol, String | Integer | Boolean>\n  {\n    host: "localhost",\n    port: 3000,\n    debug: true,\n    timeout: 30,\n    environment: "development"\n  }\nend\n\ndef get_string_value(\n  config: Hash<Symbol, String | Integer | Boolean>,\n  key: Symbol\n): String | nil\n  value = config[key]\n\n  if value.is_a?(String)\n    value\n  else\n    nil\n  end\nend\n\ndef get_integer_value(\n  config: Hash<Symbol, String | Integer | Boolean>,\n  key: Symbol\n): Integer | nil\n  value = config[key]\n\n  if value.is_a?(Integer)\n    value\n  else\n    nil\n  end\nend\n\nconfig = create_config()\nhost: String | nil = get_string_value(config, :host)  # "localhost"\nport: Integer | nil = get_integer_value(config, :port)  # 3000\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-union-type-patterns",children:"Common Union Type Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"pattern-1-success-or-error",children:"Pattern 1: Success or Error"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="result_pattern.trb"',children:'def divide_safe(a: Float, b: Float): Float | String\n  if b == 0.0\n    "Error: Division by zero"\n  else\n    a / b\n  end\nend\n\ndef process_result(result: Float | String): String\n  if result.is_a?(Float)\n    "Result: #{result}"\n  else\n    # It\'s an error message\n    result\n  end\nend\n\nresult1 = divide_safe(10.0, 2.0)  # 5.0\nresult2 = divide_safe(10.0, 0.0)  # "Error: Division by zero"\n\nmessage1: String = process_result(result1)  # "Result: 5.0"\nmessage2: String = process_result(result2)  # "Error: Division by zero"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-2-default-values",children:"Pattern 2: Default Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="default_pattern.trb"',children:'def get_value_or_default(\n  value: String | nil,\n  default: String\n): String\n  if value.nil?\n    default\n  else\n    value\n  end\nend\n\n# Using || for simpler cases\ndef get_or_default_short(value: String | nil, default: String): String\n  value || default\nend\n\nresult1: String = get_value_or_default("hello", "default")  # "hello"\nresult2: String = get_value_or_default(nil, "default")  # "default"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-3-type-coercion",children:"Pattern 3: Type Coercion"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="coercion_pattern.trb"',children:'def to_integer(value: String | Integer): Integer\n  if value.is_a?(Integer)\n    value\n  else\n    value.to_i\n  end\nend\n\ndef to_string(value: String | Integer | Boolean): String\n  if value.is_a?(String)\n    value\n  else\n    value.to_s\n  end\nend\n\nnum1: Integer = to_integer(42)  # 42\nnum2: Integer = to_integer("42")  # 42\n\nstr1: String = to_string("hello")  # "hello"\nstr2: String = to_string(42)  # "42"\nstr3: String = to_string(true)  # "true"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pattern-4-polymorphic-functions",children:"Pattern 4: Polymorphic Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="polymorphic_pattern.trb"',children:'def repeat(value: String | Integer, times: Integer): String\n  if value.is_a?(String)\n    value * times\n  else\n    # Repeat the number representation\n    (value.to_s + " ") * times\n  end\nend\n\nresult1: String = repeat("Ha", 3)  # "HaHaHa"\nresult2: String = repeat(42, 3)  # "42 42 42 "\n'})}),"\n",(0,r.jsx)(n.h2,{id:"nested-union-types",children:"Nested Union Types"}),"\n",(0,r.jsx)(n.p,{children:"Union types can be combined in complex ways:"}),"\n",(0,r.jsx)(n.h3,{id:"unions-in-unions",children:"Unions in Unions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="nested_unions.trb"',children:'# A value that can be a number (Integer or Float) or text (String or Symbol)\ndef process_input(value: Integer | Float | String | Symbol): String\n  if value.is_a?(Integer) || value.is_a?(Float)\n    "Number: #{value}"\n  elsif value.is_a?(String)\n    "String: #{value}"\n  else\n    "Symbol: #{value}"\n  end\nend\n\nresult1: String = process_input(42)  # "Number: 42"\nresult2: String = process_input(3.14)  # "Number: 3.14"\nresult3: String = process_input("hello")  # "String: hello"\nresult4: String = process_input(:active)  # "Symbol: active"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"unions-with-complex-types",children:"Unions with Complex Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="complex_unions.trb"',children:'# Can be a simple value or an array of values\ndef normalize_input(\n  value: String | String[]\n): String[]\n  if value.is_a?(Array)\n    value\n  else\n    [value]\n  end\nend\n\nresult1: String[] = normalize_input("hello")  # ["hello"]\nresult2: String[] = normalize_input(["a", "b"])  # ["a", "b"]\n\n# Can be a single integer or a range\ndef expand_range(value: Integer | Range): Integer[]\n  if value.is_a?(Range)\n    value.to_a\n  else\n    [value]\n  end\nend\n\nnums1: Integer[] = expand_range(5)  # [5]\nnums2: Integer[] = expand_range(1..5)  # [1, 2, 3, 4, 5]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"practical-example-configuration-system",children:"Practical Example: Configuration System"}),"\n",(0,r.jsx)(n.p,{children:"Here's a comprehensive example using union types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="config_system.trb"',children:'class ConfigManager\n  def initialize()\n    @config: Hash<String, String | Integer | Boolean | nil> = {}\n  end\n\n  def set(key: String, value: String | Integer | Boolean | nil)\n    @config[key] = value\n  end\n\n  def get_string(key: String): String | nil\n    value = @config[key]\n\n    if value.is_a?(String)\n      value\n    else\n      nil\n    end\n  end\n\n  def get_integer(key: String): Integer | nil\n    value = @config[key]\n\n    if value.is_a?(Integer)\n      value\n    else\n      nil\n    end\n  end\n\n  def get_bool(key: String): Boolean | nil\n    value = @config[key]\n\n    if value.is_a?(Boolean)\n      value\n    else\n      nil\n    end\n  end\n\n  def get_string_or_default(key: String, default: String): String\n    value = get_string(key)\n    value || default\n  end\n\n  def get_integer_or_default(key: String, default: Integer): Integer\n    value = get_integer(key)\n    value || default\n  end\n\n  def get_bool_or_default(key: String, default: Boolean): Boolean\n    value = get_bool(key)\n    if value.nil?\n      default\n    else\n      value\n    end\n  end\n\n  def to_hash(): Hash<String, String | Integer | Boolean | nil>\n    @config.dup\n  end\n\n  def parse_and_set(key: String, raw_value: String)\n    # Try to parse as boolean\n    if raw_value == "true"\n      set(key, true)\n      return\n    elsif raw_value == "false"\n      set(key, false)\n      return\n    end\n\n    # Try to parse as integer\n    int_value = raw_value.to_i\n    if int_value.to_s == raw_value\n      set(key, int_value)\n      return\n    end\n\n    # Otherwise, store as string\n    set(key, raw_value)\n  end\nend\n\n# Usage\nconfig = ConfigManager.new()\n\nconfig.set("host", "localhost")\nconfig.set("port", 3000)\nconfig.set("debug", true)\nconfig.set("optional_feature", nil)\n\nhost: String = config.get_string_or_default("host", "0.0.0.0")\n# "localhost"\n\nport: Integer = config.get_integer_or_default("port", 8080)\n# 3000\n\ndebug: Boolean = config.get_bool_or_default("debug", false)\n# true\n\ntimeout: Integer = config.get_integer_or_default("timeout", 30)\n# 30 (uses default since key doesn\'t exist)\n\n# Parsing from strings\nconfig.parse_and_set("max_connections", "100")  # Stored as Integer\nconfig.parse_and_set("enable_ssl", "true")  # Stored as Boolean\nconfig.parse_and_set("environment", "production")  # Stored as String\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-keep-unions-simple",children:"1. Keep Unions Simple"}),"\n",(0,r.jsx)(n.p,{children:"Avoid unions with too many types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="simple_unions.trb"',children:"# Good - clear and simple\ndef process(value: String | Integer): String\n  # ...\nend\n\n# Avoid - too many types to handle\ndef process_complex(\n  value: String | Integer | Float | Boolean | Symbol | nil\n): String\n  # Too many branches needed\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-use-nil-unions-for-optional-values",children:"2. Use nil Unions for Optional Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="optional_best_practice.trb"',children:'# Good - clearly optional\ndef find_item(id: Integer): String | nil\n  # ...\nend\n\n# Avoid - using empty string to mean "not found"\ndef find_item_bad(id: Integer): String\n  # Returns "" when not found - unclear!\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-check-types-in-consistent-order",children:"3. Check Types in Consistent Order"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="consistent_checks.trb"',children:'# Good - consistent pattern\ndef process(value: String | Integer): String\n  if value.is_a?(String)\n    value.upcase\n  else\n    value.to_s\n  end\nend\n\n# Also good - same pattern\ndef format(value: String | Integer): String\n  if value.is_a?(String)\n    "Text: #{value}"\n  else\n    "Number: #{value}"\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-document-union-type-semantics",children:"4. Document Union Type Semantics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="documentation.trb"',children:'# Good - clear what each type means\ndef get_status(id: Integer): String | Symbol | nil\n  # Returns:\n  # - String: Error message\n  # - Symbol: Status code (:active, :pending, etc.)\n  # - nil: Item not found\n\n  return nil if id < 0\n  return :active if id == 1\n  "Error: Invalid state"\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,r.jsx)(n.h3,{id:"forgetting-type-checks",children:"Forgetting Type Checks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="missing_checks.trb"',children:"# Wrong - doesn't check type\ndef bad_example(value: String | Integer): Integer\n  value.length  # Error! Integer doesn't have length\nend\n\n# Correct - checks type first\ndef good_example(value: String | Integer): Integer\n  if value.is_a?(String)\n    value.length\n  else\n    value\n  end\nend\n"})}),"\n",(0,r.jsx)(n.h3,{id:"assuming-type-after-mutation",children:"Assuming Type After Mutation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-trb",metastring:'title="type_mutation.trb"',children:"def risky_example(value: String | Integer)\n  if value.is_a?(String)\n    value = value.to_i  # Now it's an Integer!\n    # value is now Integer, not String\n  end\n\n  # Can't assume value is still String here\nend\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Union types in T-Ruby allow values to be one of several types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": Use the pipe operator (",(0,r.jsx)(n.code,{children:"|"}),") to combine types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Common use"}),": Making values optional with ",(0,r.jsx)(n.code,{children:"| nil"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type checking"}),": Use ",(0,r.jsx)(n.code,{children:"is_a?"})," to determine actual type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Collections"}),": Can be used with Array and Hash types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best practices"}),": Keep unions simple, check types consistently"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Union types are essential for modeling real-world data that doesn't fit into a single type. Combined with type narrowing (covered in the next chapter), they provide powerful and safe ways to handle diverse data."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8885:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var i=t(9378);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);