"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[4089],{2768(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>d,default:()=>g,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"learn/interfaces/duck-typing","title":"Duck Typing","description":"Structural typing and duck typing in T-Ruby","source":"@site/docs/learn/interfaces/duck-typing.md","sourceDirName":"learn/interfaces","slug":"/learn/interfaces/duck-typing","permalink":"/docs/learn/interfaces/duck-typing","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/interfaces/duck-typing.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Duck Typing","description":"Structural typing and duck typing in T-Ruby"},"sidebar":"docsSidebar","previous":{"title":"Implementing Interfaces","permalink":"/docs/learn/interfaces/implementing-interfaces"},"next":{"title":"Generic Functions & Classes","permalink":"/docs/learn/generics/generic-functions-classes"}}');var r=t(5656),s=t(6145);const a={sidebar_position:3,title:"Duck Typing",description:"Structural typing and duck typing in T-Ruby"},d="Duck Typing",l={},o=[{value:"Understanding Duck Typing",id:"understanding-duck-typing",level:2},{value:"Structural Type Syntax",id:"structural-type-syntax",level:2},{value:"Anonymous Structural Types",id:"anonymous-structural-types",level:2},{value:"Complex Structural Types",id:"complex-structural-types",level:2},{value:"Duck Typing vs Interfaces",id:"duck-typing-vs-interfaces",level:2},{value:"Structural Subtyping",id:"structural-subtyping",level:2},{value:"Generic Structural Types",id:"generic-structural-types",level:2},{value:"Practical Example: Plugin System",id:"practical-example-plugin-system",level:2},{value:"Practical Example: Data Pipeline",id:"practical-example-data-pipeline",level:2},{value:"Practical Example: Event System",id:"practical-example-event-system",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"When to Use Duck Typing",id:"when-to-use-duck-typing",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components},{DocsBadge:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t,{}),"\n",(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"duck-typing",children:"Duck Typing"})}),"\n",(0,r.jsx)(e.p,{children:'"If it walks like a duck and quacks like a duck, then it must be a duck." Duck typing is a form of structural typing where type compatibility is determined by the presence of methods and properties, not by explicit interface implementation. T-Ruby supports duck typing while maintaining type safety.'}),"\n",(0,r.jsx)(e.h2,{id:"understanding-duck-typing",children:"Understanding Duck Typing"}),"\n",(0,r.jsx)(e.p,{children:"In duck typing, you don't need to explicitly implement an interface\u2014you just need to have the required methods:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="duck_typing_basic.trb"',children:'# No interface needed\ndef print_object(obj: { def to_string(): String }): void\n  puts obj.to_string()\nend\n\nclass User\n  def initialize(name: String)\n    @name = name\n  end\n\n  def to_string(): String\n    "User: #{@name}"\n  end\nend\n\nclass Product\n  def initialize(name: String)\n    @name = name\n  end\n\n  def to_string(): String\n    "Product: #{@name}"\n  end\nend\n\n# Both work without implementing an interface\nuser = User.new("Alice")\nproduct = Product.new("Laptop")\n\nprint_object(user)     # "User: Alice"\nprint_object(product)  # "Product: Laptop"\n'})}),"\n",(0,r.jsx)(e.h2,{id:"structural-type-syntax",children:"Structural Type Syntax"}),"\n",(0,r.jsx)(e.p,{children:"Define structural types inline using object literal syntax:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="structural_types.trb"',children:'# Structural type definition\ntype Printable = {\n  def print(): void\n  def get_name(): String\n}\n\ndef print_item(item: Printable): void\n  puts "Printing: #{item.get_name()}"\n  item.print()\nend\n\nclass Document\n  def initialize(title: String)\n    @title = title\n  end\n\n  def print(): void\n    puts "Document: #{@title}"\n  end\n\n  def get_name(): String\n    @title\n  end\nend\n\nclass Report\n  def initialize(name: String)\n    @name = name\n  end\n\n  def print(): void\n    puts "Report: #{@name}"\n  end\n\n  def get_name(): String\n    @name\n  end\nend\n\n# Both classes satisfy the structural type\ndoc = Document.new("Manual")\nreport = Report.new("Q4 Results")\n\nprint_item(doc)\nprint_item(report)\n'})}),"\n",(0,r.jsx)(e.h2,{id:"anonymous-structural-types",children:"Anonymous Structural Types"}),"\n",(0,r.jsx)(e.p,{children:"Use structural types directly without naming them:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="anonymous_types.trb"',children:'def process_data(\n  source: { def read(): String },\n  destination: { def write(content: String): void }\n): void\n  data = source.read()\n  destination.write(data)\nend\n\nclass FileReader\n  def initialize(path: String)\n    @path = path\n  end\n\n  def read(): String\n    "File content from #{@path}"\n  end\nend\n\nclass DatabaseWriter\n  def write(content: String): void\n    puts "Writing to database: #{content}"\n  end\nend\n\nclass ConsoleWriter\n  def write(content: String): void\n    puts "Console: #{content}"\n  end\nend\n\n# Usage\nreader = FileReader.new("/path/to/file")\ndb_writer = DatabaseWriter.new\nconsole_writer = ConsoleWriter.new\n\nprocess_data(reader, db_writer)\nprocess_data(reader, console_writer)\n'})}),"\n",(0,r.jsx)(e.h2,{id:"complex-structural-types",children:"Complex Structural Types"}),"\n",(0,r.jsx)(e.p,{children:"Structural types can define multiple methods and property signatures:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="complex_structural.trb"',children:'type Repository = {\n  def find(id: Integer): Hash<String, String>?\n  def save(data: Hash<String, String>): Boolean\n  def delete(id: Integer): Boolean\n  def count(): Integer\n}\n\nclass MemoryRepository\n  def initialize()\n    @data: Hash<Integer, Hash<String, String>> = {}\n    @next_id: Integer = 1\n  end\n\n  def find(id: Integer): Hash<String, String>?\n    @data[id]\n  end\n\n  def save(data: Hash<String, String>): Boolean\n    @data[@next_id] = data\n    @next_id += 1\n    true\n  end\n\n  def delete(id: Integer): Boolean\n    if @data.key?(id)\n      @data.delete(id)\n      true\n    else\n      false\n    end\n  end\n\n  def count(): Integer\n    @data.length\n  end\nend\n\nclass FileRepository\n  def initialize(path: String)\n    @path = path\n    @data: Hash<Integer, Hash<String, String>> = {}\n  end\n\n  def find(id: Integer): Hash<String, String>?\n    @data[id]\n  end\n\n  def save(data: Hash<String, String>): Boolean\n    # Save to file\n    true\n  end\n\n  def delete(id: Integer): Boolean\n    @data.key?(id) && @data.delete(id) != nil\n  end\n\n  def count(): Integer\n    @data.length\n  end\nend\n\ndef use_repository(repo: Repository): void\n  repo.save({ "name" => "Test" })\n  puts "Repository has #{repo.count()} items"\nend\n\n# Both work with the same function\nmemory_repo = MemoryRepository.new\nfile_repo = FileRepository.new("/data")\n\nuse_repository(memory_repo)\nuse_repository(file_repo)\n'})}),"\n",(0,r.jsx)(e.h2,{id:"duck-typing-vs-interfaces",children:"Duck Typing vs Interfaces"}),"\n",(0,r.jsx)(e.p,{children:"Compare explicit interfaces with duck typing:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="comparison.trb"',children:'# Explicit interface approach\ninterface Logger\n  def log(message: String): void\n  def error(message: String): void\nend\n\nclass ConsoleLogger\n  implements Logger\n\n  def log(message: String): void\n    puts message\n  end\n\n  def error(message: String): void\n    puts "ERROR: #{message}"\n  end\nend\n\n# Duck typing approach (no implements keyword)\nclass FileLogger\n  def log(message: String): void\n    # Write to file\n    puts "Logging to file: #{message}"\n  end\n\n  def error(message: String): void\n    puts "ERROR to file: #{message}"\n  end\nend\n\n# Both work with duck typing parameter\ndef use_logger(logger: { def log(message: String): void }): void\n  logger.log("Application started")\nend\n\nconsole = ConsoleLogger.new\nfile = FileLogger.new\n\nuse_logger(console)  # Works - implements Logger\nuse_logger(file)     # Works - has log method (duck typing)\n'})}),"\n",(0,r.jsx)(e.h2,{id:"structural-subtyping",children:"Structural Subtyping"}),"\n",(0,r.jsx)(e.p,{children:"Objects with more methods than required still satisfy structural types:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="subtyping.trb"',children:'type BasicLogger = {\n  def log(message: String): void\n}\n\nclass AdvancedLogger\n  def log(message: String): void\n    puts message\n  end\n\n  def debug(message: String): void\n    puts "DEBUG: #{message}"\n  end\n\n  def warn(message: String): void\n    puts "WARN: #{message}"\n  end\n\n  def error(message: String): void\n    puts "ERROR: #{message}"\n  end\nend\n\n# AdvancedLogger satisfies BasicLogger requirement\ndef simple_logging(logger: BasicLogger): void\n  logger.log("Message")\n  # Can only call log() here, even though logger has more methods\nend\n\nadvanced = AdvancedLogger.new\nsimple_logging(advanced)  # Works - structural subtyping\n'})}),"\n",(0,r.jsx)(e.h2,{id:"generic-structural-types",children:"Generic Structural Types"}),"\n",(0,r.jsx)(e.p,{children:"Combine generics with structural typing:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="generic_structural.trb"',children:'def transform<T, U>(\n  items: T[],\n  transformer: { def transform(item: T): U }\n): U[]\n  items.map { |item| transformer.transform(item) }\nend\n\nclass StringToInt\n  def transform(item: String): Integer\n    item.to_i\n  end\nend\n\nclass IntToString\n  def transform(item: Integer): String\n    item.to_s\n  end\nend\n\nclass DoubleTransformer\n  def transform(item: Integer): Integer\n    item * 2\n  end\nend\n\n# All work with the same generic function\nstrings = ["1", "2", "3"]\nstring_to_int = StringToInt.new\nintegers = transform(strings, string_to_int)  # [1, 2, 3]\n\nnumbers = [1, 2, 3]\nint_to_string = IntToString.new\nstrings_result = transform(numbers, int_to_string)  # ["1", "2", "3"]\n\ndoubler = DoubleTransformer.new\ndoubled = transform(numbers, doubler)  # [2, 4, 6]\n'})}),"\n",(0,r.jsx)(e.h2,{id:"practical-example-plugin-system",children:"Practical Example: Plugin System"}),"\n",(0,r.jsx)(e.p,{children:"Using duck typing for a flexible plugin architecture:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="plugin_duck_typing.trb"',children:'type Plugin = {\n  def name(): String\n  def execute(): void\n}\n\ntype ConfigurablePlugin = {\n  def name(): String\n  def execute(): void\n  def configure(options: Hash<String, String>): void\n}\n\nclass SimplePlugin\n  def name(): String\n    "Simple Plugin"\n  end\n\n  def execute(): void\n    puts "Executing #{name()}"\n  end\nend\n\nclass AdvancedPlugin\n  def initialize()\n    @config: Hash<String, String> = {}\n  end\n\n  def name(): String\n    "Advanced Plugin"\n  end\n\n  def execute(): void\n    level = @config["level"] || "default"\n    puts "Executing #{name()} at level #{level}"\n  end\n\n  def configure(options: Hash<String, String>): void\n    @config = options\n  end\nend\n\nclass PluginRunner\n  def run_plugin(plugin: Plugin): void\n    puts "Running: #{plugin.name()}"\n    plugin.execute()\n  end\n\n  def run_configurable(plugin: ConfigurablePlugin, config: Hash<String, String>): void\n    plugin.configure(config)\n    run_plugin(plugin)  # ConfigurablePlugin satisfies Plugin\n  end\nend\n\nrunner = PluginRunner.new\n\nsimple = SimplePlugin.new\nrunner.run_plugin(simple)\n\nadvanced = AdvancedPlugin.new\nrunner.run_configurable(advanced, { "level" => "high" })\n'})}),"\n",(0,r.jsx)(e.h2,{id:"practical-example-data-pipeline",children:"Practical Example: Data Pipeline"}),"\n",(0,r.jsx)(e.p,{children:"Duck typing for flexible data processing:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="data_pipeline.trb"',children:'type DataSource = {\n  def read(): Hash<String, String>[]\n}\n\ntype DataProcessor = {\n  def process(data: Hash<String, String>[]): Hash<String, String>[]\n}\n\ntype DataSink = {\n  def write(data: Hash<String, String>[]): void\n}\n\nclass CSVSource\n  def initialize(path: String)\n    @path = path\n  end\n\n  def read(): Hash<String, String>[]\n    # Read CSV file\n    [{ "name" => "Alice", "age" => "30" }]\n  end\nend\n\nclass JSONSource\n  def initialize(url: String)\n    @url = url\n  end\n\n  def read(): Hash<String, String>[]\n    # Fetch JSON from URL\n    [{ "name" => "Bob", "age" => "25" }]\n  end\nend\n\nclass FilterProcessor\n  def initialize(field: String, value: String)\n    @field = field\n    @value = value\n  end\n\n  def process(data: Hash<String, String>[]): Hash<String, String>[]\n    data.select { |row| row[@field] == @value }\n  end\nend\n\nclass TransformProcessor\n  def process(data: Hash<String, String>[]): Hash<String, String>[]\n    data.map do |row|\n      row.merge({ "processed" => "true" })\n    end\n  end\nend\n\nclass DatabaseSink\n  def write(data: Hash<String, String>[]): void\n    puts "Writing #{data.length} rows to database"\n    data.each { |row| puts "  #{row}" }\n  end\nend\n\nclass FileSink\n  def initialize(path: String)\n    @path = path\n  end\n\n  def write(data: Hash<String, String>[]): void\n    puts "Writing #{data.length} rows to #{@path}"\n  end\nend\n\nclass Pipeline\n  def initialize(source: DataSource, sink: DataSink)\n    @source = source\n    @sink = sink\n    @processors: DataProcessor[] = []\n  end\n\n  def add_processor(processor: DataProcessor): void\n    @processors.push(processor)\n  end\n\n  def execute(): void\n    data = @source.read()\n    @processors.each do |processor|\n      data = processor.process(data)\n    end\n    @sink.write(data)\n  end\nend\n\n# Build pipeline with different combinations\ncsv_source = CSVSource.new("/data/input.csv")\njson_source = JSONSource.new("https://api.example.com/data")\n\nfilter = FilterProcessor.new("age", "30")\ntransform = TransformProcessor.new\n\ndb_sink = DatabaseSink.new\nfile_sink = FileSink.new("/data/output.csv")\n\n# Pipeline 1: CSV -> Filter -> Transform -> Database\npipeline1 = Pipeline.new(csv_source, db_sink)\npipeline1.add_processor(filter)\npipeline1.add_processor(transform)\npipeline1.execute()\n\n# Pipeline 2: JSON -> Transform -> File\npipeline2 = Pipeline.new(json_source, file_sink)\npipeline2.add_processor(transform)\npipeline2.execute()\n'})}),"\n",(0,r.jsx)(e.h2,{id:"practical-example-event-system",children:"Practical Example: Event System"}),"\n",(0,r.jsx)(e.p,{children:"Flexible event handling with duck typing:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-trb",metastring:'title="event_system.trb"',children:'type EventHandler = {\n  def handle(event: Hash<String, String>): void\n}\n\ntype AsyncEventHandler = {\n  def handle(event: Hash<String, String>): void\n  def handle_async(event: Hash<String, String>): void\n}\n\nclass LogHandler\n  def handle(event: Hash<String, String>): void\n    puts "Log: #{event[\'type\']} - #{event[\'message\']}"\n  end\nend\n\nclass EmailHandler\n  def handle(event: Hash<String, String>): void\n    puts "Sending email for: #{event[\'type\']}"\n  end\n\n  def handle_async(event: Hash<String, String>): void\n    puts "Queueing email for: #{event[\'type\']}"\n  end\nend\n\nclass MetricsHandler\n  def handle(event: Hash<String, String>): void\n    puts "Recording metric: #{event[\'type\']}"\n  end\nend\n\nclass EventBus\n  def initialize()\n    @handlers: EventHandler[] = []\n  end\n\n  def subscribe(handler: EventHandler): void\n    @handlers.push(handler)\n  end\n\n  def publish(event: Hash<String, String>): void\n    @handlers.each { |handler| handler.handle(event) }\n  end\n\n  def publish_async(event: Hash<String, String>): void\n    @handlers.each do |handler|\n      # Check if handler supports async\n      if handler.respond_to?(:handle_async)\n        handler.handle_async(event)\n      else\n        handler.handle(event)\n      end\n    end\n  end\nend\n\n# Usage\nbus = EventBus.new\nbus.subscribe(LogHandler.new)\nbus.subscribe(EmailHandler.new)\nbus.subscribe(MetricsHandler.new)\n\nevent = { "type" => "user_signup", "message" => "New user registered" }\nbus.publish(event)\nbus.publish_async(event)\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use structural types for flexibility"}),": When you need flexibility and don't want to enforce explicit interface implementation."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use interfaces for contracts"}),": When you want explicit contracts and documentation of requirements."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Keep structural types simple"}),": Complex structural types can be harder to understand than named interfaces."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Document expectations"}),": Clearly document what methods and behaviors are expected, even with duck typing."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Consider future maintenance"}),": Explicit interfaces can make refactoring easier by showing all implementations."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Combine approaches"}),": Use interfaces for core contracts and duck typing for flexible, optional features."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"when-to-use-duck-typing",children:"When to Use Duck Typing"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Use duck typing when:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Working with third-party code you can't modify"}),"\n",(0,r.jsx)(e.li,{children:"Building highly flexible, plugin-style architectures"}),"\n",(0,r.jsx)(e.li,{children:"Prototyping and iteration speed is important"}),"\n",(0,r.jsx)(e.li,{children:"You want to avoid deep inheritance hierarchies"}),"\n",(0,r.jsx)(e.li,{children:"Different classes naturally have similar methods but aren't related"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Use explicit interfaces when:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Defining public APIs and contracts"}),"\n",(0,r.jsx)(e.li,{children:"You want IDE support for all implementations"}),"\n",(0,r.jsx)(e.li,{children:"Documentation and discoverability are important"}),"\n",(0,r.jsx)(e.li,{children:"You're building frameworks or libraries"}),"\n",(0,r.jsx)(e.li,{children:"Type safety is critical"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"Duck typing in T-Ruby provides:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Structural typing"})," based on method presence, not explicit implementation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Flexibility"})," to work with any object that has the required methods"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Type safety"})," ensuring objects have the methods you call"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Gradual typing"})," combining strict interfaces with flexible duck typing"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Master both explicit interfaces and duck typing to write flexible, type-safe T-Ruby code. Choose the right approach for each situation based on your needs for flexibility, type safety, and maintainability."})]})}function g(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},6145(n,e,t){t.d(e,{R:()=>a,x:()=>d});var i=t(7140);const r={},s=i.createContext(r);function a(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);