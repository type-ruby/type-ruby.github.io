"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[7654],{1604(e,n,a){a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"learn/advanced/mapped-types","title":"Mapped Types","description":"Transforming types programmatically","source":"@site/docs/learn/advanced/mapped-types.md","sourceDirName":"learn/advanced","slug":"/learn/advanced/mapped-types","permalink":"/docs/learn/advanced/mapped-types","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/learn/advanced/mapped-types.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Mapped Types","description":"Transforming types programmatically"},"sidebar":"docsSidebar","previous":{"title":"Conditional Types","permalink":"/docs/learn/advanced/conditional-types"},"next":{"title":"Utility Types","permalink":"/docs/learn/advanced/utility-types"}}');var t=a(5656),i=a(6145);const s={sidebar_position:4,title:"Mapped Types",description:"Transforming types programmatically"},l="Mapped Types",d={},o=[{value:"Understanding Mapped Types",id:"understanding-mapped-types",level:2},{value:"Basic Syntax",id:"basic-syntax",level:3},{value:"The <code>keyof</code> Operator",id:"the-keyof-operator",level:2},{value:"Basic Mapped Type Patterns",id:"basic-mapped-type-patterns",level:2},{value:"Make Properties Readonly",id:"make-properties-readonly",level:3},{value:"Make Properties Optional",id:"make-properties-optional",level:3},{value:"Make Properties Required",id:"make-properties-required",level:3},{value:"Property Transformations",id:"property-transformations",level:2},{value:"Transform Property Types",id:"transform-property-types",level:3},{value:"Add or Remove Modifiers",id:"add-or-remove-modifiers",level:3},{value:"Filtering Keys",id:"filtering-keys",level:2},{value:"Pick Specific Properties",id:"pick-specific-properties",level:3},{value:"Omit Specific Properties",id:"omit-specific-properties",level:3},{value:"Conditional Mapped Types",id:"conditional-mapped-types",level:2},{value:"Key Remapping",id:"key-remapping",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"DTO Pattern",id:"dto-pattern",level:3},{value:"Form Handlers",id:"form-handlers",level:3},{value:"Database Models",id:"database-models",level:3},{value:"Event Handlers",id:"event-handlers",level:3},{value:"Deep Mapped Types",id:"deep-mapped-types",level:2},{value:"Combining Mapped Types",id:"combining-mapped-types",level:2},{value:"Type-Safe Builders",id:"type-safe-builders",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Descriptive Names",id:"1-use-descriptive-names",level:3},{value:"2. Create Reusable Mapped Types",id:"2-create-reusable-mapped-types",level:3},{value:"3. Document Complex Mappings",id:"3-document-complex-mappings",level:3},{value:"4. Combine with Conditional Types",id:"4-combine-with-conditional-types",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Repository Pattern",id:"repository-pattern",level:3},{value:"State Management",id:"state-management",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Cannot Add New Properties",id:"cannot-add-new-properties",level:3},{value:"Key Type Restrictions",id:"key-type-restrictions",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components},{DocsBadge:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a,{}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"mapped-types",children:"Mapped Types"})}),"\n",(0,t.jsx)(n.admonition,{title:"Coming Soon",type:"caution",children:(0,t.jsx)(n.p,{children:"This feature is planned for a future release."})}),"\n",(0,t.jsx)(n.p,{children:'Mapped types allow you to transform one type into another by iterating over its properties. Think of them as "map" operations for types\u2014they let you programmatically create new types based on existing ones by applying transformations to each property.'}),"\n",(0,t.jsx)(n.h2,{id:"understanding-mapped-types",children:"Understanding Mapped Types"}),"\n",(0,t.jsx)(n.p,{children:"Mapped types iterate over the keys of a type and apply a transformation to create a new type:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"type MappedType<T> = {\n  [K in keyof T]: Transformation<T[K]>\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"basic-syntax",children:"Basic Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Iterate over keys of T\ntype ReadonlyType<T> = {\n  readonly [K in keyof T]: T[K]\n}\n\n# Make all properties optional\ntype OptionalType<T> = {\n  [K in keyof T]?: T[K]\n}\n\n# Make all properties required\ntype RequiredType<T> = {\n  [K in keyof T]-?: T[K]\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"the-keyof-operator",children:["The ",(0,t.jsx)(n.code,{children:"keyof"})," Operator"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"keyof"})," operator gets all keys of a type as a union:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'type User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\ntype UserKeys = keyof User  # "id" | "name" | "email"\n\n# Use in mapped types\ntype UserValues<T> = {\n  [K in keyof T]: T[K]\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"basic-mapped-type-patterns",children:"Basic Mapped Type Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"make-properties-readonly",children:"Make Properties Readonly"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Make all properties readonly\ntype Readonly<T> = {\n  readonly [K in keyof T]: T[K]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\ntype ReadonlyUser = Readonly<User>\n# {\n#   readonly id: Integer,\n#   readonly name: String,\n#   readonly email: String\n# }\n\n# Usage\nuser: ReadonlyUser = { id: 1, name: "Alice", email: "alice@example.com" }\n# user.name = "Bob"  # Error: Cannot assign to readonly property\n'})}),"\n",(0,t.jsx)(n.h3,{id:"make-properties-optional",children:"Make Properties Optional"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Make all properties optional\ntype Partial<T> = {\n  [K in keyof T]?: T[K]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\ntype PartialUser = Partial<User>\n# {\n#   id?: Integer,\n#   name?: String,\n#   email?: String\n# }\n\n# Usage - all properties optional\npartial_user: PartialUser = { name: "Alice" }  # OK\npartial_user2: PartialUser = {}  # OK\n'})}),"\n",(0,t.jsx)(n.h3,{id:"make-properties-required",children:"Make Properties Required"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Remove optional modifiers\ntype Required<T> = {\n  [K in keyof T]-?: T[K]\n}\n\ntype UserUpdate = {\n  id?: Integer,\n  name?: String,\n  email?: String\n}\n\ntype RequiredUserUpdate = Required<UserUpdate>\n# {\n#   id: Integer,\n#   name: String,\n#   email: String\n# }\n"})}),"\n",(0,t.jsx)(n.h2,{id:"property-transformations",children:"Property Transformations"}),"\n",(0,t.jsx)(n.h3,{id:"transform-property-types",children:"Transform Property Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Convert all properties to arrays\ntype Arrayify<T> = {\n  [K in keyof T]: Array<T[K]>\n}\n\ntype User = {\n  id: Integer,\n  name: String\n}\n\ntype ArrayUser = Arrayify<User>\n# {\n#   id: Array<Integer>,\n#   name: Array<String>\n# }\n\n# Convert all properties to promises\ntype Promisify<T> = {\n  [K in keyof T]: Promise<T[K]>\n}\n\n# Convert all properties to nullable\ntype Nullable<T> = {\n  [K in keyof T]: T[K] | nil\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"add-or-remove-modifiers",children:"Add or Remove Modifiers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Add readonly\ntype AddReadonly<T> = {\n  +readonly [K in keyof T]: T[K]\n}\n\n# Remove readonly\ntype RemoveReadonly<T> = {\n  -readonly [K in keyof T]: T[K]\n}\n\n# Make optional\ntype MakeOptional<T> = {\n  [K in keyof T]+?: T[K]\n}\n\n# Make required\ntype MakeRequired<T> = {\n  [K in keyof T]-?: T[K]\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"filtering-keys",children:"Filtering Keys"}),"\n",(0,t.jsx)(n.h3,{id:"pick-specific-properties",children:"Pick Specific Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Pick only specified keys\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String,\n  password: String\n}\n\ntype PublicUser = Pick<User, "id" | "name">\n# {\n#   id: Integer,\n#   name: String\n# }\n\n# Usage\npublic_user: PublicUser = { id: 1, name: "Alice" }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"omit-specific-properties",children:"Omit Specific Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Omit specified keys\ntype Omit<T, K extends keyof T> = {\n  [P in Exclude<keyof T, K>]: T[P]\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String,\n  password: String\n}\n\ntype UserWithoutPassword = Omit<User, "password">\n# {\n#   id: Integer,\n#   name: String,\n#   email: String\n# }\n\n# Omit multiple properties\ntype UserBasic = Omit<User, "password" | "email">\n# {\n#   id: Integer,\n#   name: String\n# }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"conditional-mapped-types",children:"Conditional Mapped Types"}),"\n",(0,t.jsx)(n.p,{children:"Combine mapped types with conditional types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Make properties readonly based on condition\ntype ConditionalReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends Function ? T[K] : readonly T[K]\n}\n\n# Make properties nullable based on condition\ntype ConditionalNullable<T> = {\n  [K in keyof T]: T[K] extends String ? T[K] | nil : T[K]\n}\n\n# Remove functions\ntype RemoveFunctions<T> = {\n  [K in keyof T as T[K] extends Function ? never : K]: T[K]\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"key-remapping",children:"Key Remapping"}),"\n",(0,t.jsx)(n.p,{children:"Transform property keys while mapping:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Add prefix to all keys\ntype Prefixed<T, Prefix extends String> = {\n  [K in keyof T as `${Prefix}${K}`]: T[K]\n}\n\ntype User = {\n  id: Integer,\n  name: String\n}\n\ntype PrefixedUser = Prefixed<User, "user_">\n# {\n#   user_id: Integer,\n#   user_name: String\n# }\n\n# Convert keys to uppercase\ntype Uppercased<T> = {\n  [K in keyof T as Uppercase<K>]: T[K]\n}\n\n# Add getters\ntype WithGetters<T> = {\n  [K in keyof T as `get${Capitalize<K>}`]: () => T[K]\n}\n\ntype User = { name: String, age: Integer }\ntype UserWithGetters = WithGetters<User>\n# {\n#   getName: () => String,\n#   getAge: () => Integer\n# }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,t.jsx)(n.h3,{id:"dto-pattern",children:"DTO Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Data Transfer Object - all properties become optional and nullable\ntype DTO<T> = {\n  [K in keyof T]?: T[K] | nil\n}\n\n# API Response - wrap data\ntype APIWrapper<T> = {\n  [K in keyof T]: {\n    value: T[K],\n    updated_at: Time\n  }\n}\n\ntype User = {\n  name: String,\n  email: String\n}\n\ntype UserDTO = DTO<User>\n# {\n#   name?: String | nil,\n#   email?: String | nil\n# }\n\ntype UserAPI = APIWrapper<User>\n# {\n#   name: { value: String, updated_at: Time },\n#   email: { value: String, updated_at: Time }\n# }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"form-handlers",children:"Form Handlers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Convert properties to form fields\ntype FormFields<T> = {\n  [K in keyof T]: {\n    value: T[K],\n    error: String | nil,\n    touched: Boolean\n  }\n}\n\n# Form values only\ntype FormValues<T> = {\n  [K in keyof T]: T[K]\n}\n\n# Form event handlers\ntype FormHandlers<T> = {\n  [K in keyof T as `on${Capitalize<K>}Change`]: (value: T[K]) => void\n}\n\ntype LoginForm = {\n  username: String,\n  password: String\n}\n\ntype LoginFields = FormFields<LoginForm>\n# {\n#   username: { value: String, error: String | nil, touched: Boolean },\n#   password: { value: String, error: String | nil, touched: Boolean }\n# }\n\ntype LoginHandlers = FormHandlers<LoginForm>\n# {\n#   onUsernameChange: (value: String) => void,\n#   onPasswordChange: (value: String) => void\n# }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"database-models",children:"Database Models"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Add timestamps to model\ntype WithTimestamps<T> = T & {\n  created_at: Time,\n  updated_at: Time\n}\n\n# Make model partial for updates\ntype UpdateModel<T> = Partial<Omit<T, "id" | "created_at">>\n\n# Add database metadata\ntype DBModel<T> = {\n  [K in keyof T]: {\n    value: T[K],\n    column_name: String,\n    dirty: Boolean\n  }\n}\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String\n}\n\ntype TimestampedUser = WithTimestamps<User>\n# {\n#   id: Integer,\n#   name: String,\n#   email: String,\n#   created_at: Time,\n#   updated_at: Time\n# }\n\ntype UserUpdate = UpdateModel<User>\n# {\n#   name?: String,\n#   email?: String\n# }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"event-handlers",children:"Event Handlers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Create event handlers for all properties\ntype EventHandlers<T> = {\n  [K in keyof T as `on${Capitalize<K>}Updated`]: (value: T[K]) => void\n}\n\n# Create validators for all properties\ntype Validators<T> = {\n  [K in keyof T]: (value: T[K]) => Boolean\n}\n\n# Create serializers for all properties\ntype Serializers<T> = {\n  [K in keyof T]: (value: T[K]) => String\n}\n\ntype Product = {\n  name: String,\n  price: Float,\n  stock: Integer\n}\n\ntype ProductHandlers = EventHandlers<Product>\n# {\n#   onNameUpdated: (value: String) => void,\n#   onPriceUpdated: (value: Float) => void,\n#   onStockUpdated: (value: Integer) => void\n# }\n\ntype ProductValidators = Validators<Product>\n# {\n#   name: (value: String) => Boolean,\n#   price: (value: Float) => Boolean,\n#   stock: (value: Integer) => Boolean\n# }\n"})}),"\n",(0,t.jsx)(n.h2,{id:"deep-mapped-types",children:"Deep Mapped Types"}),"\n",(0,t.jsx)(n.p,{children:"Apply mappings recursively to nested objects:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Deep readonly\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends Hash<any, any>\n    ? DeepReadonly<T[K]>\n    : T[K]\n}\n\n# Deep partial\ntype DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends Hash<any, any>\n    ? DeepPartial<T[K]>\n    : T[K]\n}\n\n# Deep required\ntype DeepRequired<T> = {\n  [K in keyof T]-?: T[K] extends Hash<any, any>\n    ? DeepRequired<T[K]>\n    : T[K]\n}\n\ntype NestedUser = {\n  profile: {\n    name: String,\n    settings: {\n      theme: String,\n      notifications: Boolean\n    }\n  }\n}\n\ntype DeepReadonlyUser = DeepReadonly<NestedUser>\n# All nested properties become readonly\n"})}),"\n",(0,t.jsx)(n.h2,{id:"combining-mapped-types",children:"Combining Mapped Types"}),"\n",(0,t.jsx)(n.p,{children:"Combine multiple mappings:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Readonly and Partial\ntype ReadonlyPartial<T> = Readonly<Partial<T>>\n\n# Readonly and Required\ntype ReadonlyRequired<T> = Readonly<Required<T>>\n\n# Nullable and Partial\ntype NullablePartial<T> = {\n  [K in keyof T]?: T[K] | nil\n}\n\n# Pick and Partial\ntype PartialPick<T, K extends keyof T> = Partial<Pick<T, K>>\n\ntype User = {\n  id: Integer,\n  name: String,\n  email: String,\n  password: String\n}\n\ntype SafeUserUpdate = ReadonlyPartial<Omit<User, "id">>\n# {\n#   readonly name?: String,\n#   readonly email?: String,\n#   readonly password?: String\n# }\n'})}),"\n",(0,t.jsx)(n.h2,{id:"type-safe-builders",children:"Type-Safe Builders"}),"\n",(0,t.jsx)(n.p,{children:"Use mapped types to create type-safe builders:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Builder that ensures all properties are set\ntype Builder<T> = {\n  [K in keyof T as `with${Capitalize<K>}`]: (value: T[K]) => Builder<T>\n} & {\n  build: () => T\n}\n\n# Fluent API\ntype FluentAPI<T> = {\n  [K in keyof T]: (value: T[K]) => FluentAPI<T>\n} & {\n  get: () => T\n}\n\n# Usage example\ntype User = {\n  name: String,\n  email: String,\n  age: Integer\n}\n\ntype UserBuilder = Builder<User>\n# {\n#   withName: (value: String) => UserBuilder,\n#   withEmail: (value: String) => UserBuilder,\n#   withAge: (value: Integer) => UserBuilder,\n#   build: () => User\n# }\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-use-descriptive-names",children:"1. Use Descriptive Names"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'# Good: Clear purpose\ntype ReadonlyUser = Readonly<User>\ntype PartialUpdate = Partial<UserUpdate>\ntype PublicProfile = Pick<User, "id" | "name">\n\n# Less good: Generic names\ntype UserType1 = Readonly<User>\ntype UserType2 = Partial<UserUpdate>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-create-reusable-mapped-types",children:"2. Create Reusable Mapped Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Good: Reusable utilities\ntype WithTimestamps<T> = T & { created_at: Time, updated_at: Time }\ntype WithSoftDelete<T> = T & { deleted_at: Time | nil }\ntype WithMetadata<T> = T & { metadata: Hash<String, String> }\n\n# Compose them\ntype FullModel<T> = WithTimestamps<WithSoftDelete<WithMetadata<T>>>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-document-complex-mappings",children:"3. Document Complex Mappings"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Good: Documented\n# Converts all properties to their corresponding getter methods\n# Example: { name: String } => { getName: () => String }\ntype ToGetters<T> = {\n  [K in keyof T as `get${Capitalize<K>}`]: () => T[K]\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-combine-with-conditional-types",children:"4. Combine with Conditional Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Good: Smart transformations\ntype SmartNullable<T> = {\n  [K in keyof T]: T[K] extends String | Integer\n    ? T[K] | nil\n    : T[K]\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"repository-pattern",children:"Repository Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:'type Repository<T> = {\n  find_by_id: (id: Integer) => T | nil,\n  find_all: () => Array<T>,\n  save: (entity: T) => T,\n  update: (id: Integer, data: Partial<T>) => T | nil,\n  delete: (id: Integer) => Boolean\n}\n\ntype CRUDHandlers<T> = {\n  create: (data: Omit<T, "id">) => T,\n  read: (id: Integer) => T | nil,\n  update: (id: Integer, data: Partial<T>) => T | nil,\n  delete: (id: Integer) => Boolean\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"state-management",children:"State Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"type State<T> = T\n\ntype Actions<T> = {\n  [K in keyof T as `set${Capitalize<K>}`]: (value: T[K]) => void\n} & {\n  [K in keyof T as `get${Capitalize<K>}`]: () => T[K]\n}\n\ntype Reducers<T> = {\n  [K in keyof T]: (state: T[K], action: any) => T[K]\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.h3,{id:"cannot-add-new-properties",children:"Cannot Add New Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Cannot add properties not in the original type\ntype Extended<T> = {\n  [K in keyof T]: T[K]\n  # new_property: String  # Error: Cannot add new properties in mapped type\n}\n\n# Use intersection instead\ntype Extended<T> = T & { new_property: String }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-type-restrictions",children:"Key Type Restrictions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-trb",children:"# Keys must be String | Symbol | Integer\ntype ValidKeys = { [K in String]: any }     # OK\ntype InvalidKeys = { [K in User]: any }     # Error: User is not a valid key type\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(n.p,{children:"Now that you understand mapped types, explore:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/learn/advanced/utility-types",children:"Utility Types"})," which are built using mapped types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/learn/advanced/conditional-types",children:"Conditional Types"})," to add logic to mappings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/learn/advanced/type-aliases",children:"Type Aliases"})," to name your mapped types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/learn/generics/generic-functions-classes",children:"Generics"})," to make mapped types reusable"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},6145(e,n,a){a.d(n,{R:()=>s,x:()=>l});var r=a(7140);const t={},i=r.createContext(t);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);