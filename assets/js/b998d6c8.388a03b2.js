"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[996],{4907(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"reference/cheatsheet","title":"Type Syntax Cheatsheet","description":"Quick reference for T-Ruby type syntax","source":"@site/docs/reference/cheatsheet.md","sourceDirName":"reference","slug":"/reference/cheatsheet","permalink":"/docs/reference/cheatsheet","draft":false,"unlisted":false,"editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/docs/reference/cheatsheet.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Type Syntax Cheatsheet","description":"Quick reference for T-Ruby type syntax"},"sidebar":"docsSidebar","previous":{"title":"Migrating from Ruby","permalink":"/docs/tooling/migrating-from-ruby"},"next":{"title":"Built-in Types","permalink":"/docs/reference/built-in-types"}}');var i=r(5656),s=r(6145);const l={sidebar_position:1,title:"Type Syntax Cheatsheet",description:"Quick reference for T-Ruby type syntax"},a="Type Syntax Cheatsheet",d={},c=[{value:"Basic Types",id:"basic-types",level:2},{value:"Variable Annotations",id:"variable-annotations",level:2},{value:"Function Signatures",id:"function-signatures",level:2},{value:"Union Types",id:"union-types",level:2},{value:"Array Types",id:"array-types",level:2},{value:"Hash Types",id:"hash-types",level:2},{value:"Generic Types",id:"generic-types",level:2},{value:"Type Aliases",id:"type-aliases",level:2},{value:"Class Annotations",id:"class-annotations",level:2},{value:"Interface Definitions",id:"interface-definitions",level:2},{value:"Type Operators",id:"type-operators",level:2},{value:"Blocks, Procs, and Lambdas",id:"blocks-procs-and-lambdas",level:2},{value:"Type Narrowing",id:"type-narrowing",level:2},{value:"Literal Types",id:"literal-types",level:2},{value:"Advanced Types",id:"advanced-types",level:2},{value:"Type Assertions",id:"type-assertions",level:2},{value:"Module Type Annotations",id:"module-type-annotations",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Optional Parameters with Defaults",id:"optional-parameters-with-defaults",level:3},{value:"Result Type Pattern",id:"result-type-pattern",level:3},{value:"Builder Pattern",id:"builder-pattern",level:3},{value:"Type Guards",id:"type-guards",level:3},{value:"Quick Tips",id:"quick-tips",level:2},{value:"Common Type Errors",id:"common-type-errors",level:2},{value:"File Extensions and Compilation",id:"file-extensions-and-compilation",level:2},{value:"Further Reading",id:"further-reading",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components},{DocsBadge:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("DocsBadge",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r,{}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"type-syntax-cheatsheet",children:"Type Syntax Cheatsheet"})}),"\n",(0,i.jsx)(n.p,{children:"A comprehensive quick reference guide for T-Ruby type syntax. Bookmark this page for easy access to all type annotations and syntax patterns."}),"\n",(0,i.jsx)(n.h2,{id:"basic-types",children:"Basic Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})}),(0,i.jsx)(n.td,{children:"Text data"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'name: String = "Alice"'})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Integer"})}),(0,i.jsx)(n.td,{children:"Whole numbers"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"count: Integer = 42"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Float"})}),(0,i.jsx)(n.td,{children:"Decimal numbers"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"price: Float = 19.99"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Boolean"})}),(0,i.jsx)(n.td,{children:"Boolean values"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"active: Boolean = true"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Symbol"})}),(0,i.jsx)(n.td,{children:"Immutable identifiers"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"status: Symbol = :active"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"nil"})}),(0,i.jsx)(n.td,{children:"Absence of value"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"value: nil = nil"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Any"})}),(0,i.jsx)(n.td,{children:"Any type (avoid when possible)"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'data: Any = "anything"'})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"No return value"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"def log(msg: String): void"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"variable-annotations",children:"Variable Annotations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Variable with type annotation\nname: String = "Alice"\nage: Integer = 30\nprice: Float = 99.99\n\n# Multiple variables\nx: Integer = 1\ny: Integer = 2\nz: Integer = 3\n\n# Type inference (type annotation optional)\nmessage = "Hello"  # Inferred as String\n'})}),"\n",(0,i.jsx)(n.h2,{id:"function-signatures",children:"Function Signatures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Basic function\ndef greet(name: String): String\n  "Hello, #{name}!"\nend\n\n# Multiple parameters\ndef add(a: Integer, b: Integer): Integer\n  a + b\nend\n\n# Optional parameters\ndef greet(name: String, greeting: String = "Hello"): String\n  "#{greeting}, #{name}!"\nend\n\n# Rest parameters\ndef sum(*numbers: Integer[]): Integer\n  numbers.sum\nend\n\n# Keyword arguments (no variable = destructured)\ndef create_user({ name: String, email: String, age: Integer = 18 }): Hash\n  { name: name, email: email, age: age }\nend\n\n# Hash literal (with variable name)\ndef process(config: { host: String, port: Integer }): String\n  "#{config[:host]}:#{config[:port]}"\nend\n\n# No return value\ndef log(message: String): void\n  puts message\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"union-types",children:"Union Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Syntax"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"A | B"})}),(0,i.jsx)(n.td,{children:"Either type A or B"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String | Integer"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"A | B | C"})}),(0,i.jsx)(n.td,{children:"One of multiple types"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String | Integer | Boolean"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"T | nil"})}),(0,i.jsx)(n.td,{children:"Optional type"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String | nil"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"T?"})}),(0,i.jsxs)(n.td,{children:["Shorthand for ",(0,i.jsx)(n.code,{children:"T | nil"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String?"})})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Union types\nid: String | Integer = "user-123"\nid: String | Integer = 456\n\n# Optional values\nname: String | nil = nil\nname: String? = nil  # Shorthand\n\n# Multiple types\nvalue: String | Integer | Boolean = true\n\n# Function with union return type\ndef find_user(id: Integer): User | nil\n  # Returns User or nil\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"array-types",children:"Array Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Array of specific type (shorthand syntax)\nnames: String[] = ["Alice", "Bob"]\nnumbers: Integer[] = [1, 2, 3]\n\n# Array of union types\nmixed: (String | Integer)[] = ["Alice", 1, "Bob", 2]\n\n# Nested arrays\nmatrix: Integer[][] = [[1, 2], [3, 4]]\n\n# Empty array with type\nitems: String[] = []\n\n# Nullable array vs array of nullable\nnullable_array: String[]? = nil        # The array itself can be nil\narray_of_nullable: String?[] = [nil]   # Elements can be nil\n'})}),"\n",(0,i.jsx)(n.h2,{id:"hash-types",children:"Hash Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Hash with specific key and value types\nscores: Hash<String, Integer> = { "Alice" => 100, "Bob" => 95 }\n\n# Symbol keys\nconfig: Hash<Symbol, String> = { host: "localhost", port: "3000" }\n\n# Union value types\ndata: Hash<String, String | Integer> = { "name" => "Alice", "age" => 30 }\n\n# Nested hashes\nusers: Hash<Integer, Hash<Symbol, String>> = {\n  1 => { name: "Alice", email: "alice@example.com" }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"generic-types",children:"Generic Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Generic function\ndef first<T>(arr: T[]): T?\n  arr[0]\nend\n\n# Multiple type parameters\ndef pair<K, V>(key: K, value: V): Hash<K, V>\n  { key => value }\nend\n\n# Generic class\nclass Box<T>\n  @value: T\n\n  def initialize(value: T): void\n    @value = value\n  end\n\n  def get: T\n    @value\n  end\nend\n\n# Using generics\nbox = Box<String>.new("hello")\nresult = first([1, 2, 3])  # Type inferred\n'})}),"\n",(0,i.jsx)(n.h2,{id:"type-aliases",children:"Type Aliases"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Simple alias\ntype UserId = Integer\ntype EmailAddress = String\n\n# Union type alias\ntype ID = String | Integer\ntype JSONValue = String | Integer | Float | Boolean | nil\n\n# Collection alias\ntype StringList = String[]\ntype UserMap = Hash<Integer, User>\n\n# Generic alias\ntype Result<T> = T | nil\ntype Callback<T> = Proc<T, void>\n\n# Using aliases\nuser_id: UserId = 123\nemail: EmailAddress = "alice@example.com"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"class-annotations",children:"Class Annotations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"# Instance variables\nclass User\n  @name: String\n  @age: Integer\n  @email: String | nil\n\n  def initialize(name: String, age: Integer): void\n    @name = name\n    @age = age\n    @email = nil\n  end\n\n  def name: String\n    @name\n  end\n\n  def age: Integer\n    @age\n  end\nend\n\n# Class variables\nclass Counter\n  @@count: Integer = 0\n\n  def self.increment: void\n    @@count += 1\n  end\n\n  def self.count: Integer\n    @@count\n  end\nend\n\n# Generic class\nclass Container<T>\n  @value: T\n\n  def initialize(value: T): void\n    @value = value\n  end\n\n  def value: T\n    @value\n  end\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interface-definitions",children:"Interface Definitions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Basic interface\ninterface Printable\n  def to_s: String\nend\n\n# Interface with multiple methods\ninterface Comparable\n  def <=>(other: self): Integer\n  def ==(other: self): Boolean\nend\n\n# Generic interface\ninterface Collection<T>\n  def add(item: T): void\n  def remove(item: T): Boolean\n  def size: Integer\nend\n\n# Implementing interfaces\nclass User\n  implements Printable\n\n  @name: String\n\n  def initialize(name: String): void\n    @name = name\n  end\n\n  def to_s: String\n    "User: #{@name}"\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"type-operators",children:"Type Operators"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operator"}),(0,i.jsx)(n.th,{children:"Name"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Example"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"|"})}),(0,i.jsx)(n.td,{children:"Union"}),(0,i.jsx)(n.td,{children:"Either/or types"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String | Integer"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"&"})}),(0,i.jsx)(n.td,{children:"Intersection"}),(0,i.jsx)(n.td,{children:"Both types"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Printable & Comparable"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"?"})}),(0,i.jsx)(n.td,{children:"Optional"}),(0,i.jsxs)(n.td,{children:["Shorthand for ",(0,i.jsx)(n.code,{children:"| nil"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String?"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[]"})}),(0,i.jsx)(n.td,{children:"Array"}),(0,i.jsx)(n.td,{children:"Array shorthand"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String[]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<T>"})}),(0,i.jsx)(n.td,{children:"Generic"}),(0,i.jsx)(n.td,{children:"Type parameter"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"T[]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"=>"})}),(0,i.jsx)(n.td,{children:"Hash pair"}),(0,i.jsx)(n.td,{children:"Key-value type"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Hash<String => Integer>"})})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"# Union (OR)\nvalue: String | Integer\n\n# Intersection (AND)\nclass Person\n  implements Printable & Comparable\nend\n\n# Optional\nname: String?  # Same as String | nil\n\n# Array shorthand\nitems: String[]\nnested: Integer[][]\n\n# Generics\nitems: String[]\npairs: Hash<String, Integer>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"blocks-procs-and-lambdas",children:"Blocks, Procs, and Lambdas"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"# Block parameter\ndef each_item<T>(items: T[], &block: Proc<T, void>): void\n  items.each { |item| block.call(item) }\nend\n\n# Proc types\ncallback: Proc<String, void> = ->(msg: String): void { puts msg }\ntransformer: Proc<Integer, String> = ->(n: Integer): String { n.to_s }\n\n# Lambda with types\ndouble: Proc<Integer, Integer> = ->(n: Integer): Integer { n * 2 }\n\n# Block with multiple parameters\ndef map<T, U>(items: T[], &block: Proc<T, Integer, U>): U[]\n  items.map.with_index { |item, index| block.call(item, index) }\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"type-narrowing",children:"Type Narrowing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Type checking with is_a?\ndef process(value: String | Integer): String\n  if value.is_a?(String)\n    value.upcase  # T-Ruby knows value is String\n  else\n    value.to_s    # T-Ruby knows value is Integer\n  end\nend\n\n# Nil checking\ndef get_length(text: String | nil): Integer\n  if text.nil?\n    0\n  else\n    text.length  # T-Ruby knows text is String\n  end\nend\n\n# Multiple checks\ndef describe(value: String | Integer | Boolean): String\n  if value.is_a?(String)\n    "String: #{value}"\n  elsif value.is_a?(Integer)\n    "Number: #{value}"\n  else\n    "Boolean: #{value}"\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"literal-types",children:"Literal Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# String literals\ntype Status = "pending" | "active" | "completed"\nstatus: Status = "active"\n\n# Number literals\ntype Port = 80 | 443 | 8080\nport: Port = 443\n\n# Symbol literals\ntype Role = :admin | :editor | :viewer\nrole: Role = :admin\n\n# Boolean literals\ntype Yes = true\ntype No = false\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-types",children:"Advanced Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"# Intersection types\ntype Serializable = Printable & Comparable\nobj: Serializable  # Must implement both interfaces\n\n# Conditional types (planned)\ntype NonNullable<T> = T extends nil ? never : T\n\n# Mapped types (planned)\ntype Readonly<T> = { readonly [K in keyof T]: T[K] }\n\n# Utility types\ntype Partial<T>    # All properties optional\ntype Required<T>   # All properties required\ntype Pick<T, K>    # Select properties\ntype Omit<T, K>    # Remove properties\n"})}),"\n",(0,i.jsx)(n.h2,{id:"type-assertions",children:"Type Assertions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# Type casting (use with caution)\nvalue = get_value() as String\nnumber = parse("42") as Integer\n\n# Safe type conversion\ndef to_integer(value: String | Integer): Integer\n  if value.is_a?(Integer)\n    value\n  else\n    value.to_i\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"module-type-annotations",children:"Module Type Annotations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'module Formatter\n  # Module method with types\n  def self.format(value: String, width: Integer): String\n    value.ljust(width)\n  end\n\n  # Module constants with types\n  DEFAULT_WIDTH: Integer = 80\n  DEFAULT_CHAR: String = " "\nend\n\n# Mixin module\nmodule Timestamped\n  @created_at: Integer\n  @updated_at: Integer\n\n  def timestamp: Integer\n    @created_at\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"optional-parameters-with-defaults",children:"Optional Parameters with Defaults"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"def create_user(\n  name: String,\n  email: String,\n  age: Integer = 18,\n  active: Boolean = true\n): User\n  User.new(name, email, age, active)\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"result-type-pattern",children:"Result Type Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'type Result<T, E> = { success: Boolean, value: T | nil, error: E | nil }\n\ndef divide(a: Float, b: Float): Result<Float, String>\n  if b == 0\n    { success: false, value: nil, error: "Division by zero" }\n  else\n    { success: true, value: a / b, error: nil }\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"builder-pattern",children:"Builder Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'class QueryBuilder\n  @conditions: String[]\n\n  def initialize: void\n    @conditions = []\n  end\n\n  def where(condition: String): self\n    @conditions << condition\n    self\n  end\n\n  def build: String\n    @conditions.join(" AND ")\n  end\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"type-guards",children:"Type Guards"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:"def is_string(value: Any): value is String\n  value.is_a?(String)\nend\n\ndef is_user(value: Any): value is User\n  value.is_a?(User)\nend\n\n# Usage\nvalue = get_value()\nif is_string(value)\n  puts value.upcase  # value is String here\nend\n"})}),"\n",(0,i.jsx)(n.h2,{id:"quick-tips",children:"Quick Tips"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use type inference"})," - Don't annotate everything, let T-Ruby infer simple types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prefer union types over Any"})," - ",(0,i.jsx)(n.code,{children:"String | Integer"})," is better than ",(0,i.jsx)(n.code,{children:"Any"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use type aliases"})," - Make complex types readable with aliases"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Check types before use"})," - Use ",(0,i.jsx)(n.code,{children:"is_a?"})," and ",(0,i.jsx)(n.code,{children:"nil?"})," for union types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Leverage generics"})," - Write reusable, type-safe code"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Start gradually"})," - You don't need to type everything at once"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"void"})," for side effects"]})," - Methods that don't return meaningful values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Avoid over-typing"})," - If the type is obvious, let T-Ruby infer it"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-type-errors",children:"Common Type Errors"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-trb",children:'# \u274c Wrong: Assigning wrong type\nname: String = 123  # Error: Integer is not String\n\n# \u2705 Correct: Use union type\nid: String | Integer = 123\n\n# \u274c Wrong: Accessing property without type check\ndef get_length(value: String | nil): Integer\n  value.length  # Error: value might be nil\nend\n\n# \u2705 Correct: Check for nil first\ndef get_length(value: String | nil): Integer\n  if value.nil?\n    0\n  else\n    value.length\n  end\nend\n\n# \u274c Wrong: Generic without type parameter\nbox = Box.new("hello")  # Error if type can\'t be inferred\n\n# \u2705 Correct: Specify type parameter\nbox = Box<String>.new("hello")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"file-extensions-and-compilation",children:"File Extensions and Compilation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# T-Ruby source files\nhello.trb\n\n# Compile to Ruby\ntrc hello.trb\n# Generates: hello.rb\n\n# Generate RBS types\ntrc --rbs hello.trb\n# Generates: hello.rbs\n\n# Watch mode\ntrc --watch *.trb\n\n# Type check only (no output)\ntrc --check hello.trb\n"})}),"\n",(0,i.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/reference/built-in-types",children:"Built-in Types"})," - Complete list of built-in types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/reference/type-operators",children:"Type Operators"})," - Detailed operator reference"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/reference/stdlib-types",children:"Standard Library Types"})," - Ruby stdlib type definitions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/learn/advanced/type-aliases",children:"Type Aliases"})," - Advanced aliasing techniques"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/learn/generics/generic-functions-classes",children:"Generics"})," - Generic programming guide"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},6145(e,n,r){r.d(n,{R:()=>l,x:()=>a});var t=r(7140);const i={},s=t.createContext(i);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);