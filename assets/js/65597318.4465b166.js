"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[7451],{4832:e=>{e.exports=JSON.parse('{"permalink":"/news/type-inference-released","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/news/2025-12-24-type-inference.md","source":"@site/news/2025-12-24-type-inference.md","title":"Type Inference: Write Less, Type More","description":"T-Ruby now automatically infers return types from your code. No more explicit annotations for obvious types!","date":"2025-12-24T00:00:00.000Z","tags":[{"inline":true,"label":"release","permalink":"/news/tags/release"},{"inline":true,"label":"feature","permalink":"/news/tags/feature"}],"hasTruncateMarker":false,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"type-inference-released","title":"Type Inference: Write Less, Type More","authors":["yhk1038"],"tags":["release","feature"]},"unlisted":false,"prevItem":{"title":"Introducing T-Ruby","permalink":"/news/introducing-t-ruby"}}')},8885:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var s=r(9378);const t={},i=s.createContext(t);function l(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:n},e.children)}},9738:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});var s=r(4832),t=r(2714),i=r(8885);const l={slug:"type-inference-released",title:"Type Inference: Write Less, Type More",authors:["yhk1038"],tags:["release","feature"]},a=void 0,c={authorsImageUrls:[void 0]},o=[{value:"What&#39;s New",id:"whats-new",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Examples",id:"examples",level:2},{value:"Simple Methods",id:"simple-methods",level:3},{value:"Instance Variables",id:"instance-variables",level:3},{value:"Technical Details",id:"technical-details",level:2},{value:"Try It Now",id:"try-it-now",level:2},{value:"Feedback",id:"feedback",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"T-Ruby now automatically infers return types from your code. No more explicit annotations for obvious types!"}),"\n",(0,t.jsx)(n.h2,{id:"whats-new",children:"What's New"}),"\n",(0,t.jsx)(n.p,{children:"Previously, you had to write:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'def greet(name: String): String\n  "Hello, #{name}!"\nend\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now, the return type is optional:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'def greet(name: String)\n  "Hello, #{name}!"\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["T-Ruby infers that ",(0,t.jsx)(n.code,{children:"greet"})," returns ",(0,t.jsx)(n.code,{children:"String"})," and generates the correct RBS:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rbs",children:"def greet: (name: String) -> String\n"})}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.p,{children:"The new type inference engine analyzes method bodies to determine return types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Literal inference"}),": ",(0,t.jsx)(n.code,{children:'"hello"'})," \u2192 ",(0,t.jsx)(n.code,{children:"String"}),", ",(0,t.jsx)(n.code,{children:"42"})," \u2192 ",(0,t.jsx)(n.code,{children:"Integer"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Method call tracking"}),": ",(0,t.jsx)(n.code,{children:"str.upcase"})," \u2192 ",(0,t.jsx)(n.code,{children:"String"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implicit returns"}),": Ruby's last expression becomes the return type"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Conditional handling"}),": Union types from ",(0,t.jsx)(n.code,{children:"if"}),"/",(0,t.jsx)(n.code,{children:"else"})," branches"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"simple-methods",children:"Simple Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class Calculator\n  def double(n: Integer)\n    n * 2\n  end\n\n  def is_positive?(n: Integer)\n    n > 0\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"Generated RBS:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rbs",children:"class Calculator\n  def double: (n: Integer) -> Integer\n  def is_positive?: (n: Integer) -> bool\nend\n"})}),"\n",(0,t.jsx)(n.h3,{id:"instance-variables",children:"Instance Variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class User\n  def initialize(name: String)\n    @name = name\n  end\n\n  def greeting\n    "Hello, #{@name}!"\n  end\nend\n'})}),"\n",(0,t.jsx)(n.p,{children:"Generated RBS:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rbs",children:"class User\n  @name: String\n\n  def initialize: (name: String) -> void\n  def greeting: () -> String\nend\n"})}),"\n",(0,t.jsx)(n.h2,{id:"technical-details",children:"Technical Details"}),"\n",(0,t.jsx)(n.p,{children:"The inference system is inspired by TypeScript's approach:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BodyParser"}),": Parses T-Ruby method bodies into IR nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TypeEnv"}),": Manages scope chains for variable type tracking"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ASTTypeInferrer"}),": Traverses IR with lazy evaluation and caching"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For a deep dive into the implementation, check out our ",(0,t.jsx)(n.a,{href:"/blog/typescript-style-type-inference",children:"technical blog post"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"try-it-now",children:"Try It Now"}),"\n",(0,t.jsx)(n.p,{children:"Update to the latest T-Ruby and enjoy automatic type inference:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"gem update t-ruby\n"})}),"\n",(0,t.jsx)(n.p,{children:"Your existing code will work as before - explicit types still take precedence. The inference only kicks in when return types are omitted."}),"\n",(0,t.jsx)(n.h2,{id:"feedback",children:"Feedback"}),"\n",(0,t.jsxs)(n.p,{children:["We'd love to hear your experience with type inference. Found an edge case? Have suggestions? Open an issue on ",(0,t.jsx)(n.a,{href:"https://github.com/aspect-build/t-ruby",children:"GitHub"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Happy typing!"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);