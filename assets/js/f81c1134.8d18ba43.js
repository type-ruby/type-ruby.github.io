"use strict";(globalThis.webpackChunkt_ruby_docs=globalThis.webpackChunkt_ruby_docs||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"typescript-style-type-inference","metadata":{"permalink":"/blog/typescript-style-type-inference","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/blog/2025-12-24-type-inference/index.md","source":"@site/blog/2025-12-24-type-inference/index.md","title":"Building TypeScript-Style Type Inference for T-Ruby","description":"How we implemented TypeScript-inspired static type inference for T-Ruby, enabling automatic type detection without explicit annotations.","date":"2025-12-24T00:00:00.000Z","tags":[{"inline":true,"label":"technical","permalink":"/blog/tags/technical"},{"inline":true,"label":"type-inference","permalink":"/blog/tags/type-inference"},{"inline":true,"label":"compiler","permalink":"/blog/tags/compiler"}],"readingTime":4.73,"hasTruncateMarker":true,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"typescript-style-type-inference","title":"Building TypeScript-Style Type Inference for T-Ruby","authors":["yhk1038"],"tags":["technical","type-inference","compiler"]},"unlisted":false,"nextItem":{"title":"Welcome to the T-Ruby Blog","permalink":"/blog/welcome"}},"content":"How we implemented TypeScript-inspired static type inference for T-Ruby, enabling automatic type detection without explicit annotations.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The Problem\\n\\nWhen writing T-Ruby code, developers had to explicitly annotate every return type:\\n\\n```ruby\\ndef greet(name: String): String\\n  \\"Hello, #{name}!\\"\\nend\\n```\\n\\nWithout the `: String` return type, the generated RBS would show `untyped`:\\n\\n```rbs\\ndef greet: (name: String) -> untyped\\n```\\n\\nThis was frustrating. The return type is obviously `String` - why can\'t T-Ruby figure it out?\\n\\n## Inspiration: TypeScript\'s Approach\\n\\nTypeScript handles this elegantly. You can write:\\n\\n```typescript\\nfunction greet(name: string) {\\n  return `Hello, ${name}!`;\\n}\\n```\\n\\nAnd TypeScript infers the return type as `string`. We wanted the same experience for T-Ruby.\\n\\n### How TypeScript Does It\\n\\nTypeScript\'s type inference is built on two key components:\\n\\n1. **Binder**: Builds a Control Flow Graph (CFG) during parsing\\n2. **Checker**: Lazily evaluates types when needed, using flow analysis\\n\\nThe magic happens in `getFlowTypeOfReference` - a 1200+ line function that determines a symbol\'s type at any point in the code by walking backwards through flow nodes.\\n\\n### Our Simplified Approach\\n\\nRuby\'s control flow is simpler than JavaScript\'s. We don\'t need the full complexity of TypeScript\'s flow graph. Instead, we implemented:\\n\\n- **Linear data flow analysis** - Ruby\'s straightforward execution model\\n- **Separation of concerns** - IR Builder (Binder role) + ASTTypeInferrer (Checker role)\\n- **Lazy evaluation** - Types computed only when generating RBS\\n\\n## Architecture\\n\\n```\\n[Binder Stage - IR Builder]\\nSource (.trb) \u2192 Parser \u2192 IR Tree (with method bodies)\\n\\n[Checker Stage - Type Inferrer]\\nIR Node traversal \u2192 Type determination \u2192 Caching\\n\\n[Output Stage]\\nInferred types \u2192 RBS generation\\n```\\n\\n### The Core Components\\n\\n#### 1. BodyParser - Parsing Method Bodies\\n\\nThe first challenge was that our parser didn\'t analyze method bodies - it only extracted signatures. We built `BodyParser` to convert T-Ruby method bodies into IR nodes:\\n\\n```ruby\\nclass BodyParser\\n  def parse(lines, start_line, end_line)\\n    statements = []\\n    # Parse each line into IR nodes\\n    # Handle: literals, variables, operators, method calls, conditionals\\n    IR::Block.new(statements: statements)\\n  end\\nend\\n```\\n\\nSupported constructs:\\n- Literals: `\\"hello\\"`, `42`, `true`, `:symbol`\\n- Variables: `name`, `@instance_var`, `@@class_var`\\n- Operators: `a + b`, `x == y`, `!flag`\\n- Method calls: `str.upcase`, `array.map { |x| x * 2 }`\\n- Conditionals: `if`/`unless`/`elsif`/`else`\\n\\n#### 2. TypeEnv - Scope Chain Management\\n\\n```ruby\\nclass TypeEnv\\n  def initialize(parent = nil)\\n    @parent = parent\\n    @bindings = {}       # Local variables\\n    @instance_vars = {}  # Instance variables\\n  end\\n\\n  def lookup(name)\\n    @bindings[name] || @instance_vars[name] || @parent&.lookup(name)\\n  end\\n\\n  def child_scope\\n    TypeEnv.new(self)\\n  end\\nend\\n```\\n\\nThis enables proper scoping - a method\'s local variables don\'t leak into other methods, but instance variables are shared across the class.\\n\\n#### 3. ASTTypeInferrer - The Type Inference Engine\\n\\nThe heart of the system:\\n\\n```ruby\\nclass ASTTypeInferrer\\n  LITERAL_TYPE_MAP = {\\n    string: \\"String\\",\\n    integer: \\"Integer\\",\\n    float: \\"Float\\",\\n    boolean: \\"bool\\",\\n    symbol: \\"Symbol\\",\\n    nil: \\"nil\\"\\n  }.freeze\\n\\n  def infer_expression(node, env)\\n    # Check cache first (lazy evaluation)\\n    return @type_cache[node.object_id] if @type_cache[node.object_id]\\n\\n    type = case node\\n    when IR::Literal\\n      LITERAL_TYPE_MAP[node.literal_type]\\n    when IR::VariableRef\\n      env.lookup(node.name)\\n    when IR::BinaryOp\\n      infer_binary_op(node, env)\\n    when IR::MethodCall\\n      infer_method_call(node, env)\\n    # ... more cases\\n    end\\n\\n    @type_cache[node.object_id] = type\\n  end\\nend\\n```\\n\\n### Handling Ruby\'s Implicit Returns\\n\\nRuby\'s last expression is the implicit return value. This is crucial for type inference:\\n\\n```ruby\\ndef status\\n  if active?\\n    \\"running\\"\\n  else\\n    \\"stopped\\"\\n  end\\nend\\n# Implicit return: String (from both branches)\\n```\\n\\nWe handle this by:\\n1. Collecting all explicit `return` types\\n2. Finding the last expression (implicit return)\\n3. Unifying all return types\\n\\n```ruby\\ndef infer_method_return_type(method_node, env)\\n  # Collect explicit returns\\n  return_types, terminated = collect_return_types(method_node.body, env)\\n\\n  # Add implicit return (unless method always returns explicitly)\\n  unless terminated\\n    implicit_return = infer_implicit_return(method_node.body, env)\\n    return_types << implicit_return if implicit_return\\n  end\\n\\n  unify_types(return_types)\\nend\\n```\\n\\n### Special Case: `initialize` Method\\n\\nRuby\'s `initialize` is a constructor. Its return value is ignored - `Class.new` returns the instance. Following RBS conventions, we always infer `void`:\\n\\n```ruby\\nclass User\\n  def initialize(name: String)\\n    @name = name\\n  end\\nend\\n```\\n\\nGenerates:\\n\\n```rbs\\nclass User\\n  def initialize: (name: String) -> void\\nend\\n```\\n\\n### Built-in Method Type Knowledge\\n\\nWe maintain a table of common Ruby method return types:\\n\\n```ruby\\nBUILTIN_METHOD_TYPES = {\\n  %w[String upcase] => \\"String\\",\\n  %w[String downcase] => \\"String\\",\\n  %w[String length] => \\"Integer\\",\\n  %w[String to_i] => \\"Integer\\",\\n  %w[Array first] => \\"untyped\\",  # Element type\\n  %w[Array length] => \\"Integer\\",\\n  %w[Integer to_s] => \\"String\\",\\n  # ... 200+ methods\\n}.freeze\\n```\\n\\n## Results\\n\\nNow this T-Ruby code:\\n\\n```ruby\\nclass Greeter\\n  def initialize(name: String)\\n    @name = name\\n  end\\n\\n  def greet\\n    \\"Hello, #{@name}!\\"\\n  end\\n\\n  def shout\\n    @name.upcase\\n  end\\nend\\n```\\n\\nAutomatically generates correct RBS:\\n\\n```rbs\\nclass Greeter\\n  @name: String\\n\\n  def initialize: (name: String) -> void\\n  def greet: () -> String\\n  def shout: () -> String\\nend\\n```\\n\\nNo explicit return types needed!\\n\\n## Testing\\n\\nWe built comprehensive tests:\\n\\n- **Unit tests**: Literal inference, operator types, method call types\\n- **E2E tests**: Full compilation with RBS validation\\n\\n```ruby\\nit \\"infers String from string literal\\" do\\n  create_trb_file(\\"src/test.trb\\", <<~TRB)\\n    class Test\\n      def message\\n        \\"hello world\\"\\n      end\\n    end\\n  TRB\\n\\n  rbs_content = compile_and_get_rbs(\\"src/test.trb\\")\\n  expect(rbs_content).to include(\\"def message: () -> String\\")\\nend\\n```\\n\\n## Challenges & Solutions\\n\\n| Challenge | Solution |\\n|-----------|----------|\\n| Method bodies not parsed | Built custom BodyParser for T-Ruby syntax |\\n| Implicit returns | Analyze last expression in blocks |\\n| Recursive methods | 2-pass analysis (signatures first, then bodies) |\\n| Complex expressions | Gradual expansion: literals \u2192 variables \u2192 operators \u2192 method calls |\\n| Union types | Collect all return paths and unify |\\n\\n## Future Work\\n\\n- **Generic inference**: `[1, 2, 3]` \u2192 `Array[Integer]`\\n- **Block/lambda types**: Infer block parameter and return types\\n- **Type narrowing**: Smarter types after `if x.is_a?(String)`\\n- **Cross-method inference**: Use inferred types from other methods\\n\\n## Conclusion\\n\\nBy studying TypeScript\'s approach and adapting it for Ruby\'s simpler semantics, we built a practical type inference system. The key insights:\\n\\n1. **Parse method bodies** - You can\'t infer types without seeing the code\\n2. **Lazy evaluation with caching** - Don\'t compute until needed\\n3. **Handle Ruby idioms** - Implicit returns, `initialize`, etc.\\n4. **Start simple** - Literals first, then build up complexity\\n\\nType inference makes T-Ruby feel more natural. Write Ruby code, get type safety - no annotations required.\\n\\n---\\n\\n*The type inference system is available in T-Ruby. Try it out and let us know what you think!*"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/type-ruby/t-ruby.github.io/tree/main/blog/2025-12-24-welcome/index.md","source":"@site/blog/2025-12-24-welcome/index.md","title":"Welcome to the T-Ruby Blog","description":"Welcome to the official T-Ruby blog! This is where we\'ll share tutorials, technical deep-dives, and insights about type-safe Ruby development.","date":"2025-12-24T00:00:00.000Z","tags":[{"inline":true,"label":"announcement","permalink":"/blog/tags/announcement"}],"readingTime":0.82,"hasTruncateMarker":true,"authors":[{"name":"Yonghyun Kim","url":"https://github.com/yhk1038","imageURL":"https://github.com/yhk1038.png","key":"yhk1038","page":null}],"frontMatter":{"slug":"welcome","title":"Welcome to the T-Ruby Blog","authors":["yhk1038"],"tags":["announcement"]},"unlisted":false,"prevItem":{"title":"Building TypeScript-Style Type Inference for T-Ruby","permalink":"/blog/typescript-style-type-inference"}},"content":"Welcome to the official T-Ruby blog! This is where we\'ll share tutorials, technical deep-dives, and insights about type-safe Ruby development.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What You\'ll Find Here\\n\\nThis blog will be your go-to resource for:\\n\\n### Tutorials\\n\\nStep-by-step guides to help you get the most out of T-Ruby. From basic type annotations to advanced generic patterns, we\'ll cover it all.\\n\\n### Technical Deep-Dives\\n\\nExplore the internals of T-Ruby\'s type system. Learn how type inference works, how RBS files are generated, and the design decisions behind the project.\\n\\n### Best Practices\\n\\nReal-world patterns and practices for writing type-safe Ruby code. We\'ll share examples from actual projects and discuss common pitfalls to avoid.\\n\\n### Community Highlights\\n\\nShowcasing interesting projects and contributions from the T-Ruby community.\\n\\n## Stay Updated\\n\\nFollow our [News](/news) section for release announcements and project updates. For in-depth content, bookmark this blog and check back regularly.\\n\\nWe\'re excited to share this journey with you. Happy typing!"}]}}')}}]);